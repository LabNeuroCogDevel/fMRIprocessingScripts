#!/bin/bash

function printHelp() {

cat <<EndOfHelp
-----------------------------------
preprocessFunctional is an adaptation of Robert's clean_nonlinear_preproc_all
  script, which preprocesses an entire functional run.

Three files are required for this preprocessing script:
  1) 4d functionals file (-4d command line parameter). Alternative: -dicom
  2) betted mprage scan (-mprage_bet command line parameter)
  3) mprage-to-standard-space warp coefficients (-warpcoef command line parameter)

Command line options:
  -4d: The 4d file containing unprocessed functional volumes for a single subject. Required.
  -bet_frac: fractional intensity threshold for skull-stripping mean functional (used in func-to-struc warp). Default 0.4.
  -cleanup: Deletes all files used in preprocessing that are unlikely to be needed for analysis
  -constrain_to_template: Constrain brain voxels to the corresponding standard template (e.g., MNI). y or n. Default: y.
  -delete_dicom: if converting dicom to nifti, whether delete or archive DICOM files. If not
        passed, user will be prompted for action. Options are:
        -delete_dicom no. (leaves DICOM untouched)
        -delete_dicom yes. (deletes DICOM files)
        -delete_dicom archive. (compresses files into archive file): functional_dicom.tar.gz.
  -deoblique_all: Deoblique all functional datasets (3dWarp -deoblique) after all preprocessing complete: y or n. Default is n.
  -despike: Whether to interpolate intensity spikes using 3dDespike. Occurs early in pipeline: y or n. Default is n.
  -dicom: The file pattern to match all dicom files to be converted to nifti. Must be in quotes.
        Example: -dicom "MR*" (This parameter is an alternative to passing the 4d nifti file using -4d)
  -fieldmap: path to gre field map image
        -fm_mag:  path to field map magnitude image (mag2.nii.gz)
        -fm_cfg:  configuration files for scan (TEs, etc)
  -func_struc_dof: The number of degrees of freedom to be used when co-registering the mean subject
        functional scan to the subject structural scan. Defaults to 12. Other common options are 6 or 7.
  -help: Print command help
  -hp_filter: high-pass filtering frequency (in TRs). Anything faster than this value will be passed. Default is 40.
  -log: Name for log file that documents each command that is run. Default: preprocessFunctional.log
  -motion_sinc: Complete a 4th stage optimization of motion correction using sinc interpolation (slower but better): y or n. Default y.
  -mprage_bet: The betted structural scan for this participant. Required.
  -no_warp: Maintain native space and resolution of input image. Do not warp to a template.
  -ref_vol: Reference volume to be used in motion correction. Will default to mean volume if not passed.
  -rescaling_method: The method used to normalize voxel intensities. Options are:
        -rescaling_method 10000_globalmedian (FSL's default, rescale the 4d file by a single quantity: 10000/[global median])
        -rescaling_method 100_voxelmean (Rescale each voxel by 100/[voxel 4d mean]. In principle, approximates % change)
  -slice_acquisition: The order in which slices were acquired.
        -slice_acquisition seqasc. Sequential ascending (bottom-up)
        -slice_acquisition seqdesc. Sequential descending (top-down)
        -slice_acquisition interleaved. Interleaved 1,3,5... 2,4,6...
  -smoothing_kernel: The size of gaussian smoothing kernel in mm. Default: 5
  -smoother: The smoothing approach to use. Defaults to "susan" (tries to normalize intensities without
        blurring). Alternative is "gaussian", which is regular smoothing.
  -startover: rather than skipping preprocessing stages that have been
        completed, re-run all processing stages, overwriting any existing files.
  -st_first: run slice timing correction first, regardless of slice acquisition order.
        By default, slice timing is run before motion correction for interleaved sequences, but after
        motion correction for sequential acquisition.
  -template_brain: Which standard template brain to use. Default: MNI_3mm. Must match template from mprage normalization. Options:
        -template_brain MNI_3mm (MNI152 brain, 3mm isotropic voxels, template from MNI Fonov et al. 2009)
        -template_brain MNI_FSL_3mm (MNI152 brain, 3mm isotropic voxels, template from FSL standard)
        -template_brain SPM_2mm (MNI brain from spm8 canonical template)
        -template_brain Tal_3mm (Talairach brain, 3mm isotropic voxels. Brain built by resampling MNI template in Tal space)
  -threshold: The method to use for thresholding/masking low intensity voxels. Options are:
        -threshold 98_2 (FSL's default, 2nd %ile + (98th %ile - 2nd %ile)/10
        -threshold 10 (mask any voxels below the 10th percentile)
  -tr: TR duration in seconds.
  -trio_tim: only relevant for -4d input. If set, slice timing correction will check for interleaved
        order and odd vs. even number of slices. If even, will create and use --ocustom file 2,4,6...1,3,5...
  -warpcoef: The warp coefficients used to transform the structural scan to standard space. Required.
  -warp_interpolation: The intepolation method used to warp functional data to the mprage and to the standard space (e.g., MNI). Default: spline.
        -warp_interpolation spline. Use cubic spline interpolation to apply warp coefficients. Faster than sinc and slightly more blurry, but more robust to mask. (Default)
        -warp_interpolation sinc. Provides higher quality non-blurry resampling relative to trilinear, but is slower. N.B. Only works well when the subject's
               functional mask is precise and contains only brain voxels. Otherwise, sinc is prone to stretching the warp strangely.
        -warp_interpolation trilinear. Faster method, but somewhat blurry.

The major steps in the processing pipeline are, in order:
  1)   Intensity despiking (optional) - d
  1.5) field map unwarping - u
  2)   Slice timing correction - t
  3)   Motion correction - m
  4)   Skull stripping - k
  5)   Co-registration and warping to standard space - w
  6)   Smoothing - s
  7)   High-pass filtering - f
  8)   Intensity normalization - n

Note that if the slice acquisition order is sequential, then motion correction is applied before slice timing correction.

Characters are prepended as a prefix to the 4d filename, such that the final processed file will have the
prefix: nfswkmt, indicating the sequence of processing steps, from right to left.

N.B. For the warping to work properly, you must use preprocessMprage for the mprage scan, which uses the same template set.

Example call:
  preprocessFunctional -4d 10802func.nii.gz -mprage_bet 10802mprage.nii.gz -warpcoef mprage_warpcoef.nii.gz -slice_acquisition seqasc \
      -tr 2 -smoothing_kernel 6 -cleanup

-----------------------------------
EndOfHelp

}

#Written: 5/18/2010
#Last updated: 08/02/2012
#
#Changelog:
#08/02/2012
# - make skullstrip and field map unwarp functions
# - fm_cfg for FM unwapring
#07/12/2012
# - Provide -no_warp option to maintain native space.
# - Provide -constrain_to_template option, which defaults to yes. This constrains functional voxels to the standard space anatomical (eliminates extra-brain activation).
#06/07/2012
# - Only retain voxels with non-zero values at all timepoints. Extents mask created before smoothing, applied after.
#06/04/2012
# - Provide option to use SPM8 MNI template.
#05/26/2012
# - Retain rms motion files from mcflirt.
# - Provide -st_first option for those who want to run slice timing first.
#04/10/2012
# - Change skull-stripping and thresholding to apply BET + low intensity + dilate mask to pre-BET data so that BET does not rule edge voxels (follows FEAT).
#04/09/2012
# - incorporate fieldmap unwarping.
#02/06/2012
# - changed default warp interpolation to spline. Sinc was generating too many strange artifacts when functional mask didn't precisely match the boundaries of subject brain.
#01/27/2012
# - small fixes to use of --ocustom, added checks for odd/even with -4d input and added -trio_tim flag
#01/18/2012
# - add --ocustom to acquisitionString for interleaved TrioTim with even num total slices -- Will
#12/5/2011
# - added -log parameter to log the exact preprocessing commands used
#11/17/2011
# - added option to run 3dDespike on functionals prior to motion or slice timing correction.
#10/27/2011
# - put back in 3dresample to orient to LPI. With some of Kirsten's data, warp was failing due to some orientation problem.
#10/18/2011
# - removed 3dresample command to orient original functional to LPI. Bug in AFNI that was flipping storage but not header.
# - Added -f to gzip to overwrite old file.
#9/27/2011
# - Switched dicom conversion to Dimon
# - Default to MNI nonlinear template from Vladimir Fonov (added MNI_FSL_3mm option)
# - Use improved Talairach template (@auto_tlrc approach)
# - Ensure that images are oriented to LPI for MNI space
# - Restrict applywarp to brain voxels (problems with sinc smudging the image when not masked)
# - Use wktm mask based on thresholding step as final mask for subject. (problems with Susan + sinc creating tiny, weird artifacts ringing at the outside of brain)
# - Auto-detect slice acquisition order and TR from DICOM header. Notify user of discrepancies.
# - Create symbolic link to standard space template within subject directory. Documents the template used and makes it easier to view functional data against structural backdrop.
# - Default motion correction sinc interpolation ON. Makes things run slower (~20 min/subject), but can be turned off if user needs results quickly.
# - Create symbolic link to final mask for subject: subject_mask.nii.gz.
# - Remove default TR. Detected from DICOM or must be passed by user.
#6/16/2011
# - SO commented out a delete file command for an file that was never created
#6/13/2011
# - Based on DM's initiative, implemented option for deobliquing datasets as final preprocessing step. For visualization convenience only.
#5/11/2011
# - Now appropriately varies the order of slice timing correction and motion correction depending on sequential vs. ascending slice order
#4/28/2011
# - updated code in the 'startover'section. was missing this: deleteFile ".thresholding_complete" (DM)
# - added a step to remove any previous file left over from dcm2nii before running it (DM)
#4/26/2011:
# - updated code in the 'check for existence of required files' to allow symbolic links to mprage_bet and mprage_warpcoef files (DM)
#3/20/2011:
# - Added final stage mean functional and corresponding mask to be used in GLM
#3/11/2011:
# - Added option for slice acquisition order for proper slice timing correction.
#3/10/2011:
# - Switched default template brain to MNI.
#3/8/2011:
# - Changed rm command to include -f to handle files that lack write permission.
# - Added -motion_sinc parameter for final stage sinc interpolation during motion correction.
# - Added -template_brain parameter to allow choice of MNI vs. Tal.
#11/8/2010:
# - Added -bet_frac parameter for fractional intensity threshold. Default 0.4.
#11/5/2010:
# - Changed default DOF for functional-structural coregistration to 12.
# - Added -func_struc_dof option for setting functional-structural DOF.
#9/2/2010:
# - Changed HP Filter to default of 40 TRs, not 20. 20 seems way too short and 
#     is likely to filter some slower task-related effects. FSL defaults to
#     100s (~66 TRs at TR=1.5), SPM default to 128s. So even 40 may be too fast.
# - Improved checks for median calculation if thresholding complete
#8/9/2010:
# - added rescaling_method parameter to support grand mean rescaling
# - fixed thresholding_complete logic for cases where thresholding complete, but need median_intensity
#7/26/2010:
# - Added dicom processing options
#6/28/2010:
# - updated to improve filename handling with prepending of processing steps.
# - removed robert compatibility settings (forked to preprocessFunctional_Old)

#TODO: 
# - Switch high pass filtering to seconds, not TRs and use bc to calculate #TRs.

function deleteFile() {
    #delete a file, if it exists
    if [ -f "$1" ]; then
	rm "$1"
    fi
}

#rel is shorthand for "run, echo, log"
function rel() {
    #function that runs, echos to terminal, and logs to file an arbitrary command
    cmd="${1}"
    comment=0
    if [[ -n "${2}" && ${2} = c ]]; then
	comment=1
    fi
    
    #echo to screen
    echo ${cmd}

    #run command   
    if [ $comment -eq 0 ]; then
	eval ${cmd}
    fi
    
    if [ -n "${logFile}" ]; then
	if [ $comment -eq 1 ]; then
	    cmd="## ${cmd}"
	fi
	echo "${cmd}" >> "${logFile}"
    fi
}


set -e #exit if any error occurs (stop processing)

export FSLOUTPUTTYPE='NIFTI_GZ'

#initialize defaults
funcFile=
smoothing_kernel="5"
betFrac=0.4 #default fractional intensity threshold
cleanup=0
constrainToTemplate="y"
deoblique_all="n"
despike="n"
delDicom=
detectTrioTim=0
dicomPattern=
dte=
fieldmap=
fm_mag=
fm_cfg=
funcStructFlirtDOF=12
funcWarpInterp="spline"
hpFilter=40
logFile="preprocessFunctional.log"
motionSinc="y"
no_warp=0
ref_vol=  #don't set a motion correction reference volume by default
rescalingMethod="10000_globalmedian" #scale whole brain 4D by single constant to normalize median to 10000.
sliceAcquisition= #never assume slice acquistion order. Force definition or use auto-detect from DICOM.
smoother="susan"
st_first=0
thresholdMethod="98_2"
tr= #never assume a TR. Force definition or use auto-detect from DICOM.
templateBrain="$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_3mm" #default to new 2009 MNI

#if no parameters are passed in, then print help and exit.
if [ $# -eq 0 ]; then
    printHelp
    exit 0
fi

#process command line parameters
while [ _$1 != _ ] ; do
    if [[ $1 = -4d || $1 = -4D ]] ; then
	funcFile="${2}"
	funcNifti="${funcFile}" #retains file extension
	shift 2
    elif [ $1 = -bet_frac ]; then
	betFrac="${2}"
	shift 2
    elif [ $1 = -cleanup ]; then
	cleanup=1
	shift 1
    elif [ $1 = -constrain_to_template ]; then
	if [[ $2 = [NnYy] ]]; then
	    constrainToTemplate="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -constrain_to_template parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -delete_dicom ]; then
	delDicom="${2}"
	shift 2
    elif [ $1 = -deoblique_all ]; then
	if [[ $2 = [NnYy] ]]; then
	    deoblique_all="${2}"
	    shift 2
	else
	    echo -e "Unrecognized deoblique_all parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -despike ]; then
	if [[ $2 = [NnYy] ]]; then
	    despike="${2}"
	    shift 2
	else
	    echo -e "Unrecognized despike parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
#    elif [ $1 = -dwell_time ]; then
#	dte="${2}"
#	shift 2

    elif [ $1 = -fieldmap ]; then
	fieldmap="${2}"
	shift 2
    elif [ $1 = -fm_mag ]; then
	fm_mag="${2}"
	shift 2
    elif [ $1 = -fm_cfg ]; then
	fm_cfg="${2}"
	shift 2

    elif [ $1 = -func_struc_dof ]; then
	funcStructFlirtDOF="${2}"
	shift 2
    elif [ $1 = -dicom ]; then
	dicomPattern="${2}"
	shift 2
    elif [ $1 = -help ]; then	
	printHelp
	exit 0
    elif [ $1 = -hp_filter ]; then
	hpFilter="${2}"
	shift 2
    elif [ $1 = -log ]; then
	logFile="${2}"
	shift 2
    elif [ $1 = -motion_sinc ]; then
	if [[ $2 = [NnYy] ]]; then
	    motionSinc="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -motion_sinc parameter: ${2}.\n  Options are: y or n."
	    exit 1
	fi
    elif [ $1 = -mprage_bet ]; then
	mprageBet="${2}"
	shift 2
    elif [ $1 = -no_warp ]; then
	no_warp=1
	shift 1
    elif [ $1 = -ref_vol ] ; then
        ref_vol="${2}"
        shift 2
    elif [ $1 = -rescaling_method ]; then
	if [[ $2 = "10000_globalmedian" || $2 = "100_voxelmean" ]]; then
	    rescalingMethod="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -rescaling_method: ${2}.\n  Options are: -rescaling_method 10000_globalmedian or -rescaling_method 100_voxelmean"
	    exit 1
	fi
    elif [ $1 = -slice_acquisition ]; then
	if [[ $2 = "interleaved" || $2 = "seqasc" || $2 = "seqdesc" ]]; then
	    sliceAcquisition="${2}"
	    shift 2
	else
	    echo "Slice acquisition setting not recognized. Options are: seqdesc, seqasc, and interleaved"
	    exit 1
	fi
    elif [ $1 = -smoother ]; then
	smoother="${2}"
	shift 2
    elif [ $1 = -startover ]; then
	echo -e "\nStarting over...\n\nRe-running all preprocessing steps\n"
	deleteFile ".motion_plots_complete"
	deleteFile ".slice_timing_complete"
	deleteFile ".motion_correction_complete"
	deleteFile ".skull_strip_complete"
	deleteFile ".warp_complete"
	deleteFile ".smoothing_complete"
	deleteFile ".temporal_filtering_complete"
	deleteFile ".rescaling_complete"
	deleteFile ".thresholding_complete"
	deleteFile ".despike_complete"
	shift 1
    elif [ $1 = -smoothing_kernel ] ; then
        smoothing_kernel="${2}"
        shift 2
    elif [ $1 = -st_first ]; then
	st_first=1
	shift 1
    elif [ $1 = -template_brain ]; then
	case $2 in
	    Tal_3mm) templateBrain="$HOME/standard/talairach_fsl_mni152/TalFSL_MNI152_T1_3mm_brain" ;;
	    MNI_FSL_3mm) templateBrain="$HOME/standard/fsl_mni152/MNI152_T1_3mm_brain" ;;
	    MNI_3mm) templateBrain="$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_3mm" ;;
	    SPM_2mm) templateBrain="$HOME/standard/spm8_mni/T1_brain" ;;
	    *) echo -e "Reference brain -template_brain ${2} not recognized. Options are MNI_3mm, MNI_FSL_3mm, SPM_2mm, and Tal_3mm."; exit 1 ;;
	esac
	shift 2
    elif [ $1 = -threshold ]; then
	if [[ $2 = "98_2" || $2 = "10" ]]; then
	    thresholdMethod="${2}"
	    shift 2
	else
	    echo -e "Unrecognized thresholding parameter: ${2}.\n  Options are: 98_2 or 10."
	    exit 1
	fi
    elif [ $1 = -tr ]; then
	tr="${2}"
        shift 2
    elif [ $1 = -trio_tim ]; then
	detectTrioTim=1
	shift 1
    elif [ $1 = -warpcoef ]; then
	warpCoef="${2}"
	shift 2
    elif [ $1 = -warp_interpolation ]; then
	if [[ $2 = "sinc" || $2 = "trilinear" || $2 = "spline" ]]; then
	    funcWarpInterp="${2}"
	    shift 2
	else
	    echo -e "Unrecognized -warp_interpolation parameter: ${2}.\n  Options are: sinc, spline, or trilinear."
	    exit 1
	fi
    else
	printHelp
	echo -e "----------------\n\n"
	echo "Unrecognized command line parameter: ${1}"
	exit 1
    fi
done

if [ -n "${logFile}" ]; then
    if [ -f "${logFile}" ]; then
	rm -f "${logFile}"
    fi
    echo "#!/bin/bash" > "${logFile}"
    echo "## Log of preprocessFunctional commands" >> "${logFile}"
fi



################################################################################
# Setup
################################################################################

#The smoothing kernel parameter is expected to be the full width at half
#maximum (FWHM) value (in mm). FWHM refers to the width of the Gaussian shape
#on the x-axis at half of the maximum y value
#(see http://imaging.mrc-cbu.cam.ac.uk/imaging/PrinciplesSmoothing).
#It is common to conceptualize Gaussian curves in terms of their standard
#deviation (sigma). Sigma is related to FWHM by the following equation:
#FHWM=sigma * sqrt(8*log(2))
#Hence, because FSL expects our smoothing specification to be a sigma,
#we divide the FWHM value provided by $smoothing_kernel by 2.355 (approximately
#8*log(2).

sigma=$( echo "scale=5; $smoothing_kernel/2.355" | bc )
#echo "sigma is: $sigma"

#check that slice acquisition order and TR was specified or detected in case of 4d input
if [ -n "$funcFile" ]; then
    if [ -f .detect_sliceorder ]; then
	if [ -n "$sliceAcquisition" ]; then
	    rel "Ignoring user setting for slice acquisition: ${sliceAcquisition} because of auto-detected order in .detect_sliceorder." c
	fi

	sliceAcquisition=$( cat .detect_sliceorder )
    fi

    if [ -z $sliceAcquisition ]; then
	echo -e "Slice acquisition order was not specified and not detected.\nPass using the -slice_acquisition parameter.\nExiting.\n"
	exit 1
    fi

    if [ -f .detect_tr ]; then
	if [ -n "$tr" ]; then
	    rel "Ignoring user setting for TR: ${tr} because of auto-detected TR in .detect_tr." c
	fi  

	tr=$( cat .detect_tr )
    fi

    if [ -z $tr ]; then
	echo -e "TR was not specified and not detected.\nPass using the -tr parameter.\nExiting.\n"
	exit 1
    fi

    #check number of slices
    #if DICOMs used, num slices will be picked up by section below
    detectSliceNum=$( fslhd ${funcFile}  | grep '^dim3' | perl -pe 's/dim3\s+(\d+)/\1/' )

fi


#check for existence of required files
#mprageBet and warpCoef only required if warping to a standard template. Thus, don't require for -no_warp runs.
if [ $no_warp -eq 0 ]; then
    if [ -z $mprageBet ]; then
	echo -e "Betted mprage file parameter not provided.\nPass using the -mprage_bet parameter.\nExiting.\n"
	exit 1
    elif [[ ! -f $mprageBet ]] && [[ ! -h ${mprageBet} ]]; then
	echo -e "Betted mprage file: $mprageBet does not exist.\nExiting.\n"
	exit 1
    fi

    if [ -z $warpCoef ]; then
	echo -e "Structural to standard space warp coefficients file (from FNIRT) not provided.\nPass using the -warpcoef parameter.\nExiting.\n"
	exit 1
    elif [[ ! -f $warpCoef ]] && [[ ! -h ${warpCoef} ]]; then
	echo "Structural to standard space warp coefficients file does not exist.\nFile specified: $warpCoef.\nExiting.\n"
	exit 1
    fi
fi


#check file extensions to see if file was passed in with nii or nii.gz extension
#could be made more efficient by combining nii and nii.gz section
if [ -z $funcFile ]; then

    #if 4d file not passed, check for dicom pattern
    #need dicomPattern in quotes to avoid expansion
    if [ -z "$dicomPattern" ]; then
	echo -e "No 4d file provided to script. This file is required.\nPass using the -4d parameter.\n"
	echo -e "Alternatively, pass a dicom file pattern, such as -dicom \"MR*\"\nExiting.\n"
	exit 1
    else
	#process dicom files first
	#code duplicated from preprocessMprage... could create a third file for shared functions
        #check whether files exist
        #numFiles=$( ls | grep "$dicomPattern"  | wc -l )
	numFiles=$( ls $dicomPattern | wc -l )
	if [ $numFiles -eq 0 ]; then
	    echo "No DICOM files found using pattern: $dicomPattern. If you have already converted DICOM to NIFTI and want to skip this step, pass in the 4d functionals file using the -4d parameter. Example: preprocessFunctional -4d 10802_func.nii.gz"
	    exit 1
	fi

	funcFile="functional" #base name for preprocessing steps below
	funcNifti="functional.nii.gz"

	#look for TR and slice acquisition order in Dicom
	firstDicom=$( find . -iname "${dicomPattern}" -type f | head -1 )
	dicomHdr=$( dicom_hdr -sexinfo "${firstDicom}" )
	detectTR=$( echo "${dicomHdr}" | grep "0018 0080.*ACQ Repetition Time" | perl -pe 's/.*ACQ Repetition Time\/\/(\d+)$/\1/' )
	detectTR=$( echo "scale=3; ${detectTR}/1000" | bc ) #convert to seconds from milliseconds
	detectSliceOrder=$( echo "${dicomHdr}" | grep "sSliceArray.ucMode" | perl -pe 's/sSliceArray.ucMode\s+=\s+(\dx\d)$/\1/' )

	if [ "${detectSliceOrder}" = "0x1" ]; then
	    detectSliceOrder="seqasc"
	elif [ "${detectSliceOrder}" = "0x2" ]; then
	    detectSliceOrder="seqdesc"
	elif [ "${detectSliceOrder}" = "0x4" ]; then
	    detectSliceOrder="interleaved"
            #used to test need for ocustom switch in slicetimer
            detectTrioTim=$(    echo "${dicomHdr}" | perl -ne 'print "1" if /TrioTim/' )
            detectSliceNum=$(   echo "${dicomHdr}" | perl -ne 'print $1  if /sSliceArray.lSize\W+=\W?(\d+)/' )
	fi

	rel "Auto-detecting TR and slice acquisition order from DICOM header: ${firstDicom}" c
	rel "  Detected TR: ${detectTR}s" c
	rel "  Detected Slice Order: ${detectSliceOrder}" c
	rel "  Number of slices: ${detectSliceNum}" c
	rel "  If this is incorrect, please exit the script now by pressing Ctrl-C" c

	sleep 3

	#check auto-detect against user specification
	if [ -n "${tr}" ]; then
	    trEquiv=$( echo "${tr} == ${detectTR}" | bc )	    
	    if [ ${trEquiv} -eq 0 ]; then
		echo "Specified TR: ${tr} does not match detected TR: ${detectTR}"
		echo "Exiting script. Please resolve discrepancy."
		exit 1
	    fi
	fi

	if [ -n "${sliceAcquisition}" ] && [ "${sliceAcquisition}" != "${detectSliceOrder}" ]; then
	    echo "Specified slice order: ${sliceAcquisition} does not match detected slice order: ${detectSliceOrder}"
	    echo "Exiting script. Please resolve discrepancy."
	    exit 1
	fi

	#set run parameters based on auto-detected settings
	tr=${detectTR}
	sliceAcquisition=${detectSliceOrder}

	echo "${detectTR}" > .detect_tr
	echo "${detectSliceOrder}" > .detect_sliceorder
	
	#remove functional.nii if it exists so that Dimon doesn't bomb out
	if [ -f functional.nii ]; then
	    rm -f functional.nii
	fi

	rel "Dimon \
	    -infile_pattern \"${dicomPattern}\" \
	    -GERT_Reco \
	    -quit \
	    -dicom_org \
	    -sort_by_acq_time \
	    -gert_write_as_nifti \
	    -gert_create_dataset \
	    -gert_to3d_prefix functional"

	rm -f dimon.files*
	rm -f GERT_Reco_dicom*

        #if afnirc has compressor on, then above will already generate nii.gz
	if [ -f functional.nii ]; then
	    rel "gzip -f functional.nii" #use -f to force overwrite in case where functional.nii.gz exists, but we want to replace it.
	fi

	#default to LPI
	#hopefully the 3dresample bug is fixed:
	#http://afni.nimh.nih.gov/afni/community/board/read.php?f=1&i=39923&t=39923
	rel "3dresample -overwrite -orient LPI -prefix \"functional.nii.gz\" -inset \"functional.nii.gz\""

        #Ask user what to do with original DICOM files unless passed on command line
	if [ -z $delDicom ]; then
	    until [[ "$delDicom" = [AaNnYy] ]]; do
		read -sn1 -p "Delete or archive original DICOM files? (y/n/a)" delDicom
	    done
	else
	    delDicom=${delDicom:0:1} #retain only the first character
	fi

	case ${delDicom} in
	    y|Y) echo -e "\nDeleting DICOM files"; rm -f ${dicomPattern} ;;
	    n|N) echo -e "\nKeeping DICOM files" ;;
	    a|A) echo -e "\nArchiving DICOM files (functional_dicom.tar.gz)"; tar czf functional_dicom.tar.gz ${dicomPattern} && rm -f ${dicomPattern} ;;
	esac
	sleep 1

        #end duped code
    fi
elif [ ${funcFile:(-7)} = ".nii.gz" ]; then
    if [ ! -f ${funcFile} ]; then
	echo -e "Raw functional 4D file: $funcFile does not exist.\nPass in as -4d parameter. Exiting.\n"
	exit 1
    else
	#strip off the suffix for FSL processing and makes filenames easier to build.
	lenFile=${#funcFile}
	lenSub=$( expr $lenFile - 7 )
	funcFile=${funcFile:0:$lenSub}
    fi
elif [ ${funcFile:(-4)} = ".nii" ]; then
    if [ ! -f ${funcFile} ]; then
	echo -e "Raw functional 4D file: $funcFile does not exist.\nPass in as -4d parameter. Exiting.\n"
	exit 1
    else
	#strip off the suffix for FSL processing
	lenFile=${#funcFile}
	lenSub=$( expr $lenFile - 4 )
	funcFile=${funcFile:0:$lenSub}
    fi
else
    #passed in parameter does not have nii or nii.gz extension. Need to test for file
    if [[ ! -f "${funcFile}.nii" && ! -f "${funcFile}.nii.gz" ]]; then
	echo -e "Raw functional 4d file: $funcFile does not exist.\nAttempted to look for ${funcFile}.nii and ${funcFile}.nii.gz to no avail.\nExiting.\n"
	exit 1
    fi
fi

#echo -e "Functional 4d filename: $funcFile\n\n"
#set -x #echo all executed commands from this point forward

if [[ ${motionSinc} = [Yy] ]]; then
    mcflirtSinc="-stages 4 -sinc_final"
else
    mcflirtSinc=
fi

prefix= #tracks file prefix indicating which processing has been performed

#MOTION PLOTS
if [ ! -f ".motion_plots_complete" ]; then

    #####
    #create rotation, translation, and displacement plots of subject motion
    #If ref_vol is not provided, then mcflirt defaults to middle volume.

    rel "1. Creating subject motion plots" c
    if [ -z $ref_vol ]; then
	rel "mcflirt -in $funcFile -o mcplots -plots -rmsabs -rmsrel"
    else
	rel "mcflirt -in $funcFile -o mcplots -plots -rmsabs -rmsrel -refvol $ref_vol"
    fi

    #rotations plot
    rel "fsl_tsplot -i mcplots.par -t 'MCFLIRT estimated rotations (radians)' -u 1 --start=1 --finish=3 -a x,y,z -w 800 -h 300 -o rot.png"

    #translations plot
    rel "fsl_tsplot -i mcplots.par -t 'MCFLIRT estimated translations (mm)' -u 1 --start=4 --finish=6 -a x,y,z -w 800 -h 300 -o trans.png"

    #displacement plot
    rel "fsl_tsplot -i mcplots_abs.rms,mcplots_rel.rms -t 'MCFLIRT estimated mean displacement (mm)' -u 1 -w 800 -h 300 -a absolute,relative -o disp.png"

    #cleanup files generated for plots (save mcplots.par)
    #old approach, which only keep motion parameters, not RMS.
    #rel "ls -d mcplots* | grep -v mcplots.par | xargs rm -rf"
    #remove the motion-correction 1) NIFTI 2) mean abs RMS 3) mean rel RMS 4) transformation matrices
    #this should retain the abs and rel RMS vectors and the mcplots.par, which contains motion estimates
    rel "rm -rf mcplots.nii.gz mcplots_abs_mean.rms mcplots_rel_mean.rms mcplots.mat"

    rel "touch .motion_plots_complete"
fi

#optional despiking - first step
if [[ ${despike} = [Yy] ]]; then
    prefix="d_"

    if [ ! -f ".despike_complete" ]; then
	rel "3dDespike -overwrite -prefix \"${prefix}${funcNifti}\" \"${funcNifti}\""
	rel "touch .despike_complete"
    fi
fi

################################################################################
# functions for preprocessing
################################################################################


function runSliceTimingCorrection {
    #SLICE TIMING CORRECTION

    #file naming changes depending on motion vs. slice timing first
    #problem arises with adding initial _ to prefix of funcFile
    if [ -z ${prefix} ]; then
	infile="${funcFile}"
	prefix="t_"
	outfile="${prefix}${funcFile}"
    else
	infile="${prefix}${funcFile}"
	prefix="t${prefix}"
	outfile="${prefix}${funcFile}"
    fi

    if [ ! -f ".slice_timing_complete" ]; then

        #####
        #Slice timing correction. Note that slice timing correction should
        #be performed before motion correction for interleaved acquisition,
        #but after motion correction for sequential acquisition.

        #For interleaved data, slice timing is performed on the original 4D file: -i ${funcFile}
	#For sequential data, slice timing is performed on the motion-corrected 4D file: -i m_${funcFile}
        #Slice timed functionals are output to t_$funcFile: -o "${prefix}${funcFile}"
        #TR is specified by -r
        #--odd specifies interleaved order
	#--down specifies sequential descending
        #--ocustom filename of single-column custom interleave order file (first slice is referred to as 1 not 0)
	#slicetimer default is ascending, so no need to create acquitionString for this setting

	rel "Running slice timing correction" c

	acquisitionString=
	if [ $sliceAcquisition = interleaved ]; then

            # if slice number is even and triotrim is set 
            # need to create a custom slice order file
            # put all even slices first, then all odd slices
            # use this file with --ocustom switch option to slicetimer
            if [ $((($detectSliceNum%2))) = 0 ] && [ $detectTrioTim -eq 1 ]; then

		rel "  Siemens Trio Tim scanner with even number of slices detected" c
		rel "  Using custom slice order file --ocustom with order 2,4,6...1,3,5..." c
		
		acqCustFile='.triotim_evenSliceNum_acquisitionOrder'


		#num=$detectSliceNum perl -le \
                #    'for $i (2,1){                      # for all even slices, then all odd slices
                #     $j=-2+$i; 
                #     print $j+=2 while $j<=$ENV{num}-2 # $j+=2 doesnt return as expected in condition context
                #    }' > $acqCustFile
                ##same thing, but more concise 
                # print evens(%2==0), then print odds (%2==1)
                n=$detectSliceNum \
                 perl -le '$,="\n"; @a=1..$ENV{n}; for $i (0,1){ print grep {$_%2==$i} @a }' > $acqCustFile
		
		acquisitionString="--ocustom=$acqCustFile"
		
            else
		acquisitionString="--odd"
            fi
	elif [ $sliceAcquisition = seqdesc ]; then
	    acquisitionString="--down"
	fi

	rel "slicetimer -i \"${infile}\" -o \"${outfile}\" -r $tr ${acquisitionString}"

	rel "touch .slice_timing_complete"
    fi
}
# mcFunctional needs to be global: fm unwarping will generate its own mc files if it can't find it
mcFunctional="null"
function runMotionCorrection {
    #MOTION CORRECTION

    #file naming changes depending on motion vs. slice timing first
    #problem arises with adding initial _ to prefix of funcFile
    if [ -z ${prefix} ]; then
	infile="${funcFile}"
	prefix="m_"
	outfile="${prefix}${funcFile}"
    else
	infile="${prefix}${funcFile}"
	prefix="m${prefix}"
	outfile="${prefix}${funcFile}"
    fi


    mcFunctional=$outfile
    if [ ! -f ".motion_correction_complete" ]; then

        #####
        #Motion correction.
        #input: slice-time-corrected 4D file
        #output: motion-corrected, slice-time-corrected 4D file.
        #Defaults to mean volume correction unless -refvol passed.

        additionalParams="-mats -plots -meanvol -rmsrel -rmsabs"

	rel "Running motion correction" c
	if [ -z $ref_vol ]; then
        #if no reference volume specified, correct to the mean volume
	    rel "Using mean volume for motion correction" c
	    rel "mcflirt -in \"${infile}\" -o \"${outfile}\" -meanvol ${mcflirtSinc}"
            if [ -n  ${fieldmap} ]; then
              #-plots/-mat  and -meanvol are mutally excluse 
              # need mat for field map unwarp
              # https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=FSL;82b968f7.0708#TOP
              # do mc twice, first to get mean and then to correct to it
              #
              # TODO: is a Tmean example_func approprate?
              #
              rel "mc -> Tmean -> mc again with Tmean ref (gen MAT for FM unwarp)" c
              rel "fslmaths \"${outfile}\" -Tmean example_func"
              rel "mcflirt -in \"${infile}\" -o \"${outfile}\" -reffile example_func ${mcflirtSinc} $additionalParams "
            fi
	else
	    rel "Using volume number: $ref_vol for motion correction" c
	    rel "mcflirt -in "${infile}" -o "${outfile}" -refvol $ref_vol ${mcflirtSinc} $additionalParams"
	    rel "And extract refrence as an example of the functional set" c
            rel  "fslroi prefiltered_func_data example_func $ref_vol 1"
	fi

        #mkdir mc && mv *rms *par *mat/ $_ 
        [ -r $prefix*rms ] && mkdir mc && mv $prefix*{rms,par,mat/} $_ 
	rel "touch .motion_correction_complete"
    fi
}

function runFieldMapUnwarp {
   # unwarp FieldMap
   # prefix: u    -- hardcoded in immv and prefix= below
   if [[ -n ${fieldmap} && ! -f ".unwarp_complete" ]]; then
       
       #expect:
       # -fieldmap
       # -fm_mag
       # -fm_cfg
       # does functional need to be skull stripped?!

       rel "Applying fieldmap" c
     
       logFile=$logFile \
        $(dirname $0)/preprocessFMUnwarp -f $prefix$funcFile -m $fm_mag -g $fieldmap -c $fm_cfg --mcFunctional $mcFunctional
       # creates unwarp_thumbnails dirctory
       # leaves prefiltered_func_data_unwarp.nii

       immv prefiltered_func_data_unwarp.nii u$prefix$funcFile

       #touch .unwarp_complete
       date >> .unwarp_complete

       # record actions in nii files
       # addNote $prefix$funcFile  \
       #   "$(dirname $0)/preprocessFMUnwarp -f $prefix$funcFile -m $fm_mag -g $fieldmap -c $fm_cfg"

   fi

   # set prefix to include unwarping given we did this
   [ -n ${fieldmap} ] && prefix="u$prefix" 
}

#betBrain is global
betBrain=
function runSkullStrip {
   #SKULL STRIPPING
   if [ ! -f ".skull_strip_complete" ]; then
       #####
       #Compute the mean functional: mt_mean_func.nii.gz
       #Used in warping subjects mean T2* to his/her T1 structural scan

       rel "4. Computing mean functional" c
       rel "fslmaths \"${prefix}${funcFile}\" -Tmean \"${prefix}mean_func\""

       #####
       #Skull strip the mean functional: kmt_mean_func.nii.gz

       rel "5. Skull stripping functionals" c
       rel "bet \"${prefix}mean_func\" \"k${prefix}mean_func\" -R -f ${betFrac} -m"

       #Use the mask generated from skull stripping the mean functional to strip all functionals
       rel "fslmaths \"${prefix}${funcFile}\" -mas \"k${prefix}mean_func_mask\" \"k${prefix}${funcFile}\""


       #old approach commented out below.
       #used to run -F separately on 4d functionals, which runs bet with 0.3 on first volume of 4d, dilates mask
       #new approach is to use mask from betting mean functional, which coincides better with FEAT and allows
       #greater control of skull stripping using -bet_frac
       #####
       #Skull strip the 4D functional file: kmt_$funcFile
       #-F strips each functional using -f 0.3 with slight dilation of brain mask
       #note that -F also generates a mask file: kmt_$funcFile_mask.nii.gz (this is never used, I think)
       #
       #bet "${prefix}${funcFile}" "k${prefix}${funcFile}" -F

       touch ".skull_strip_complete"

   fi



   #store the pre-bet file for application of combined BET + intensity mask below
   preBet="${prefix}${funcFile}"
   prefix="k${prefix}"
}




################################################################################
# EPI 
################################################################################

#determine precedence of slice timing and motion correction
#if sequential, then 1) motion correct, 2) slice timing correct
#if interleaved, then 1) slice timing correct, 2) motion correct

#NOTE: this is inefficient for sequential designs because motion correction is already
#run for motion plots. But I don't have time to tweak the script to use the parameters from motion plots
#as motion correction.

# NOTE2: Jesper Andersson <jesper@fmrib.ox.ac.uk> (FSL mailing list)
# In short: The correct thing is to do a 4D interpolation, but that is practically cumbersome. 
# When doing them sequentially you start with the one that introduces the biggest variance/error,
# and that is definitely movement.
# My suggestion is 1) Movement+fieldmap 2) Slice timing.
#
if [[ $sliceAcquisition = interleaved || $st_first -eq 1 ]]; then
    runSliceTimingCorrection
    runMotionCorrection
    runFieldMapUnwarp
elif [[ $sliceAcquisition = "seqasc" || $sliceAcquisition = "seqdesc" ]]; then
    runMotionCorrection
    runFieldMapUnwarp
    runSliceTimingCorrection
fi


runSkullStrip



#THRESHOLDING LOW INTENSITY VOXELS
if [[ ! -f ".thresholding_complete" && $thresholdMethod = "10" ]]; then
    rel "Thresholding 4d functionals by masking any voxel below the 10th percentile \(distribution is non-zero voxels\)." c

    #####
    #calculate the 10th percentile of non-zero voxels
    #input: slice-timed, motion-corrected, skull-stripped 4D functionals

    P_10=$( fslstats "${prefix}${funcFile}" -P 10 )

    #####
    #for each voxel, calculate the minimum activation value for the
    #run (i.e., over time) and create a single volume with all minima.
    #output: kmt_$funcFile_Tmin.nii.gz
    rel "fslmaths \"${prefix}${funcFile}\" -Tmin \"${prefix}${funcFile}_Tmin\""

    #####
    #Threshold the minimum activation volume by zeroing all values below the
    #10th percentile in the 4D file.
    #input: single volume with minimum activation values over the run: kmt_$funcFile_Tmin.nii.gz
    #output: single volume with minimum activation values over the run, with any value < 10th percentile set to 0: kmt_$funcFile_Tmin_10pctThr.nii.gz

    rel "fslmaths \"${prefix}${funcFile}_Tmin\" -thr $P_10 \"${prefix}${funcFile}_Tmin_10pctThr\""

    #####
    #Create a binary mask from the thresholded minimum activation volume,
    #where any non-zero value receives a value of 1 in the mask, and any 0 value
    #is 0 in the mask. Essentially, any
    #voxel that was below the 10th percentile in the original data will be zeroed.
    #output: mask_$funcFile_Tmin_10pctThr.nii.gz

    rel "fslmaths \"${prefix}${funcFile}_Tmin_10pctThr\" -bin \"mask_${funcFile}_Tmin_10pctThr\" -odt char"

    #####
    #Mask the slice-timed, motion-corrected, skull-stripped 4D functionals
    #file using the mask created above.
    #output: slice-timed, motion-corrected, skull-stripped, 10th percentile thresholded 4D file: kmt_$funcFile_masked.nii.gz

    rel "fslmaths \"${prefix}${funcFile}\" -mas \"mask_${funcFile}_Tmin_10pctThr\" \"${prefix}${funcFile}_masked\""

    threshMask="mask_${funcFile}_Tmin_10pctThr"

    rel "touch .thresholding_complete"

elif [[ ((! -f ".thresholding_complete") && $thresholdMethod = "98_2") || $smoother = "susan" || $rescalingMethod = "10000_globalmedian" ]]; then

    #set -x
    p_2=$( fslstats "${prefix}${funcFile}" -p 2 )
    p_98=$( fslstats "${prefix}${funcFile}" -p 98 )

    #note that this threshold calculation is based on FEAT's brain/background threshold of 10
    #the FEAT calculation is p2 + (brain_thresh * (p98 -p2))/100. When brain_thresh is 10, cancels a zero.
    thresh=$( echo "scale=5; $p_2 + ($p_98 - $p_2)/10" | bc )

    #create mask that zeroes anything below threshold.
    #because this mask is computed on the skull-stripped data, it also reflects skull stripping
    rel "fslmaths \"${prefix}${funcFile}\" -thr $thresh -Tmin -bin \"${prefix}${funcFile}_98_2_mask\" -odt char"

    #calculate median intensity (after dumping thresholded voxels) -- compute this prior to dilation to avoid inclusion of 0 voxels
    #Echoing the FEAT approach, compute this on pre-bet data, with mask applied. Should have little or no effect since the mask 
    #effectively does BET since it was generated from post-BET data.
    median_intensity=$( fslstats "${preBet}" -k "${prefix}${funcFile}_98_2_mask" -p 50 )

    #dilate mask (drawing from FEAT). This creates a liberal mask unlikely to delete brain voxels
    #Logic and dilF command not well documented in FSL.
    rel "fslmaths \"${prefix}${funcFile}_98_2_mask\" -dilF \"${prefix}${funcFile}_98_2_mask_dil1x\""

    #susan requires the 2nd pctile and the median intensity to auto-calculate brightness threshold
    #but if 98_2 thresholding requested, then actually apply the resulting mask
    if [[ $thresholdMethod = "98_2" && ! -f ".thresholding_complete" ]]; then
	rel "Thresholding 4d functionals by zeroing any voxel below the value: 2nd %ile + \(98th %ile - 2nd %ile\)/10" c
	rel "This is the default thresholding method used by FSL GUI tools." c

	#Apr2012: Following FEAT, apply the mask to pre-BET data. The logic is that BET may cut out too much brain.
	#We have generated a mask that reflects: 1) Skull strip; 2) removal of low intensity; 3) 1x mask dilation
	#If we were to apply this mask to post-BET data, the 1x dilation would essentially be irrelevant since BET would 
	#have already zeroed those data.
	rel "fslmaths \"${preBet}\" -mas \"${prefix}${funcFile}_98_2_mask_dil1x\" \"${prefix}${funcFile}_masked\""
	
	rel "touch .thresholding_complete"
    fi

    threshMask="${prefix}${funcFile}_98_2_mask_dil1x"

fi

#ALIGN FUNCTIONAL AND STRUCTURAL, WARP TO TEMPLATE SPACE
if [[ ! -f ".warp_complete" && $no_warp -eq 0 ]]; then
    #####
    #Obtain a transformation matrix that co-registers the subject's
    #structural T1 scan with his/her mean functional T2* image.

    #note that I changed the dof setting for flirt to 7, which is a rigid body
    #transformation (6 df) with 1 additional df allowing for global rescaling.
    #the default is 12df, which is affine, but this isn't appropriate for
    #images from the same person.

    #as currently written, this creates a warped functional (perhaps important
    #for checking the success of the warp), but the important part is the
    #transformation matrix: func_to_mprage.mat

    rel "6. Warping subject mean functional to subject structural (intrasubject)" c
    rel "flirt -in \"${prefix}mean_func\" -ref $mprageBet -out func_to_mprage -omat func_to_mprage.mat -dof $funcStructFlirtDOF"

    #####
    #Warp all T2* functionals to standard space (sampled at 3mm isotropic)
    #input: slice-timed, motion-corrected, skull-stripped, thresholded
    #  4D functionals: kmt_$funcFile 
    #output: 4D functionals file warped to Talairach space, resampled to
    #  3mm isotropic voxels: wkmt_$funcFile

    #note that I switched over to sinc interpolation, which is slowest, but best.
    #applywarp defaults to trilinear, which blurs the image.

    #--ref: Reference brain. Note that the dimensions and voxel sizes of the
    #  ref parameter become the dimensions and voxel sizes for the resulting
    #  images.
    #--in: The input is the slice-timed, motion-corrected, skull-stripped,
    #  thresholded 4D functional file: kmt_$funcFile_masked.
    #--out: The warped 4D functionals file to create: wkmt_$funcFile
    #--premat: An affine (linear) transformation matrix to be applied to
    #  each volume prior to the nonlinear warp. This is important so that
    #  each functional volume is first spatially aligned with the structural
    # scan before being warped.
    #--warp: The warping matrix to be applied. Here, we use the nonlinear
    #  warping matrix from the mprage normalization.
    #--interp: The interpolation method for performing the warp. See -warp_interpolation in help.
    #--mask: Restrict the warp to the mask above used for thresholding low intensity voxels.
    #  Note that this corrects odd behavior with applywarp and sinc interpolation smudging edge voxels extensively.
    #  See here: https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1108&L=FSL&P=R66855&1=FSL&9=A

    #transform threshold / skull strip mask from prior step into template space. Could this be done with one applywarp and a premat?
    rel "flirt -in ${threshMask} -applyxfm -init func_to_mprage.mat -out ${threshMask}_lin -paddingsize 0.0 -interp nearestneighbour -ref $mprageBet"
    rel "applywarp --ref=${templateBrain} --out=w${threshMask} --interp=nn --in=${threshMask}_lin --warp=${warpCoef}"

#This is an example of the one-step version. Quick visual inspection suggestions that the one-step is slightly eroded relative to the linear + nonlinear
#Whether this matters at all is unclear. Still, keep as two steps for now.
# applywarp \
# 	--ref=$HOME/standard/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_3mm.nii  \
# 	--in=kmt_functional_98_2_mask.nii.gz \
# 	--out="testlin_onestep" \
# 	--premat=func_to_mprage.mat \
# 	--warp=../../anatomical/mprage_warpcoef.nii.gz \
# 	--interp=nn

    #warning: sinc interpolation is most precise, but if the mask used below does not precisely match the subject's
    #structural scan (e.g., greater cerebellar coverage for anat relative to functional), then sinc is prone to extending
    #the warp into non-brain space in ways that produce artifact. Spline is the more intelligent default unless you
    #have precisely setup the mask.

    #12Jul2012: constrain_to_template: shrink functional mask for warping to be no bigger than the anatomical mask
    #to ensure that subject mask does not extend beyond anatomical borders, since this could lead to weird stretching etc.
    #The risk may have to do with applywarp doing excessive padding, especially for sinc:
    #https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1108&L=FSL&P=R69770
    #The risk may also a difference in coverage/size between MPRAGE and EPI because warp coefficients are generate for MPRAGE,
    #but applied here to EPI.
    #Also, this step eliminates brain activation that falls outside of the template mask
    #So, in general, this is a good idea, hence default yes.

    if [[ $constrainToTemplate = [Yy] ]]; then

	#Generate template anatomical mask (these are in ~/standard already, but are created by resampling stock brain mask).
	#The template mask created here will tend to be slightly bigger than the warped mask in ~/standard
	#because of small floating point values around T1 template. Still, using the 10th percentile of non-zero voxels
	#as an initial threshold seems to reduce differences to trivial amounts.
	#And eyeballing the mask versus T1, the ~/standard warped mask file may lose some voxels of interest.

	#zero anything below 10th percentile of non-zero voxels, then binarize
	rel "fslmaths ${templateBrain} -thrP 10 -bin templateMask -odt char"

        #subtract template anatomical mask from subject's mask, then threshold at zero
	#(neg values represent areas where anat mask > subj mask, which are not of interest)
	#thus, subject mask may be smaller than template (e.g., low cerebellum coverage), but not bigger.
	rel "fslmaths w${threshMask} -sub templateMask -thr 0 w${threshMask}_outOfAnatBounds -odt char"
	
	#subtract the out of bounds mask from subject mask (trim to match template)
	rel "fslmaths w${threshMask} -sub w${threshMask}_outOfAnatBounds w${threshMask}_templateTrim -odt char"

	subjMask=w${threshMask}_templateTrim
    else
	subjMask=w${threshMask}
    fi

    rel "7. Warping functionals to standard space using coefficients from structural nonlinear warp. Creating functionals with 3mm isotropic voxels" c
    rel "applywarp \
	--ref=$templateBrain \
	--in=\"${prefix}${funcFile}_masked\" \
	--out=\"w${prefix}${funcFile}\" \
	--premat=func_to_mprage.mat \
	--warp=${warpCoef} \
	--interp=${funcWarpInterp} \
	--mask=${subjMask}"

    #add symbolic link of template used to the directory to document which template file was used
    if [[ -f "${templateBrain}.nii" && ! -h ./template_brain.nii ]]; then
	rel "ln -s \"${templateBrain}.nii\" ./template_brain.nii"
    elif [[ -f "${templateBrain}.nii.gz" && ! -h ./template_brain.nii.gz ]]; then
	rel "ln -s \"${templateBrain}.nii.gz\" ./template_brain.nii.gz"
    fi

    rel "touch .warp_complete"
fi

#only add w prefix if warp is part of the pipeline
if [ $no_warp -eq 0 ]; then
    prefix="w${prefix}"
else
    subjMask=${threshMask} #subject mask is just non-warped threshold mask
fi

#Create an extents mask post-warp that ensures that all unsmoothed voxels are sampled at all timepoints. 
#Then apply mask after smoothing to ensure well-behaved voxels (i.e., not smoothing a mixture of zero and non-zero voxels).
rel "fslmaths ${prefix}${funcFile} -Tmin -bin ${prefix}${funcFile}_extents_mask -odt char"

extentsMask=${prefix}${funcFile}_extents_mask

if [ ! -f ".smoothing_complete" ]; then

    rel "8. Smoothing functional data" c

    if [ $smoother = "susan" ]; then
	dimensionality=3 #smooth in two or three dimensions
	susan_thresh=$( echo "scale=5; ($median_intensity - $p_2) * 0.75" | bc )
    
        #recompute mean functional, which is used for susan
	rel "fslmaths \"${prefix}${funcFile}\" -Tmean \"${prefix}mean_func\""
	rel "susan \"${prefix}${funcFile}\" $susan_thresh $sigma $dimensionality 1 1 \"${prefix}mean_func\" $susan_thresh \"s${prefix}${funcFile}_${smoothing_kernel}\""
	
	rel "touch .smoothing_complete"

    elif [ $smoother = "gaussian" ]; then

        #By dumb luck, I stumbled across a paper on correcting edge artifact due to gaussian smoothing:
        #Maisog and Chmielowska (1998). It turns out that Robert's method below implements their recommendations!
        #The procedure is:
        #1) Define a binary mask denoting the voxels to be analyzed (i.e., all brain voxels in, all non-brain out).
        #2) For safety, apply this mask to the 4d file. (Shouldn't have an impact)
        #3) Blur the binary mask using the same Gaussian kernel to be used for smoothing. This results
        #   in a "weighting" volume that has correction factors for voxels toward the edge.
        #   Essentially, any edge voxel will have a correction factor < 1, which represents degree of falloff due to blurring
        #   with non-brain near-zero voxels.
        #4) Apply Gaussian smoothing to the 4d file, dividing the result by the correction volume, thereby correcting for falloff.
	
        #####
        #Create a binary mask, mask_pre.nii.gz, that is zero for all zero voxels and 1 for any non-zero
        #voxel (i.e., in vs. out).
	
        #This is essentially just taking the Tmin of the image.
        #The max 0 says "take the minimum activation or 0, whichever is greater"
        #Would handle a weird circumstance where an activation was < 0.
        #But I just diffed the files with and without -max 0 and they are identical.
	
        #This is then used to build a "weighting" mask that handles edge falloff.
	
	rel "fslmaths \"${prefix}${funcFile}\" -max 0 -Tmin -bin \"${prefix}mask_allbrain\" -odt char"
	
        #####
        #Apply the mask from prior step to the warped functionals.
        #(note that input and output are the same). This seems more like a safety procedure,
        #applying a mask that was generated to be 0 v. non-0 should have no effect.
	
	rel "fslmaths \"${prefix}${funcFile}\" -mas \"${prefix}mask_allbrain\" \"${prefix}${funcFile}\""
        #NOTE THAT I JUST TOOK OUT THE ABOVE STEP DIFFED THE FILES.... NO DIFFERENCE. Superfluous (except I guess with negative values)
	
        #####
        #Blur the in v. out mask using the same sigma for subsequent smoothing.
        #For the vast majority of the brain, the weight will be 1 (because blurring a 1 with many other 1s is 1).
        #But toward the edge, there will be falloff as brain and non-brain voxels are mixed.
        #Thus, at the edges, the weight will drop toward 0.
        #output: mask_weight.nii.gz
	
        #-odt float is important to retain continuous values
	rel "fslmaths \"${prefix}mask_allbrain\" -s $sigma \"${prefix}mask_edgecorrection\" -odt float"
	
        #####
        #Apply gaussian smoothing to the warped 4D functionals file.
        #Not entirely clear on the approach here.
	
        #-s $sigma: apply gaussian smoothing (mean filtering) with the specified sigma
        #-div wkmt_mask_edgecorrection: divides the input image (wkmt_$funcFile) by mask_edgecorrection (i.e., apply edge correction)
        #-mas wkmt_mask_allbrain: mask output image to retain only brain/nonzero voxels.
	
        #note that it's okay for the edge correction mask not to be masked because of the -mas parameter here.
	rel "fslmaths \"${prefix}${funcFile}\" -s ${sigma} -div \"${prefix}mask_edgecorrection\" -mas \"${prefix}mask_allbrain\" \"s${prefix}${funcFile}_${smoothing_kernel}\""
	
	rel "touch .smoothing_complete"
    fi
fi #end check for smoothing_complete

prefix="s${prefix}"

#now apply the extents mask to eliminate excessive blurring due to smooth and only retain voxels fully sampled in unsmoothed image
rel "fslmaths ${prefix}${funcFile}_${smoothing_kernel} -mul ${extentsMask} ${prefix}${funcFile}_${smoothing_kernel} -odt float"

if [ ! -f ".temporal_filtering_complete" ]; then

    #####
    #High-pass filtering for slow-frequency scanner drift
    #-bptf 20 -1: pass any signal faster than 20 TRs, don't low-pass filter (-1)

    rel "9. High-pass filtering functional data" c
    rel "fslmaths \"${prefix}${funcFile}_${smoothing_kernel}\" -bptf $hpFilter -1 \"f${prefix}${funcFile}_${smoothing_kernel}\""

    rel "touch .temporal_filtering_complete"

fi
prefix="f${prefix}"


if [ ! -f ".rescaling_complete" ]; then
    #####
    #Compute a mean functional volume after all of the preprocessing
    #steps are complete. This image has been slice-timed, motion-corrected,
    #skull-stripped, warped to Talairach, smoothed, and high-pass filtered.

    rel "10. Grand mean intensity normalization (rescaling)" c
    
    if [ $rescalingMethod = "10000_globalmedian" ]; then
	rel "Rescaling intensities by a single factor: 10000/globalmedian" c
	rescalingFactor=$( echo "scale=5; 10000/${median_intensity}" | bc )
	rel "fslmaths \"${prefix}${funcFile}_${smoothing_kernel}\" -mul $rescalingFactor \"n${prefix}${funcFile}_${smoothing_kernel}\" -odt float"
    elif [ $rescalingMethod = "100_voxelmean" ]; then
        #####
        #Rescale the 4D functionals file by dividing activations in each
        #volume by the mean_float volume from Step 19 above and multiplying by 100.
        #This is considered "grand mean scaling" (as opposed to global rescaling),
        #which is important for cross-subject/cross-session inferences
        #to be valid (i.e., on a similar scale).

	rel "Rescaling intensities by 100/voxelmean" c

	rel "fslmaths \"${prefix}${funcFile}_${smoothing_kernel}\" -Tmean \"${prefix}mean_float\" -odt float"
	rel "fslmaths \"${prefix}${funcFile}_${smoothing_kernel}\" -mul 100 -div ${prefix}mean_float \"n${prefix}${funcFile}_${smoothing_kernel}\" -odt float"
    fi

    rel "touch .rescaling_complete"
fi

prefix="n${prefix}"

#####
#Ensure that the resulting 4D NIFTI file has the correct TR. (history of FSL stripping this information out)

rel "11. Setting TR in ${prefix}${funcFile}_${smoothing_kernel}.nii.gz to: $tr" c
rel "3drefit -TR $tr \"${prefix}${funcFile}_${smoothing_kernel}.nii.gz\""

#####
#Compute mean functional of final 4d file and mask to be used in GLM
#First mask the final preprocessed file using the warped mask from above.

#probably not totally necessary, but seems like an important last check to ensure that no blurring has occurred.
#extents mask above, in principle, should help with this.
rel "fslmaths \"${prefix}${funcFile}_${smoothing_kernel}\" -mas ${subjMask} \"${prefix}${funcFile}_${smoothing_kernel}\""
rel "fslmaths \"${prefix}${funcFile}_${smoothing_kernel}\" -Tmean \"${prefix}mean_func_${smoothing_kernel}\""

#if mask file exists, and subject_mask.nii is not a file (but could be a symlink), then create subject_mask symlink
if [[ -f "${subjMask}.nii"  && ! -f ./subject_mask.nii ]]; then
    rel "ln -sfn \"${subjMask}.nii\" ./subject_mask.nii"
elif [[ -f "${subjMask}.nii.gz" && ! -f ./subject_mask.nii.gz ]]; then
    rel "ln -sfn \"${subjMask}.nii.gz\" ./subject_mask.nii.gz"
fi

# 9/27/2011: note that with sinc interpolation, there tend to be some small negative values ringing the brain post-smoothing
# with an outer ring of even tinier positive values. When binarizing this, it results in a bizarre mask with an asteroid belt of sorts.
# The sensible solution is to use the mask from the thresholding step, which represents the brain voxels retained after skull stripping and
# intensity thresholding. In the warping step, I use that to mask the functional output. Need to use the same mask again here
# to mask the final file that has been smoothed. Computing a mask after all steps have finished, as I had earlier, makes little sense.
# we don't want smoothing, temporal filtering, or rescaling to influence what constitutes a brain voxel.

#Cleanup files, if requested
if [ $cleanup -eq 1 ]; then

    if [[ ${despike} = [Yy] ]]; then
	dspre="d"
	deleteFile d_${funcNifti}
    else
	dspre=""
    fi

    if [ $no_warp -eq 0 ]; then
	wpre="w"
    else
	wpre=""
    fi

    #interleaved stream
    deleteFile t${dspre}_${funcFile}.nii.gz
    deleteFile mt${dspre}_${funcFile}.nii.gz
    deleteFile mt${dspre}_${funcFile}_mean_reg.nii.gz
    deleteFile kmt${dspre}_${funcFile}.nii.gz
    deleteFile kmt${dspre}_mean_func_mask.nii.gz
    deleteFile ${wpre}kmt${dspre}_${funcFile}.nii.gz
    deleteFile ${wpre}kmt${dspre}_${funcFile}_extents_mask.nii.gz
    deleteFile s${wpre}kmt${dspre}_${funcFile}_${smoothing_kernel}.nii.gz
    deleteFile fs${wpre}kmt${dspre}_${funcFile}_${smoothing_kernel}.nii.gz

    deleteFile kmt${dspre}_${funcFile}_Tmin.nii.gz
    deleteFile kmt${dspre}_${funcFile}_Tmin_10pctThr.nii.gz
    deleteFile mt${dspre}_mean_func.nii.gz
    deleteFile kmt${dspre}_mean_func.nii.gz
    deleteFile ${wpre}kmt${dspre}_mean_func.nii.gz
    deleteFile fs${wpre}kmt${dspre}_mean_float.nii.gz
    deleteFile kmt${dspre}_${funcFile}_98_2_mask.nii.gz
    #deleteFile kmt${dspre}_${funcFile}_mask.nii.gz SO: No longer used
    deleteFile kmt${dspre}_${funcFile}_masked.nii.gz
    deleteFile s${wpre}kmt${dspre}_${funcFile}_${smoothing_kernel}_usan_size.nii.gz

    #sequential stream
    deleteFile m${dspre}_${funcFile}.nii.gz
    deleteFile m${dspre}_${funcFile}_mean_reg.nii.gz
    deleteFile tm${dspre}_${funcFile}.nii.gz
    deleteFile ktm${dspre}_${funcFile}.nii.gz
    deleteFile ktm${dspre}_mean_func_mask.nii.gz
    deleteFile ${wpre}ktm${dspre}_${funcFile}.nii.gz
    deleteFile ${wpre}ktm${dspre}_${funcFile}_extents_mask.nii.gz
    deleteFile s${wpre}ktm${dspre}_${funcFile}_${smoothing_kernel}.nii.gz
    deleteFile fs${wpre}ktm${dspre}_${funcFile}_${smoothing_kernel}.nii.gz

    deleteFile ktm${dspre}_${funcFile}_Tmin.nii.gz
    deleteFile ktm${dspre}_${funcFile}_Tmin_10pctThr.nii.gz
    deleteFile tm${dspre}_mean_func.nii.gz
    deleteFile ktm${dspre}_mean_func.nii.gz
    deleteFile ${wpre}ktm${dspre}_mean_func.nii.gz
    deleteFile fs${wpre}ktm${dspre}_mean_float.nii.gz
    deleteFile ktm${dspre}_${funcFile}_98_2_mask.nii.gz
    deleteFile ktm${dspre}_${funcFile}_mask.nii.gz
    deleteFile ktm${dspre}_${funcFile}_masked.nii.gz
    deleteFile s${wpre}ktm${dspre}_${funcFile}_${smoothing_kernel}_usan_size.nii.gz

    #general files
  
    deleteFile func_to_mprage.mat
    deleteFile func_to_mprage.nii.gz

    deleteFile mask_${funcFile}_Tmin_10pctThr.nii.gz


    deleteFile "${prefix}mean_func_${smoothing_kernel}.nii.gz"
  
    #some more here...
    deleteFile "${threshMask}_lin.nii.gz"
    deleteFile templateMask.nii.gz

    #TODO
    #deleteFile createdByFMUnwarp
fi


if [[ ${deoblique_all} = [Yy] ]]; then
    allNii=$( ls | grep ".*\.nii\.gz" )

    for nii in ${allNii}; do
	mv "${nii}" "toDeoblique_${nii}"
   
        # Run AFNI's deoblique so that it doesn't complain when looking at oblique datasets
        # Default is linear interpolation (blurry), so upgrade to quintic.
        # Note that this step necessarily resamples and interpolates the data.
	3dWarp -deoblique -prefix "${nii}" -quintic "toDeoblique_${nii}"
    
	rm -f  "toDeoblique_${nii}"
    done

fi



#The second round of 10th percentile thresholding has been removed as of 19Jul2010.
#This decision was based on comparison with FEAT's pipeline, discussions
#with Katerina and the group, and comparisons of the results with and without
#this step. The thresholding step above should handle elimination of non-brain voxels (post-BET).
#With real data, this thresholding step was typically masking out edge voxels, which seems to offset
#some of the putative gains made by using the edge correction masking above.
#--------COMMENTED OUT----------
#####
#Step 22: Another round of thresholding. Calculate the 10th percentile of
#non-zero voxels from the mean functional image.

#echo "12. Zeroing any activations < 10th percentile"
#P_10=$( fslstats fswkmt_mean_float -P 10 )

#####
#Step 23: Create a binary mask from the mean functional image that zeroes
#anything below the 10th percentile and sets anything else to 1.
#output: mask.nii.gz

#fslmaths fswkmt_mean_float -thr $P_10 -bin mask -odt char

#####
#Step 24: Apply the mask to the mean_float image.
#output: fswkmt_mean_float_masked.nii.gz

#fslmaths fswkmt_mean_float -mas mask fswkmt_mean_float_masked

#####
#Step 25: Apply the Step 23 mask to the final 4D functionals file (nfswkmt_$funcFile_$smoothing_kernel).

#fslmaths "${prefix}${funcFile}_${smoothing_kernel}" -mas mask "${prefix}${funcFile}_${smoothing_kernel}_wmask"

#Files listed for delete by David in the -startover parameter
#But the naming of these varies depending on the -4d input.
#	deleteFile "func_to_mprage.nii.gz"
#	deleteFile "functional.nii.gz"
#	deleteFile "kmt_functional.nii.gz"
#	deleteFile "kmt_functional_98_2_mask.nii.gz"
#	deleteFile "kmt_functional_masked.nii.gz"
#	deleteFile "kmt_mean_func.nii.gz"
#	deleteFile "kmt_mean_func_mask.nii.gz"
#	deleteFile "mt_functional.nii.gz"
#	deleteFile "mt_functional_mean_reg.nii.gz"
#	deleteFile "mt_mean_func.nii.gz"
#	deleteFile "t_functional.nii.gz"
#	deleteFile "wkmt_functional.nii.gz"
#	deleteFile "wkmt_mean_func.nii.gz"
#	deleteFile "disp.png"
#	deleteFile "rot.png"
#	deleteFile "trans.png"
#	deleteFile "mcplots.par"
#	deleteFile "func_to_mprage.mat"
#	deleteFile "fswkmt_functional_5.nii.gz"
#	deleteFile "fswkmt_mean_float.nii.gz"
#	deleteFile "nfswkmt_functional_5.nii.gz"
#	deleteFile "nfswkmt_functional_mask.nii.gz"
#	deleteFile "nfswkmt_mean_func_5.nii.gz"
#	deleteFile "swkmt_functional_5.nii.gz"
#	deleteFile "swkmt_functional_5_usan_size.nii.gz"
