#!/usr/bin/env bash

# FM = space of fieldmap
# EF = space of example_func
# UD = undistorted (in any space)
# D  = distorted (in any space)


### setup
#rootdir=/Volumes/T800/CogEMOSounds/subjs
#subj=10892
#run=run1
#functional=${rootdir}/$subj/$run/functional.nii.gz
#grefieldmap=${rootdir}/$subj/grefieldmap2/grefieldmap2.nii
#gremagnitude=${rootdir}/$subj/grefieldmap1/magnitude2.nii.gz
###
#epiTE=.002 # [ep2d_bold routine]
#TEdiff should be ms (for fsl_prepare_fieldmap)
#TEdiff=0.00246 #diff in TEs, from scan sheet #difference in phase of two maginutde images # should be ?? 0.000425 
#dweltime=0.000425 # ep2d_bold (echo spacing [Sequence])/(Accel. factor PE [Resolution]) e.g. GogEMO .85ms/2 * 1s/1000ms
#signallossthresh=0.9 # as was observed in log output
#unwarpdir="x-" # "play with this"
#signallossthresh=0.9 # as was observed in log output

    #https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind0712&L=FSL&P=R35595&1=FSL&9=A&I=-3&J=on&d=No+Match%3BMatch%3BMatches&z=4
    #so, from Siemens Trio scanner, GRE fieldmaps are (typically) 0-4096. When converted from DICOM, the NIFTI header has
    #scl_inter=-4096 and scl_slope=2. So add 4096 and divide by 2 to recover original units.
    #As shown in this post, a one-step conversion of the fieldmap to rad/s can be accomplished like so:

    #fslmaths rawfieldmap.nii.gz -mul 3.141593 -div 4096 -div .00246 radpers -odt float

    #or, one could undo the (weird) inter/slope encoding and compute in long-form:
    #fslmaths grefieldmap2.nii.gz -add 4096 -div 2 -sub 2048 -div 2048 -mul 3.14159 -div .00246 twostep

    #in our case, just check the fieldmap header to make sure it's -4096 intercept and 2 slope
    #then proceed with onestep

# save all the nii files?
[ -z "$savetmps" ] && savetmps=no #=yes, save
# take pictures?
[ -z "$pics" ] && pics=no #=yes, take

# regardless make a tmp directory we can remove later
tmpsdir=$(pwd)/unwarptmps
[ -d $tmpsdir ] && rm -r $tmpsdir
mkdir $tmpsdir

imgdir=$(pwd)/img
[ -d $imgdir ] && rm -r $imgdir

globalcount=0
function _picture {
   # only do this if we are told to
   [ "$pics" == "yes" ] || return

   # check we have a save directory
   [ -d $imgdir ] || mkdir $imgdir 

   globalcount=$((( $globalcount+ 1))) #let ..++ can return 0 and break things with set -e 

   name=$(basename $(basename $1 .gz) .nii)
   num=$(printf "%04d" $globalcount)
   imgname=$imgdir/${num}_$name.png
   slicer -u $1 -a $imgname
   convert -scale 200% -fill white -gravity southwest -annotate 0 "$num $name:  $2" $imgname $imgname
}

#rel is shorthand for "run, echo, log"
[ -z "$logFile" ] && logFile=unwarp.log
touch $logFile # get abs path later, make sure it exists now
function rel() {
    #function that runs, echos to terminal, and logs to file an arbitrary command
    cmd="${1}"
    comment=0
    [[ -n "${2}" && ${2} = c ]] && comment=1
    
    #echo to screen
    echo ${cmd}

    #run command   
    [ $comment -eq 0 ] && eval ${cmd}
    
    if [ -n "${logFile}" ]; then
       [ $comment -eq 1 ] && cmd="## ${cmd}"
       echo "${cmd}" >> "${logFile}"
    fi
}


# read inputs
while [ $# -gt 0 ];do
 case $1 in
   -p|--field    ) grefieldmap="$2" ;      shift;; # raw phase fieldmap image (get field distortion)
   -m|--mag      ) gremagnitude="$2" ;     shift;; # magnitude fieldmap image (align field distortion)
   -c|--config   ) configfile="$2";        shift;; # configuration file        (scanner, TEdiff, dwell time)
   -f|--mcFunctional) mcFunctional="$2";   shift;; # motion corrected functional file (file to remove field distortion from)
   #### The rest should be in a config, config overides anything here
   --tediff   ) TEdiff="$2" ;           shift;;
   --scanner  ) scanner="$2" ; shift;;
   --te       ) epiTE="$2" ;            shift;;
   --dwell    ) dweltime="$2" ;         shift;;
   --direction) unwarpdir="$2" ;        shift;;
   --loss     ) signallossthresh="$2" ; shift;;
   (--) shift; break;;
   (-*) echo "$0: error - unrecognized option $1" 1>&2; exit 1;;
   (*) break;;
 esac
 shift
done

# atl way of defining, provide experiment rather than file
case $configfile in
 cogemo|multimodal|wpc5640 ) configfile=$(dirname $0)/MultiModalScan.cfg;;
esac
# source or warn
[ -n "$configfile" -a -r "$configfile" ] && source $configfile || echo "WARNING: readable config file not provided or understood ($configfile)"

# check all inputs exist
for inputName in mcFunctional grefieldmap gremagnitude epiTE dweltime unwarpdir TEdiff signallossthresh scanner; do
 inputVal=${!inputName}
 [ -z "${inputVal}" ] && echo "$inputName cannot be empty" && exit 1
done

# check needed files exist
for fileVar in  grefieldmap gremagnitude logFile; do   # no longer care about functional
 filePath=${!fileVar} # path is the value of the variables we are iterating through
 [ ! -r "${filePath}" -a ! -r "${filePath}.nii"  -a ! -r "${filePath}.nii.gz"  ] && echo "$fileVar ($filePath[.nii[.gz]]) DNE" && exit 1

 # make paths absolute
 cd $(dirname $filePath) 
 filePath=$(pwd)/$(basename $filePath) 

 # place absolute path back into the file variable name
 printf -v $fileVar "$filePath" # eg functional=".../functional.nii.gz"
 # jump back to the directory we were in before setting abs path
 cd - 1>/dev/null
done

# check fieldmap is what we think it is (slope and intercept of a fieldmap)
# preformed by fsl_prepare_fieldmap

# make storage directories
[ -d unwarp ] && rm -r unwarp

set -e


# this takes forever, just use mcFunctional
#rel "fslmaths $functional $mcFunctional -odt float # copy to FSL friendly name"

## motion correct (mat here used as premat in applywarp)
# only doen if we don't have correction from preprocessFunctional passed in
if [ -z "$mcFunctional" ] || [ ! -r "$mcFunctional" -a ! -r "$mcFunctional.nii" -a ! -r "$mcFunctional.nii.gz" ]; then
 echo "could not find motion corrected functional image!"
 exit 1 
 #### Below is no longer executed"
 #rel "WARNING: motion correction to middle volume (need MAT) -- this shouldn't need to be done" c
 #midvol=$(fslhd $mcFunctional|perl -lne 'print  int($1/2) if m/^dim4\s+(\d+)$/') # 91
 #fslroi $mcFunctional example_func $midvol 1
 #mcFunctional="prefiltered_func_data_mcf"
 #mcflirt -in $mcFunctional -out $mcFunctional -mats -plots -refvol $midvol -rmsrel -rmsabs
 #[ -d mc ] && rm -r mc
 #mkdir mc && mv *rms *par *mat/ mc
fi


### Field Warp

## setup
rel "copying to FSL namespace images" c
mkdir unwarp && cd $_ 
fslmaths ../example_func    EF_D_example_func
bet $gremagnitude           FM_UD_fmap_mag
fslmaths FM_UD_fmap_mag     FM_UD_fmap_mag_brain
# use fsl_prepare_fieldmap to create a rad/s ver. of the fieldmap
# scanner and TEdiff should be in the cfg
#Usage: fsl_prepare_fieldmap <scanner> <phase_image> <magnitude_image> <out_image> <deltaTE (in ms)> [--nocheck]"
#eg:    fsl_prepare_fieldmap SIEMENS images_3_gre_field_mapping images_4_gre_field_mapping fmap_rads
fsl_prepare_fieldmap $scanner $grefieldmap FM_UD_fmap_mag FM_UD_fmap $TEdiff ## creates FM_UD_fmap
# if any of these vars are undefined, fsl_prepare_fieldmap will print usage with error exit status
# and set -e of master will grab it and die



globalcount=-1
_picture EF_D_example_func    "Initial"; globalcount=-1
_picture FM_UD_fmap           "Initial"; globalcount=-1 
_picture FM_UD_fmap_mag       "Initial"; globalcount=-1
_picture FM_UD_fmap_mag_brain "Initial (copy of FM mag)"; 


#fslmaths FM_UD_fmap FM_UD_fmapOrigBAK

# as expected when compared to old files
## 3dcalc -a FM_UD_fmap.nii -b ../../grefieldmap2/grefieldmap2_radpers.nii.gz -exp 'a-b' -prefix test.nii.gz -overwrite && fslstats test.nii.gz -R # == 0 0
## 3dcalc -a FM_UD_fmap_mag.nii -b ../../grefieldmap1/magnitude2_bet.nii.gz -exp 'a-b' -prefix test.nii.gz -overwrite && fslstats test.nii.gz -R   # == 0 0

# creates EF_D_example_func.nii  FM_UD_fmap_mag.nii   FM_UD_fmap.nii        

rel "creating masks" c
## Mask

# create a binary mask of the non-zero voxels of the fieldmap magnitude image (which was skull-stripped above)
fslmaths FM_UD_fmap_mag -bin FM_UD_fmap_mag_brain_mask -odt short
#fslmaths FM_UD_fmap_mag_brain_mask FM_UD_fmap_mag_brain_mask_origBAK
# invert and cluster outside to patch holes

# abs the original fieldmap, binarize, then mask based on the 1/0 magnitude image, invert by *-1, + 1, binarize (to be safe)
# the result, FM_UD_fmap_mag_brain_mask_inv is the non-zero voxels of the *fieldmap* (not magnitude) inverted such that
# brain-ish voxels are 0 and non-brain voxels are 1.
# This may lead to a circumstance where there are brain voxels of interest that have value 0 in the fieldmap.
fslmaths FM_UD_fmap -abs -bin -mas FM_UD_fmap_mag_brain_mask -mul -1 -add 1 -bin FM_UD_fmap_mag_brain_mask_inv



_picture FM_UD_fmap_mag_brain_mask "binary mask of skullstriped fmap_mag "
_picture FM_UD_fmap_mag_brain_mask_inv "non brain regions"

# To handle the scenario of 0-valued voxels in fieldmap, use cluster to obtain the largest cluster of non-zero (non-brain) voxels in the above mask
# output is mask image with integer-valued segments for each spatial cluster
cluster -i FM_UD_fmap_mag_brain_mask_inv -t 0.5 --no_table -o FM_UD_fmap_mag_brain_mask_idx

# This will grab the largest spatial cluster (the max of the range, -R), which refers to the biggest non-brain cluster
outsideIdx=$(fslstats FM_UD_fmap_mag_brain_mask_idx -R | awk '{print  $2}')

# overwrite mag_brain_mask
# Now take the clusters image, zero everything below the max (where max contains the biggest non-brain cluster),
# binarize the image, re-invert (*-1 + 1), binarize again, then mask by the skull-stripped magnitude image.
fslmaths FM_UD_fmap_mag_brain_mask_idx -thr $outsideIdx -bin -mul -1 -add 1 -bin -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap_mag_brain_mask


_picture FM_UD_fmap_mag_brain_mask_inv "non brain regions, clustered"
_picture FM_UD_fmap_mag_brain_mask "new brain_mask (inverted biggest nonbrain region masked by old self)"


#fslmaths FM_UD_fmap_mag_brain_mask FM_UD_fmap_mag_brain_mask_afterInvBAK

### Refine Mask

rel "refining masks" c
## demean
# compute median of non-zero voxels in fieldmap, masking by the useful voxels (from mask steps above)
medVal=$(fslstats FM_UD_fmap -k FM_UD_fmap_mag_brain_mask -P 50 | sed 's/ //g') # 112.242508
# overwrite fmap
# subtract off the median from all fieldmap voxels within the relevant mask
fslmaths FM_UD_fmap -sub $medVal  -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap

#fslmaths FM_UD_fmap FM_UD_fmap_afterMaskBAK

## Refine
# From skull-stripped magnitude image, compute 98th pctile of nonzero voxels, divide by 2
almostHalfMax=$(fslstats FM_UD_fmap_mag_brain -P 98 | awk '{print $1/2}') # 563.5

# refine mask (remove edge voxels where signal is poor)
# Zero all non-zero voxels in the skull-stripped magnitude image that fall below half of 98th pctile
# These will typically be near the edge
fslmaths FM_UD_fmap_mag_brain -thr $almostHalfMax -bin FM_UD_fmap_mag_brain_mask50

# Erode once to shave off a layer of all edges
fslmaths FM_UD_fmap_mag_brain_mask -ero FM_UD_fmap_mag_brain_mask_ero
# overwrite FM_UD_fmap_mag_brain_mask

# Take the eroded magnitude mask and add back those voxels (wherever they are) that exceed the half-max (~50th pctile)
# Then threshold those < 1 and binarize to make a magnitude mask.
# In effect, this will bring back edge voxels lost by -ero that are > median (i.e., they have adequate signal and should be retained)
fslmaths FM_UD_fmap_mag_brain_mask_ero -add FM_UD_fmap_mag_brain_mask50 -thr 0.5 -bin FM_UD_fmap_mag_brain_mask

#fslmaths FM_UD_fmap_mag_brain_mask FM_UD_fmap_mag_brain_mask_errBAK

# overwrite FM_UD_fmap
# mask the fieldmap by the magnitude mask above (where the intensities in the magnitude were used to dump poor-quality edge voxels)
fslmaths FM_UD_fmap -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap

# snap shots
_picture FM_UD_fmap                    "overwrite by demedian-ing ( - $medVal, overwrite)"
_picture FM_UD_fmap_mag_brain_mask50   "mag (masked) >$almostHalfMax (all high intensity)"
_picture FM_UD_fmap_mag_brain_mask_ero "mag (masked) eroded"
_picture FM_UD_fmap_mag_brain_mask     "eroded + high intensity (overwrite)"
_picture FM_UD_fmap                    "remove low intenity (mask by brain_mask finally) (overwrite)"

[ -n "$savetmps" ] && fslmaths FM_UD_fmap FM_UD_fmap_preMedianFilter


## Despike just edges
# Erode the magnitude mask created above
fslmaths FM_UD_fmap_mag_brain_mask -ero FM_UD_fmap_mag_brain_mask_ero

#Apply 2D median filtering to fieldmap, apply 2D despiking filter
fugue --loadfmap=FM_UD_fmap --savefmap=FM_UD_fmap_tmp_fmapfilt --mask=FM_UD_fmap_mag_brain_mask --despike --despikethreshold=2.1
# what is going on next? break it down
#fslmaths FM_UD_fmap_tmp_fmapfilt -sub FM_UD_fmap -mas FM_UD_fmap_mag_brain_mask_ero  curious
#_picture curious "sub self from demeaned, apply ero. mask"
#rm curious*

# de(mean&spike)ed - original * erroded brain mask + original
# add what is not within the eroded mask back (not smoothed)
# done by: remove all fmap, zero outside the mask, add back all of the fmap (including what was zeroed by the mask)

####For now, this remains magical.
#The effect is to smooth voxels between the eroded and original magnitude masks, but to leave everything else alone

#This was our guess as to what it was doing, but is wrong (exactly opposite since only the edge is smoothed)
#Take smoothed/despiked fieldmap, which is masked by magnitude,
#1) subtract original fieldmap (which is jaggy/unsmooth) (-sub)
#2) only retain smoothed fieldmap within the eroded magnitude mask (-mas)
#3) add back original jaggy fieldmap -- this does 2 things:
#      - retains smoothed fmap within ero mask
#      - and add original unsmooth fmap outside of ero mask
# OLD original fsl command
#fslmaths FM_UD_fmap_tmp_fmapfilt -sub FM_UD_fmap -mas FM_UD_fmap_mag_brain_mask_ero -add FM_UD_fmap FM_UD_fmap
# new correct command
fslmaths FM_UD_fmap -sub FM_UD_fmap_tmp_fmapfilt -mas FM_UD_fmap_mag_brain_mask_ero -add FM_UD_fmap_tmp_fmapfilt FM_UD_fmap

# snap shots
_picture FM_UD_fmap_mag_brain_mask_ero "erode brain_mask again (regardless of intensity)"
_picture FM_UD_fmap_tmp_fmapfilt       "2D demeaned,despiked FM"
_picture FM_UD_fmap                    "sub self from demeaned, apply ero. mask, add back (overwrite)"

#fslmaths FM_UD_fmap FM_UD_fmap_afterErodeBAK


#clean up
mv  FM_UD_fmap_tmp_fmapfilt* FM_UD_fmap_mag_brain_mask_ero* FM_UD_fmap_mag_brain_mask50* FM_UD_fmap_mag_brain_mask_i* $tmpsdir

##########


rel "sigloss prep" c

## demean field map
medVal=$(fslstats FM_UD_fmap -k FM_UD_fmap_mag_brain_mask -P 50|sed 's/ //g' ) # -0.623573
#overwrite FM_UD_map  with demeaned value
fslmaths FM_UD_fmap -sub $medVal  -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap

_picture FM_UD_fmap "demedian and mask ($medVal, again?, overwrite)"


########## fmap+mag.png 
rel "composing fmap+mag.png" c
# make lowest value 10 - prepair for thumbnail
minVal=$(fslstats FM_UD_fmap -R | awk '{ print  $1}') #  -1383.077148 
fslmaths FM_UD_fmap -sub $minVal -add 10 -mas FM_UD_fmap_mag_brain_mask grot # why subtract/add ?
_picture grot "FM_UD_fmap - $minVal + 10 (prepair for thumbnail)"
# overlay to file "grot" to make images
rangeAboveOne=$(fslstats grot -l 1 -p 0.1 -p 95) # 607.379578 1602.596313
overlay 0 0 FM_UD_fmap_mag -a grot $(echo $rangeAboveOne) grot 
# slice image together
slicer grot -s 3 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png ; 
pngappend sla.png + slb.png + slc.png + sld.png + sle.png + slf.png + slg.png + slh.png + sli.png + slj.png + slk.png + sll.png fmap+mag.png
# cleanup 
rm sl[a-l].png
##########################



### WARP FM to EPI(middle volume) and back
rel "signal loss and initial warp" c
# get a sigloss estimate and make (-s) a siglossed estimate for forward warp
# to be Distorted (ref (after *mag) and refweight in EF_2_FM warp) and warped to epi (sigloss+*png)
sigloss -i FM_UD_fmap --te=$epiTE -m FM_UD_fmap_mag_brain_mask -s FM_UD_fmap_sigloss
# make ref of sigloss by mulitplying by mag for EF2FM
fslmaths FM_UD_fmap_sigloss -mul FM_UD_fmap_mag_brain FM_UD_fmap_mag_brain_siglossed -odt float

_picture FM_UD_fmap_sigloss "FM_UD_fmap masked sigloss (te=$epiTE)"
_picture FM_UD_fmap_mag_brain_siglossed "multiply sigloss by mag brain"

rel "forward warp siglosses fieldmaps (UnDistorted to Distorted) " c

# Distort mag_brain_siglossed and fmap_sigloss by forward warp with FM_UD_warp
# make a warped version of FM_UD_fmap_mag to match with the EPI (for sigloss png)
# -w is forward warp applied to
for file in FM_UD_fmap_mag_brain_siglossed FM_UD_fmap_sigloss; do
  fugue -i  $file \
        --loadfmap=FM_UD_fmap --mask=FM_UD_fmap_mag_brain_mask --dwell=$dweltime \
        -w ${file/_UD_/_D_} --nokspace --unwarpdir=$unwarpdir

   _picture ${file/_UD_/_D_} "undistorted to distored ($unwarpdir), forward warp via FM_UD_fmap"

   # creates FM_D_fmap_mag_brain_siglossed FM_D_fmap_sigloss
done

###################


rel "applying warp (EPI2FM, then FM2EPI) undistorted fieldmaps warped into epi space" c

# threshold by value set in cfg
#The goal of thresholding based on signal loss is to remove EPI voxels where the signal loss
#is greater than 90%, so there is little useful signal there, and what is there may
#be highly distorted, which could detract from coregistration.
fslmaths FM_D_fmap_sigloss -thr $signallossthresh FM_D_fmap_sigloss # .9
_picture FM_D_fmap_sigloss "threshold by $signallossthresh (overwrite)"

# align middle epi (is distored) to mag fieldmap (with distortion applied)
#    overwrite grot (now totally different, will be used for thumbnail again)
# use distored singloss as a reference weight
# Example Functional is distorted and has falloff in high sigloss areas (darkening)
# FM magnitude siglossed has been distorted and darkened similarly to improve coregistration
# In addition, weight the "good" voxels (low sigloss) more in the registration cost function
flirt -in EF_D_example_func -ref FM_D_fmap_mag_brain_siglossed -omat EF_2_FM.mat -o grot -dof 6 -refweight FM_D_fmap_sigloss
_picture grot "align FM (mag,sigloss in) to epi (ref) (make EF2FM.mat, use this image for thumbnail)"

# reverse  EF->FM  to get FM->EF (to put all fieldmap stuff in epi space)
convert_xfm -omat FM_2_EF.mat -inverse EF_2_FM.mat

# warp all the fieldmap images into EPI,  FM_UDs become EF_UDs
for file in "FM_UD_fmap" "FM_UD_fmap_mag_brain" "FM_UD_fmap_mag_brain_mask" "FM_UD_fmap_sigloss"; do
  flirt -in $file  -ref EF_D_example_func -init FM_2_EF.mat -applyxfm -out ${file/FM_/EF_} 
  #creates "EF_UD_fmap" "EF_UD_fmap_mag_brain" "EF_UD_fmap_mag_brain_mask" "EF_UD_fmap_sigloss"
  _picture ${file/FM_/EF_}  "align FM (mag,sigloss in) to epi (ref) (make EF2FM.mat)"
done


## sigloss IMAGE ##################
rel "composing EF_UD_sigloss+mag.png" c
# threshold
# now that we've warped EF_UDs to EF_D_, we can threshold the old stuff for image making
fslmaths EF_UD_fmap_mag_brain_mask -thr 0.5 -bin EF_UD_fmap_mag_brain_mask -odt float
fslmaths EF_UD_fmap_sigloss -thr $signallossthresh EF_UD_fmap_sigloss -odt float
# do the overlay thing
overlay 1 0 EF_UD_fmap_mag_brain -a EF_UD_fmap_sigloss 0 1 grot
# and make the image
slicer grot -s 3 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png 
pngappend sla.png + slb.png + slc.png + sld.png + sle.png + slf.png + slg.png + slh.png + sli.png + slj.png + slk.png + sll.png EF_UD_sigloss+mag.png
# clean up
rm sl[a-l].png
############


rel "warp epi space (undistort, shift)" c
# epi: D -> UD
# shift -> example_func -> applywarp final 4D
# unwarp EF_D_example_func to EF_UD_example_func (for thumbnail, compare to original, and in convertwarp to build applywarp)
# and save unwarp-shiftmap then convert to unwarp-warpfield
# -u is unwarp 
fugue --loadfmap=EF_UD_fmap --dwell=$dweltime --mask=EF_UD_fmap_mag_brain_mask -i EF_D_example_func -u EF_UD_example_func --unwarpdir=$unwarpdir --saveshift=EF_UD_shift
_picture EF_UD_shift "pixelshift ($unwarpdir)  EF_D_example using EF_UD_fmap"

# warp with shift map from above (undistored, shifted epi) and original epi example
# this will be used in the finally apply warp
convertwarp -s EF_UD_shift -o EF_UD_warp -r EF_D_example_func --shiftdir=$unwarpdir
_picture EF_UD_warp "warped ($unwarpdir, shift w/undistored, shifted epi (with orig distored epi as ref)"



################################################

## shift image thumbnail
rel "composing EF_UD_shift+mag.png" c
# hack to to get variables (bash array of results from fslmatsh|awk)
shiftExtrema=( $(fslstats EF_UD_shift -R -P 1 -P 99 | awk '{printf "%.1f %.1f %f %f", $1, $2, $3*-1, $4}'))
#-9.9, 8.0, 3.999190, 4.090690
shiftminR=${shiftExtrema[0]} # not used by image
shiftmaxR=${shiftExtrema[1]} # not used by image
shiftminr=${shiftExtrema[2]}
shiftmaxr=${shiftExtrema[3]}
# save inverse to grot (so image can do something?)
fslmaths EF_UD_shift -mul -1 grot
overlay 1 0 EF_UD_fmap_mag_brain -a EF_UD_shift 0.0001 $shiftmaxr grot 0.0001 $shiftminr grot
slicer grot -s 3 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png
pngappend sla.png + slb.png + slc.png + sld.png + sle.png + slf.png + slg.png + slh.png + sli.png + slj.png + slk.png + sll.png EF_UD_shift+mag.png
# clean up
rm sl[a-l].png


## Skipping EF_D_example_func.gif EF_UD_example_func.gif EF_UD_fmap_mag_brain.gif
## for files in ^; do slicer &&  pngappend; done;  whirlgif

### 4D DATA!!
rel "unwarping all EPI" c
# apply warping and motion correction to example_func and 4D data
# why immv and not fslmaths? I don't know
cd - 1>/dev/null # back to subj data

# copy the example func to a more verbose name (original distorted)
# so we can name the warped version example_func
immv example_func example_func_orig_distorted
# warp using the already warped and undistored epi
applywarp -i example_func_orig_distorted -o example_func -w unwarp/EF_UD_warp -r example_func_orig_distorted --abs --mask=unwarp/EF_UD_fmap_mag_brain_mask

# FSL tcl script ($FSLDIR/tcl/featlib.tcl) would just apply warp to 4d funcdata if mcflirt transforms DNE
# but they do for us, so unwarp on volume at a time
# split the funcdata into junk name grot
[ -d grot ] && rm -r grot
mkdir grot
fslsplit $mcFunctional grot/grot

# get the total number of volumes in the functional
totalVolumes=$(fslhd $mcFunctional|perl -lne 'print $1 if m/^dim4\s+(\d+)$/') # 182
# for each split, apply warp 
# count is 0 based, fslhd output was not, subtract 1 from total
for i in $(seq 0 $((($totalVolumes-1))) ); do
 pad=$(printf "%04d" $i)
 applywarp -i grot/grot$pad -o grot/grot$pad \
           --premat=mc/$mcFunctional.mat/MAT_$pad \
           -w unwarp/EF_UD_warp -r example_func --abs \
           --mask=unwarp/EF_UD_fmap_mag_brain_mask
done
fslmerge -t prefiltered_func_data_unwarp grot/*
_picture  prefiltered_func_data_unwarp "FINAL! "

# clean up
rm -r grot/
mv mc/           $tmpsdir
mv unwarp/*nii*  $tmpsdir
mv unwarp/*mat   $tmpsdir
mv example_func* $tmpsdir #example_func.nii* example_func_orig_distorted.nii*
#keep $mcFunctional.nii* 
[ -d unwarp_thumbnails ] && rm -r unwarp_thumbnails
mv unwarp unwarp_thumbnails

[ "$savetmps" == "yes" ] || rm -r $tmpsdir

## fsl does slice time correction next (line 5194 of featlib.tcl, 581 if log.commented)
