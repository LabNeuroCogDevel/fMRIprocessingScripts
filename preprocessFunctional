#!/bin/bash

function printHelp() {

cat <<EndOfHelp
-----------------------------------
preprocessFunctional is a script to preprocess an fMRI EPI scan.

Three files are required for this preprocessing script:
  1) 4d functionals file (-4d command line parameter). Alternative: -dicom
  2) betted mprage scan (-mprage_bet command line parameter)
  3) mprage-to-standard-space warp coefficients (-warpcoef command line parameter)

This script depends on the following tools:
  1) FSL 5.0 or higher
  2) AFNI (preferably 2012 or later)
  3) imagemagick (for -mc_movie)
  4) ffmpeg (for -mc_movie)
  5) python 2.6 or later (for -4d_slice_motion)
        - nipy development version: https://github.com/nipy/nipy/
        - nibabel
        - scipy
  6) awk
  7) perl

Command line options:
  -4d: The 4d file containing unprocessed functional volumes for a single subject. Required.
  -4d_slice_motion: use 4d simultaneous slice-timing motion correction algorithm (calls sliceMotion4D)
  -bandpass_filter: Apply bandpass filter to fMRI data using 3dBandpass. Specify low and high cutoff frequencies in Hz.
        Example: -bandpass_filter 0.009 .08
  -bet_frac: fractional intensity threshold for skull-stripping mean functional (used in func-to-struc warp). Default 0.3.
  -cleanup: Deletes all files used in preprocessing that are unlikely to be needed for analysis
  -cleanup_only: Delete all intermediate files, but do not run any processing steps.
  -constrain_to_template: Constrain brain voxels to the corresponding standard template (e.g., MNI). y or n. Default: y.
  -custom_slice_times: For use with 4d slice timing + motion correction. 
        A csv file containing the times (in seconds summing to TR) of each slice (bottom to top).
        Example: -custom_slice_times "../SPECCMBSliceTimes.csv"
  -delete_dicom: if converting dicom to nifti, whether delete or archive DICOM files. If not
        passed, user will be prompted for action. Options are:
        -delete_dicom no. (leaves DICOM untouched)
        -delete_dicom yes. (deletes DICOM files)
        -delete_dicom archive. (compresses files into archive file): functional_dicom.tar.gz.
  -deoblique_all: Deoblique all functional datasets (3dWarp -deoblique) after all preprocessing complete.
  -despike: Interpolate intensity spikes using 3dDespike. Occurs after motion correction and slice timing correction.
  -despike_thresh: Cut thresholds for 3dDespike (how much to despike). Default to 2.5 and 4.0.
  -dicom: The file pattern to match all dicom files to be converted to nifti. Must be in quotes.
        Example: -dicom "MR*" (This parameter is an alternative to passing the 4d nifti file using -4d)
  -fm_phase: gre field map phase image
  -fm_magnitude: field map magnitude image (mag2.nii.gz)
  -fm_cfg: configuration file for handling fieldmap (TEs, echo spaceing, etc.)
  -func_struc_dof: The number of degrees of freedom to be used when co-registering the mean subject
        functional (EPI) scan to the subject structural (T1) scan. Defaults to bbr (boundary based registration).
        -func_struc_dof bbr. BBR segments the T1 to create a white matter boundary mask, which is used to help align EPI and T1.
        -func_struc_dof 6.  Rotation x, y, z; Translation x, y, z.
        -func_struc_dof 7.  Rotation x, y, z; Translation x, y, z; Global scaling.
        -func_struc_dof 12. Rotation x, y, z; Translation x, y, z; Scaling x, y, z; Skewing x, y, z.
  -help: Print command help.
  -hp_filter: high-pass filtering frequency (in volumes). Anything faster than this value will be passed. Default is 80.
  -log: Name for log file that documents each command that is run. Default: preprocessFunctional.log
  -mc_first: run motion correction before slice timing correction, regardless of slice acquisition order.
  -mc_movie: create .mpg movies of head movement before and after motion correction (depends on create4DMovie).
  -mc_program: what program to use for motion correction. Options: mcflirt, 3dvolreg. Default: 3dvolreg.
  -motion_censor: A slash-delimited list of motion/intensity metrics for identifying volumes to censor.
        This calls fsl_motion_outliers for each element in the list and generates both spike regressor matrices (.mat)
        and AFNI-style censor 1D files. Available metrics are dvars, fd, fdrms, relrms, refrms, refmse. If an equals sign is included,
        then this is used as the threshold for flagging volumes to exclude. Otherwise,75th pctile + 1.5*IQR is used.
        Example: -motion_censor fd=0.5/refrms (censor FD at 0.5 or greater, and ref RMS at 75th+1.5*IQR)
  -motion_sinc: Complete a 4th stage optimization of motion correction using sinc interpolation (slower but better): y or n. Default y.
  -mprage_bet: The betted structural scan for this participant. Required.
  -no_hp: Do not perform high-pass filtering.
  -no_smooth: Do not perform spatial smoothing.
  -no_st: Do not perform slice timing correction.
  -no_warp: Maintain native space and resolution of input image. Do not warp to a template.
  -nuisance_regression: regress out signals that are not of interest (most relevant to resting-state processing).
        Comma-delimited list (no spaces!) that can include: 6motion, rx, ry, rz, tx, ty, tz, wm (white matter), csf (cerebrospinal fluid), 
        gs (global signal). Derivatives of any of these can be added by using the prefix "d" (e.g., dcsf).
        If bandpass filtering is specified, nuisance regression is done by 3dBandpass (Hallquist et al. 2013, NeuroImage). Otherwise, use 3dDetrend.
        Example: -nuisance_regression 6motion,csf,wm,dcsf,dwm
  -ref_vol: Reference volume to be used in motion correction. Will default to mean volume if not passed.
  -rescaling_method: The method used to normalize voxel intensities. Options are:
        -rescaling_method 10000_globalmedian (FSL's default, rescale the 4d file by a single quantity: 10000/[global median])
        -rescaling_method 100_voxelmean (Rescale each voxel by 100/[voxel 4d mean]. In principle, approximates % change)
  -slice_acquisition: The order in which slices were acquired.
        -slice_acquisition seqasc. Sequential ascending (bottom-up)
        -slice_acquisition seqdesc. Sequential descending (top-down)
        -slice_acquisition interleaved. Interleaved 1,3,5... 2,4,6...
  -smoothing_kernel: The size of gaussian smoothing kernel in mm. Default: 5
  -smoother: The smoothing approach to use. Defaults to "susan" (tries to normalize intensities without
        blurring). Alternative is "gaussian", which is regular smoothing.
  -startover: rather than skipping preprocessing stages that have been
        completed, re-run all processing stages, overwriting any existing files.
  -st_first: run slice timing correction first, regardless of slice acquisition order.
        By default, slice timing is run before motion correction for interleaved sequences, but after
        motion correction for sequential acquisition.
  -template_brain: Which standard template brain to use. Default: MNI_3mm. Must match template from mprage normalization. Options:
        -template_brain MNI_2.3mm (MNI152 brain, 2.3mm isotropic voxels, template from MNI Fonov et al. 2009). For 2.3mm MB sequence.
        -template_brain MNI_3mm (MNI152 brain, 3mm isotropic voxels, template from MNI Fonov et al. 2009)
        -template_brain MNI_FSL_3mm (MNI152 brain, 3mm isotropic voxels, template from FSL standard)
        -template_brain SPM_2mm (MNI brain from spm8 canonical template)
        -template_brain Tal_3mm (Talairach brain, 3mm isotropic voxels. Brain built by resampling MNI template in Tal space)
  -threshold: The method to use for thresholding/masking low intensity voxels. Options are:
        -threshold 98_2 (FSL's default, 2nd %ile + (98th %ile - 2nd %ile)/10
        -threshold 10 (mask any voxels below the 10th percentile)
  -tr: TR duration in seconds.
  -siemens: only relevant for -4d input. If set, slice timing correction will check for interleaved
        order and odd vs. even number of slices. If even, will create and use --ocustom file 2,4,6...1,3,5...
        This is necessary because of different slice acquisition on Siemens for even versus odd total slices.
  -warpcoef: The warp coefficients used to transform the structural scan to standard space. Required.
  -warp_interpolation: The intepolation method used to warp functional data to the mprage and to the standard space (e.g., MNI). Default: spline.
        -warp_interpolation spline. Use cubic spline interpolation to apply warp coefficients. Faster than sinc and slightly more blurry, but more robust to mask. (Default)
        -warp_interpolation sinc. Provides higher quality non-blurry resampling relative to trilinear, but is slower. N.B. Only works well when the subject's
               functional mask is precise and contains only brain voxels. Otherwise, sinc is prone to stretching the warp strangely.
        -warp_interpolation trilinear. Faster method, but somewhat blurry.
  -wavelet_despike: Apply wavelet despiking after motion correction and slice timing correction to remove frequency-dependent nonstationary events in fMRI time series (Patel 2014 NeuroImage).
        Note: This is an alternative to 3dDespike and should generally be preferred because it removes intensity artifacts in frequency space, which is useful
        because head movement often produces artifacts that are spread in time (spin history).
        

The major steps in the processing pipeline are, in order:
  1)   Intensity despiking (optional) - d
  2)   Field map unwarping (optional) - u
  3)   Slice timing correction - t
  4)   Motion correction - m
  5)   Skull stripping - k
  6)   Co-registration and warping to standard space - w
  7)   Smoothing - s
  8)   High-pass filtering - f
  9)   Intensity normalization - n
  10)  Nuisance regression (optional) - r
  11)  Bandpass filtering (optional) - b

Note that if the slice acquisition order is sequential, then the default is to appply motion correction before slice timing correction, whereas for
interleaved acquisition, the default is slice timing first. The order of these steps can be explicitly specified using -st_first, -mc_first, or -no_st.
Altnernatively, consider -4d_slice_motion, which performs both steps at once and is likely more effective than conventional methods.

Characters are prepended as a prefix to the 4d filename, such that the final processed file will have a
prefix such as nfswkmtd, indicating the sequence of processing steps, from right to left.

N.B. For the warping to work properly, you must use preprocessMprage for the mprage scan, which uses the same template set.

Example call:
  preprocessFunctional -4d 10802func.nii.gz -mprage_bet 10802mprage.nii.gz -warpcoef mprage_warpcoef.nii.gz -slice_acquisition seqasc \
      -tr 2 -smoothing_kernel 6 -cleanup

-----------------------------------
EndOfHelp

}

#Written: 5/18/2010
#Last updated: 07/24/2014
#
#Changelog:
#07/24/2014
# - Move -wavelet_despike after motion correction and slice timing correction. We want to retain stationary components of fMRI time series
#   from a voxel that represents the same tissue. Running wavelet despiking before motion correction was sorting the large majority of
#   overt movement into the noise part. Further analyses on a single subject with severe movement demonstrated that although the spike
#   percentage was highly consistent for despike before or after motion, the voxelwise time series were not highly correlated (mean r ~ 0.5).
#   Discussing this with SM, BL, and WF, we agreed that one would like the voxel time series to represent the same tissue over time when running
#   the despike, although it remains somewhat magical how uni-voxel despiking is essentially parsing out motion with no knowledge of other voxels.
#   Likewise, some of these arguments apply to time despiking with 3dDespike (e.g., curve fitting a spike using data from a given chunk of tissue
#   seems like it would give the most meaningful intensities in edited time points).
#07/10/2014
# - Allow preprocessFunctional -startover call, which starts the pipeline again based on cached setttings in .preproc_cmd
#07/01/2014
# - Incorporate nuisance regression and bandpass filtering steps
# - Incorporate wavelet despiking (Patel et al. 2014 NI)
# - Better cleanup of intermediate files using -cleanup_only (looks in .preproc_cmd for settings)
#04/27/2014
# - MAJOR OVERHAUL: worker functions for each processing step abstracted to separate files in preproc_functions/
# - Can resume run by just typing preprocessFunctional at the prompt and answering "y" for resume.
# - Use fieldmap in functional -> structural coregistration when BBR is chosen. (recommended)
# - Refactored fieldmap code to be closer to FSL 5.0 (reduce dependence on FM -> EPI direct coregistration)
# - Generate volumewise motion transformation matrices from 3dvolreg using cat_matvec
# - Provide better detection of NIfTI files created by -dicom conversion so that re-running with -dicom does not fail.
# - Provide new -motion_censor option to automatically create .1D and spike regressor .mat files for high motion/signal change volumes.
# - Number of interpolations is minimized by combining motion correction, fieldmap unwarping, and warping to template whenever possible. (onestep_warp)
# - mc_target is now the standard name of the reference volume used for motion correction and functional -> structural.
# - fieldmap conversion to rad/sec now handled internally (prepare_fieldmap), not in fm_cfg files.
# - fieldmap processing works from original DICOM and can detect separate echos when the magnitude directory contains both images.
# - fieldmap processing detects and corrects if phase and magnitude directories were inadvertently swapped.
# - median and 2nd %ile not recomputed in the case of re-running script (creates files .pct2 and .median_intensity)
# - Rename log file if it already exists so that logs are not overwritten.
#
#03/24/2014
# - remove separate motion plots step. Always compute motion parameters (and plots) based on position of motion correction in pipeline.
# - abstracted motion correction, slice timing, and fieldmap to preproc_functions.
# - added -cleanup_only option to cleanup intermediate files without running any processing steps.
# - switched to fslreorient2std for resampling to RPI/LPI
# - apply reorientation to fieldmap and magnitude images, as needed
# 
#For previous changes, see preproc_functions/changelog

#TODO: 
# - Switch high pass filtering to seconds, not TRs and use bc to calculate #TRs.

#load preprocessing functions
scriptDir=$( dirname "$0" )
source "${scriptDir}/preproc_functions/helper_functions"
source "${scriptDir}/preproc_functions/parse_args"
source "${scriptDir}/preproc_functions/check_requirements"
source "${scriptDir}/preproc_functions/dicom_to_nifti"
source "${scriptDir}/preproc_functions/compute_motion_censor"
source "${scriptDir}/preproc_functions/correct_slice_timing"
source "${scriptDir}/preproc_functions/correct_motion"
source "${scriptDir}/preproc_functions/correct_slice_motion_4d"
source "${scriptDir}/preproc_functions/despike_timeseries"
source "${scriptDir}/preproc_functions/motion_plots"
source "${scriptDir}/preproc_functions/skull_strip_epi"
source "${scriptDir}/preproc_functions/intensity_threshold"
source "${scriptDir}/preproc_functions/register_func2struct"
source "${scriptDir}/preproc_functions/prepare_fieldmap"
source "${scriptDir}/preproc_functions/onestep_warp"
source "${scriptDir}/preproc_functions/warp_to_template"
source "${scriptDir}/preproc_functions/spatial_smooth"
source "${scriptDir}/preproc_functions/highpass_filter"
source "${scriptDir}/preproc_functions/intensity_normalization"
source "${scriptDir}/preproc_functions/nuisance_regression"


set -e #exit if any error occurs (stop processing)

datefmt='+%F+%I:%M'
#grab command, arguments, script version (date), and start time
thiscommandinfo="$0 $@ \n# preprocessFunctional v$(perl -ne 'print $1 if /^#Last updated: (.*)/' $0) \n# Run started $(date $datefmt) "
dotfile=.preprocessfunctional

#setup default values and process all command line inputs
parse_args "$@"

if [ -n "${logFile}" ]; then
    if [ -f "${logFile}" ]; then
	#stat and date are not portable across Linux and BSD...
        [ $( uname ) = Darwin ] && mtime=$( stat -f "%Sm" -t "%Y%m%d_%H%M" "${logFile}" ) || mtime=$( date -r "${logFile}" +%Y%m%d_%H%M )
	mv "${logFile}" "${logFile}_${mtime}"
    fi
    #add absolute path to log file location
    logFile="$(pwd)/$( basename $logFile )" ##TODO: make path handling more robust to non-local directories
    
    echo "#!/bin/bash" > "${logFile}"
    echo "## Log of preprocessFunctional commands" >> "${logFile}"
    echo -e "## Call: $thiscommandinfo" >> "${logFile}"
fi

#handle cleanup only scenario
#TODO: tends to leave behind some mask files since logic for which mask is subject mask is below.
if [ $cleanup_only -eq 1 ]; then
    echo "Cleaning up intermediate files, then exiting."
    cleanup_preprocessFunctional
    exit 0
fi

if [ -f "${dotfile}_complete" ]; then
    echo -e "\n--- preprocessFunctional already complete.\n"
    exit 0
fi

# write to an incomplete file (later to be changed to complete if process finishes)
echo -e "$thiscommandinfo " > ${dotfile}_incomplete

#handle conversion of dicom to nifti
#this step will be skipped when -4d is passed in
dicom_to_nifti # preproc_functions/dicom_to_nifti

#check for required files and settings
check_requirements

#reorient images to match LPI/RPI orientation, which is useful to prevent huge rotations/translations in warp
prefix="_" #tracks file prefix indicating which processing steps have been performed

if [[ ! -f .reorient2std_complete && $( imtest "${prefix}${funcFile}" ) -eq 0 ]]; then
    rel "fslreorient2std ${funcFile} ${prefix}${funcFile}" #add underscore to $funcFile to make it easy later to prepend letters corresponding to each processing step
    #rel "fslmaths ${funcFile} ${prefix}${funcFile}" #alternate to skip this step.
    date > .reorient2std_complete
fi

numVols=$( fslhd ${funcFile} | grep '^dim4' | perl -pe 's/dim4\s+(\d+)/\1/' )
middleVol=$( echo "$numVols/2" | bc )

######
# motion correction
# slice timing correction
# fieldmap unwarping
# registration of functional to structural
#
# These steps can be combined in a number of ways depending on the user specification,
# and the code below determines the order.

# NOTE: Jesper Andersson <jesper@fmrib.ox.ac.uk> (FSL mailing list)
# In short: The correct thing is to do a 4D interpolation, but that is practically cumbersome. 
# When doing them sequentially you start with the one that introduces the biggest variance/error,
# and that is definitely movement.
# My suggestion is 1) Movement+fieldmap 2) Slice timing.

if [[ -z $st_first && -z $mc_first && $sliceMotion4D -eq 0 && $no_st -eq 0 ]]; then
    #no specification of order for slice timing and motion correction
    #Default:
    #  if sequential: 1) motion, 2) slice timing
    #  if interleaved: 1) slice timing, 2) motion
    if [ $sliceAcquisition == interleaved ]; then
	rel "Defaulting to slice timing correction first because of interleaved slice acquistion order." c
	st_first=1
	mc_first=0
    else
	rel "Defaulting to motion correction first because of sequential slice acquistion order." c
	mc_first=1
	st_first=0
    fi
fi

if [ $sliceMotion4D -eq 1 ]; then
    #Option 1: 4-D slice timing + motion correction
    correct_slice_motion_4d
    prepare_fieldmap #prepare fieldmap must always come after motion correction so that mc_target exists (coregistration target)
    register_func2struct
elif [ $no_st -eq 1 ]; then
    #just motion and FM unwarp (skip slice timing)
    correct_motion
    prepare_fieldmap
    register_func2struct
elif [ $st_first -eq 1 ]; then	
    correct_slice_timing
    correct_motion
    prepare_fieldmap
    register_func2struct
elif [ $mc_first -eq 1 ]; then
    correct_motion
    prepare_fieldmap
    register_func2struct
    onestep_warp mc_target #apply MC + FM unwarping before slice timing correction
    correct_slice_timing
fi

#wavelet or time despiking immediately after motion and slice timing correction
despike_timeseries

#make plots (and optional movie) of head motion
motion_plots

#compute motion/intensity outliers to be excluded from analysis
compute_motion_censor

#Skull strip EPI
skull_strip_epi                # preproc_functions/skull_strip_epi

# Threshold low intensity voxels (further refinement of brain mask)
intensity_threshold            # preproc_functions/intensity_threshold

# Warp functional to template
# NOTE: This step is skipped for -no_warp.
# NOTE: When relevant, this step also incorporates motion correction and fieldmap correction.
# These steps are combined so that there is a single interpolation into template space.
warp_to_template               # preproc_functions/warp_to_template

# spatial smoothing
spatial_smooth                 # preproc_functions/spatial_smooth

# high pass filtering
highpass_filter                # preproc_functions/highpass_filter

# normalize intensities (to allow for comparability across subjects)
intensity_normalization

# handle nuisance regression and/or bandpass filtering
nuisance_regression


#####
#Ensure that the resulting 4D NIFTI file has the correct TR. (history of FSL stripping this information out)

tr_hdr=$( fslhd ${prefix}${funcFile}${smoothing_suffix} | grep pixdim4 | perl -pe 's/^.*pixdim4\s+([\d+\.]+).*$/\1/' )

if [ $( echo "${tr_hdr} != $tr" | bc ) -eq 1 ]; then
    rel "Setting TR in ${prefix}${funcFile}${smoothing_suffix}.nii.gz to: $tr" c
    rel "3drefit -TR $tr \"${prefix}${funcFile}${smoothing_suffix}.nii.gz\""
fi

#####
#Compute mean functional of final 4d file and mask to be used in GLM
#First mask the final preprocessed file using the warped mask from above.

#probably not totally necessary, but seems like an important last check to ensure that no blurring has occurred.
#extents mask above, in principle, should help with this.
rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -mas ${subjMask} \"${prefix}${funcFile}${smoothing_suffix}\""
rel "fslmaths \"${prefix}${funcFile}${smoothing_suffix}\" -Tmean \"${prefix}mean_func${smoothing_suffix}\""

#if mask file exists, and subject_mask.nii is not a file (but could be a symlink), then create subject_mask symlink
if [[ -f "${subjMask}.nii"  && ! -f ./subject_mask.nii ]]; then
    rel "ln -sfn \"${subjMask}.nii\" ./subject_mask.nii"
elif [[ -f "${subjMask}.nii.gz" && ! -f ./subject_mask.nii.gz ]]; then
    rel "ln -sfn \"${subjMask}.nii.gz\" ./subject_mask.nii.gz"
fi

# 9/27/2011: note that with sinc interpolation, there tend to be some small negative values ringing the brain post-smoothing
# with an outer ring of even tinier positive values. When binarizing this, it results in a bizarre mask with an asteroid belt of sorts.
# The sensible solution is to use the mask from the thresholding step, which represents the brain voxels retained after skull stripping and
# intensity thresholding. In the warping step, I use that to mask the functional output. Need to use the same mask again here
# to mask the final file that has been smoothed. Computing a mask after all steps have finished, as I had earlier, makes little sense.
# we don't want smoothing, temporal filtering, or rescaling to influence what constitutes a brain voxel.


if [ ${deoblique_all} -eq 1 ]; then
    allNii=$( ls | grep ".*\.nii\.gz" )

    for nii in ${allNii}; do
	mv "${nii}" "toDeoblique_${nii}"

        # Run AFNI's deoblique so that it doesn't complain when looking at oblique datasets
        # Default is linear interpolation (blurry), so upgrade to quintic.
        # Note that this step necessarily resamples and interpolates the data.
	# Thus, in general, I would not recommend it since its main purpose is to quiet AFNI's warning
	3dWarp -deoblique -prefix "${nii}" -quintic "toDeoblique_${nii}"
    
	rm -f  "toDeoblique_${nii}"
    done
fi

#Cleanup files, if requested
if [ $cleanup -eq 1 ]; then
    cleanup_preprocessFunctional
fi

# write finish time, mv incomplete to complete
echo "# finished $(date $datefmt)" >> ${dotfile}_incomplete
mv ${dotfile}_incomplete ${dotfile}_complete
