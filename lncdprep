#!/usr/bin/env bash
set -euo pipefail
#
# BIDS app
#
# generic formula:
# $0 bids_root output [participant] [options]

# 20200608WF - init and POD docs

:<<=cut
=head1 NAME

lncdprep - run preprocess{Mprage,Functional} on a BIDS directory tree

=head1 SYNOPSIS

lncdprep bidsroot outputdir [--participant_label participant1 [participant2 ...]] [options]  -- [preprocessFunctionalOptions]


=head2 Options

=over 4

=item C<--t1> - Folder name within outputdir for preprocessMprage.
default C<MHT1_2mm>.

=item C<--t2> - Folder name within outputdir for preprocessFunctional.

=item C<--onlyt1> - just run preprocessMprage

=item C<--use_ses> - when finding subjects, look for ses- dir. TODO: autodetect

=item C<--njobs> - number of process to fork. default is 1.

=item C<--fm_cfg> - fieldmap configuration file. default to know. if set will look for phase and mag files

=item C<--fm_patt> - pattern to use when choosing fieldmap files (default to *.nii.gz, might want eg. "*run-1*")

=item C<--ppfmri_args|--> append to default settings. will override with specified if redundent

=item C<--ppfmri_newargs> replace all defaults with what is provided aver

=item C<--pattern> - only run on pattern for functional images (default '*.nii.gz')

=item C<--help> - detailed help and examples

=back

Within this dir., there will be subdirectoires for each C<*.nii.gz>.

=head2 preprocessFunctionalOptions

see C<preprocessFunctional -help>

=cut

# where data will be saved
T1DNAME="MHT1_2mm"
T2ROOT="func"
PATT="*.nii.gz"
FMPATT="*.nii.gz"
FMCFG=""
MAXJOBS=1
ONLYT1=0
USE_SES=0 # default to just sub-*/, instead of sub-*/ses-*

usage(){ pod2usage "$0"; exit 1; }

[[ $# -eq 1 && $1 =~ -?-h* ]] && pod2text "$0" && exit 1
[ $# -lt 2 ] && usage
BIDSROOT="$1";
OUTDIR="$2";
shift 2;

## setup dryrun
:<<=cut
=head2 Environmental Variables

C<DRYRUN> - if set, will echo instead of running

=cut
env|grep -q ^DRYRUN=. && DRYRUN=echo || DRYRUN=""
env|grep -q ^DEGUB=. || DEBUG=""
debug() { [ -n "$DEBUG" ] && echo "$@" || :; }


## default globals
:<<=cut
=head1 DESCRIPTION

=head2 Subject list

C<SUBJS> is either provided in as arguments or from traversing the BIDS root at depth 1. matching and removing C<sub->
=cut

SUBJS=""

## default arguements for rest
DEF_ARGS="\
   -wavelet_despike  \
   -wavelet_threshold 10 \
   -siemens -slice_acquisition interleaved \
   -threshold 98_2 \
   -ica_aroma \
   -rescaling_method 10000_globalmedian \
   -template_brain MNI_2mm\
   -func_struc_dof bbr  \
   -warp_interpolation spline  \
   -constrain_to_template y  \
   -smoothing_kernel 4\
   -nuisance_file nuisance_regressors.txt \
   -nuisance_compute 6motion,d6motion,csf,dcsf,wm,dwm"

# rest: stricter motion, bandpass, and regression
REST_ARGS="\
  -motion_censor fd=0.3,dvars=20  \
  -bandpass_filter 0.009 .08 \
  -nuisance_regression 6motion,d6motion,csf,dcsf,wm,dwm"

# task: more permissive motion. high pass filter 111s ~= .009Hz
TASK_ARGS="\
   -motion_censor fd=0.8,dvars=20  \
   -hp_filter 111s"

## parse arguments
ARGS=""
while [ $# -gt 0 ]; do
 case "$1" in
   --task) ARGS="$DEF_ARGS $TASK_ARGS"; shift 1;;
   --rest) ARGS="$DEF_ARGS $REST_ARGS"; shift 1;;
   --participant_label) SUBJS="$SUBJS $2"; shift 2;;
   [^-]*) SUBJS="$SUBJS $1"; shift 1;;
   --t1*) T1DNAME="$2"; shift 2;;
   --onlyt1) ONLYT1=1;shift;;
   --use_ses) USE_SES=1; shift;;
   --t2*) T2ROOT="$2"; shift 2;;
   --njobs) MAXJOBS="$2"; shift 2;;
   --fm_patt) FMPATT="$2"; shift 2;;
   --fm_cfg) FMCFG="$2"; shift 2;;
   --pattern) PATT="$2"; shift 2;;
   # push unknown args onto preprocessFunctional
   --|--ppfmri_args) shift; ARGS="$ARGS $*"; break;;
   *) echo "ERROR: unknown arg '$1'" && usage;;
 esac
 debug "now parsing $*"
done

if [ -z "$ARGS" ] && [ "$ONLYT1" -ne 1 ]; then
   echo "ERROR: specify --task or --rest. Or use your own args like '$0 $* -- ....';" >&2
   echo "ERROR:    see 'preprocessFunctional -help' for options to fill ...." >&2
   exit 1
fi

:<<=cut
=head2 preprocessMprage

We copy the sole T1w nifti to this subjects directory (C</output/t1prefix/>)
and run preprocessMprage with the default settings
=cut
mprage() {
 local t1out="$1"; shift
 local t1s="$1"
 [ ! -d $t1out ] && mkdir -p $t1out
 cd $t1out
 3dcopy $t1s mprage.nii.gz -overwrite
 preprocessMprage -n mprage.nii.gz
}


:<<=cut
=head2 preprocessDistortion

=cut
fieldmap(){
   local fmdir="$1"; shift
   local mag="$1"; shift
   local phase="$1"; shift
   [ ! -d "$fmdir" ] && mkdir -p "$fmdir"
   cd $fmdir
   preprocessDistortion -phase "$phase" -mag "$mag" -fm_cfg "$FMCFG" -method "gre.nii.gz"
}

# needs ARGS defined
:<<=cut
=head2 preprocessFunctional

We copy the each nifti to this subjects directory (C</output/t2prefix/nifti_name/>)
and run preprocessFunctional with the a mix of settings not necissaily the default for the sole command.

N.B. repeated command overwrite the previous setting. 
e.g. C<-smoothing_kernel 4 -smoothing_kernel 5> runs at 5mm
=cut
func() {
 local t1out="$1"; shift
 local thisout="$1"; shift
 local func="$1"; shift
 local args="$ARGS";

 [ ! -d "$thisout" ] && mkdir -p "$thisout"
 cd $thisout


 # in BIDS sbref should be named nearly the same as func if it exists
 sbref=${func/_bold.nii.gz/_sbref.nii.gz}
 if [ -r "$sbref" ]; then
    ! test -r ref.nii.gz && 3dcopy $sbref $_
    ! test -r ref.json  && cp ${sbref/.nii.gz/.json} $_
    debug "using $sbref reference!"
    args="-func_refimg ref.nii.gz $args"
 else
    debug "no sbref for like '$sbref'"
 fi

 echo "final args: $args" #todo rmme

 [ ! -r func.nii.gz ] && 3dcopy $func func.nii.gz
 [ ! -r func.json ] && cp ${func/.nii.gz/.json} func.json
 preprocessFunctional -4d func.nii.gz \
   -mprage_bet $t1out/mprage_bet.nii.gz -warpcoef $t1out/mprage_warpcoef.nii.gz \
   $args
}

if [ -z "$SUBJS" ]; then
   debug "finding subjects"
   [ $USE_SES -eq 0 ] &&
     SUBJS=$(find -L $BIDSROOT -maxdepth 3 -type d -name func | perl -lne 'print $1 if m:sub-([^/]*):') ||
     SUBJS=$(find -L $BIDSROOT -maxdepth 4 -type d -name func | perl -lne 'print $1 if m:sub-([^/]*/ses-[^/]*):')
   debug "have $SUBJS"
fi

for id in $SUBJS; do
  debug $id

  if [ -n "$FMCFG" ]; then
     distortion_dir=$OUTDIR/FM/$id
     fieldmap $distortion_dir \
        $(find -L $BIDSROOT/sub-$id/fmap/ -name "$FMPATT" -name "*magnitude1.nii.gz"| sed -n '$p') \
        $(find -L $BIDSROOT/sub-$id/fmap/ -name "$FMPATT" -name "*phase.nii.gz"| sed -n '$p')
     ARGS="$ARGS -distortion_dir $distortion_dir/unwarp"
  fi

  t1out="$OUTDIR/$T1DNAME/$id"
  if [ ! -r $t1out/mprage_warpcoef.nii.gz ]; then
     t1s=($(find -L $BIDSROOT/sub-$id -name '*T1w*.nii.gz' -path '*/anat/*'))
     [ ${#t1s[@]} -eq 0 ] && echo "ERROR: $id: no T1 in $BIDSROOT/sub-$id!?" && continue
     [ ${#t1s[@]} -gt 1 ] && echo "ERROR: $id: more than one T1 ${t1s[*]}" && continue
     $DRYRUN mprage $t1out ${t1s[0]}
  fi

  [ $ONLYT1 -ne 0 ] && continue


  find -L $BIDSROOT/sub-$id \
     -path '*/func/*'  \
     -iname "$PATT" \
     -name "*nii.gz" \
     -not -iname '*_sbref.nii.gz' |
   while read func; do

     test 1 -ge $(AFNI_NIFTI_TYPE_WARN=NO 3dinfo -nt "$func") &&
        echo "# skipping '$func', too few volumes ($_)" && continue

     thisout=$(perl -pe "
       s:/func/sub-:/sub-:g;
       s/:/_/g;s:^$BIDSROOT:$OUTDIR/$T2ROOT:;
       s/sub-//;s/.nii(.gz)?$//;" <<< $func)
     # $BIDSROOT/sub-11757/func/sub-11757_task-SOA_bold.nii.gz
     #  becomes
     # $OUTPUTDIR/$T2ROOT/11757/sub-11757_task-SOA_bold 

     $DRYRUN func "$t1out" "$thisout" "$func" &

     if [ $MAXJOBS -eq 1 -o -n "$DRYRUN" ]; then
        sleep .1
     else
        i=1
        while [ $(jobs -p|wc -l) -gt $MAXJOBS ]; do
           echo "[$i@$(date +%FT%H:%m)] $id $func; $MAXJOBS jobs. waiting";
           let ++i
           sleep 30
        done
     fi
  done
done

wait

:<<=cut

=head1 EXAMPLE

lncdprep BIDS/ preproc/ 233/ses-1 --t2dir aus --pattern "*AUS_run*nii.gz" --task -- -smoothing_kernel 6


=over 4

=item look in BIDS for input niftis

=item output to preproc/ directory root

=item run only for sub C<233/ses-1>

=item save to C<aus> directory (i.e. preproc/aus)

=item only run on nifti matching glob "*AUS_run*nii.gz" (i.e. BIDS/sub-233/ses-1/func/*AUS_run*nii.gz; BIDS/**/func/*AUS_run*nii.gz if no sub/ses provided)

=item use task settings

=item but change smoothing_krenl to 6 (default is 4)

=back


=cut
