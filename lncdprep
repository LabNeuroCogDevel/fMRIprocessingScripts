#!/usr/bin/env bash
set -euo pipefail
trap 'e=$?; [ $e -ne 0 ] && echo "$0 exited in error; wait for cleanup"; wait' EXIT

#
# BIDS app
#
# generic formula:
# $0 bids_root output [participant] [options]

# 20200608WF - init and POD docs

:<<=cut
=head1 NAME

lncdprep - run preprocess{Mprage,Functional} on a BIDS directory tree

=head1 SYNOPSIS

lncdprep bidsroot outputdir [--participant_label participant1 [participant2 ...]] [options]  -- [preprocessFunctionalOptions]


=head2 Options

=over 4

=item C<--t1> - Folder name within outputdir for preprocessMprage.
default C<MHT1_2mm>.

=item C<--t2> - Folder name within outputdir for preprocessFunctional.

=item C<--onlyt1> - just run preprocessMprage

=item C<--use_ses> - when finding subjects, look for ses- dir. TODO: autodetect

=item C<--njobs> - number of process to fork. default is 1.

=item C<--fm_cfg> - fieldmap configuration file. default to know. if set will look for phase and mag files

=item C<--fm_patt> - pattern to use when choosing fieldmap files (default to *.nii.gz, might want eg. "*run-1*")

=item C<--ppfmri_args|--> append to default settings. will override with specified if redundent

=item C<--ppfmri_newargs> replace all defaults with what is provided aver

=item C<--pattern> - only run on pattern for functional images (default '*.nii.gz')

=item C<--help> - detailed help and examples

=item C<--tac> - like tac is to cat, reverse order of inputs

=item C<--no_partial> - skip if we have any thing in the directory we would run in

=back

Within this dir., there will be subdirectoires for each C<*.nii.gz>.

=head2 preprocessFunctionalOptions

see C<preprocessFunctional -help>

=cut

# where data will be saved
T1DNAME="MHT1_2mm"
T2ROOT="func"
PATT="*.nii.gz"
FMPATT="*.nii.gz"
FMCFG=""
MAXJOBS=1
ONLYT1=0
USE_SES=0 # default to just sub-*/, instead of sub-*/ses-*
PARTIAL=1 # okay to rerun if something is already in the directory

usage(){ pod2usage "$0"; exit 1; }


## setup dryrun
:<<=cut
=head2 Environmental Variables

C<DRYRUN> - if set, will echo instead of running

=cut
env|grep -q ^DRYRUN=. && DRYRUN=echo || DRYRUN=""
env|grep -q ^DEGUB=. || DEBUG=""
debug() { [ -n "$DEBUG" ] && echo "$@" || :; }


## default globals
:<<=cut
=head1 DESCRIPTION

=head2 Subject list

C<SUBJS> is either provided in as arguments or from traversing the BIDS root at depth 1. matching and removing C<sub->
=cut

SUBJS=""

## default arguements for rest
DEF_ARGS="\
   -wavelet_despike  \
   -wavelet_threshold 10 \
   -siemens -slice_acquisition interleaved \
   -threshold 98_2 \
   -ica_aroma \
   -rescaling_method 10000_globalmedian \
   -template_brain MNI_2mm\
   -func_struc_dof bbr  \
   -warp_interpolation spline  \
   -constrain_to_template y  \
   -smoothing_kernel 4\
   -nuisance_file nuisance_regressors.txt \
   -nuisance_compute 6motion,d6motion,csf,dcsf,wm,dwm"

# rest: stricter motion, bandpass, and regression
REST_ARGS="\
  -motion_censor fd=0.3 \
  -bandpass_filter 0.009 .08 \
  -nuisance_regression 6motion,d6motion,csf,dcsf,wm,dwm"

# task: more permissive motion. high pass filter 111s ~= .009Hz
TASK_ARGS="\
   -motion_censor fd=0.8 \
   -hp_filter 111s"

## parse arguments
ARGS=""
CAT="cat" # default to subjects in order, tac reverses

parse_args() {
   [[ $# -eq 1 && $1 =~ -?-h* ]] && pod2text "$0" && exit 1
   [ $# -lt 2 ] && usage
   BIDSROOT="$1";
   OUTDIR="$2";
   shift 2;
   while [ $# -gt 0 ]; do
    case "$1" in
      --task) ARGS="$DEF_ARGS $TASK_ARGS"; shift 1;;
      --rest) ARGS="$DEF_ARGS $REST_ARGS"; shift 1;;
      --participant_label) SUBJS="$SUBJS $2"; shift 2;;
      [^-]*) SUBJS="$SUBJS $1"; shift 1;;
      --t1*) T1DNAME="$2"; shift 2;;
      --onlyt1) ONLYT1=1;shift;;
      --use_ses) USE_SES=1; shift;;
      --t2*) T2ROOT="$2"; shift 2;;
      --njobs) MAXJOBS="$2"; shift 2;;
      --fm_patt) FMPATT="$2"; shift 2;;
      --fm_cfg) FMCFG="$2"; shift 2;;
      --pattern) PATT="$2"; shift 2;;
      --tac) CAT=tac; shift;;
      --no_partial) PARTIAL=0; shift;;
      # push unknown args onto preprocessFunctional
      --|--ppfmri_args) shift; ARGS="$ARGS $*"; break;;
      *) echo "ERROR: unknown arg '$1'" && usage;;
    esac
    debug "now parsing $*"
   done

   if [ -z "$ARGS" ] && [ "$ONLYT1" -ne 1 ]; then
      echo "ERROR: specify --task or --rest. Or use your own args like '$0 $* -- ....';" >&2
      echo "ERROR:    see 'preprocessFunctional -help' for options to fill ...." >&2
      exit 1
   fi
}

:<<=cut
=head2 preprocessMprage

We copy the sole T1w nifti to this subjects directory (C</output/t1prefix/>)
and run preprocessMprage with the default settings
=cut
mprage() {
 local t1out="$1"; shift
 local t1s="$1"
 [ ! -d $t1out ] && mkdir -p $t1out
 cd $t1out
 3dcopy $t1s mprage.nii.gz -overwrite
 preprocessMprage -n mprage.nii.gz
}


:<<=cut
=head2 preprocessDistortion

=cut
fieldmap(){
   [ $# -ne 3 ] && echo "$FUNCNAME: want fmdir, mag, phase. given '$@'." && return 1
   local fmdir="$1"; shift
   local mag="$1"; shift
   local phase="$1"; shift
   [ ! -d "$fmdir" ] && mkdir -p "$fmdir"
   cd $fmdir
   preprocessDistortion -phase "$phase" -mag "$mag" -fm_cfg "$FMCFG" -method "gre.nii.gz"
}

# needs ARGS defined
:<<=cut
=head2 preprocessFunctional

We copy the each nifti to this subjects directory (C</output/t2prefix/nifti_name/>)
and run preprocessFunctional with the a mix of settings not necissaily the default for the sole command.

N.B. repeated command overwrite the previous setting. 
e.g. C<-smoothing_kernel 4 -smoothing_kernel 5> runs at 5mm
=cut
func() {
 local t1out="$1"; shift
 local thisout="$1"; shift
 local func="$1"; shift
 local args="$ARGS";

 [ ! -d "$thisout" ] && mkdir -p "$thisout"
 cd $thisout


 # in BIDS sbref should be named nearly the same as func if it exists
 sbref=${func/_bold.nii.gz/_sbref.nii.gz}
 if [ -r "$sbref" ]; then
    ! test -r ref.nii.gz && 3dcopy $sbref $_
    ! test -r ref.json  && cp ${sbref/.nii.gz/.json} $_
    debug "using $sbref reference!"
    args="-func_refimg ref.nii.gz $args"
 else
    debug "no sbref for like '$sbref'"
 fi

 echo "final args: $args" #todo rmme

 [ ! -r func.nii.gz ] && 3dcopy $func func.nii.gz
 [ ! -r func.json ] && cp ${func/.nii.gz/.json} func.json
 preprocessFunctional -4d func.nii.gz \
   -mprage_bet $t1out/mprage_bet.nii.gz -warpcoef $t1out/mprage_warpcoef.nii.gz \
   $args

 wait
}

find_func(){
   find -L $BIDSROOT -maxdepth "$1" -type d -name func |
      perl -lne 'print $1 if m:sub-([^/]*(/ses-[^/]*)):' |
      $CAT
}

wait_for_jobs() {
  i=1
  while [ $(jobs -p|wc -l) -gt $MAXJOBS ]; do
     echo "[$i@$(date +%FT%H:%m)] $*; $MAXJOBS jobs. waiting";
     let ++i
     sleep 30
  done
}

# return false if this is partially completed and we care about that
partial_ok(){
   local thisout="$1"
     [ "$PARTIAL" -eq 0 ] && [ -e "$thisout" ] &&
        [ $(find -L "$thisout" -maxdepth 1 | wc -l) -gt 1 ] &&
        echo "# skipping '$thisout'. not empty. remove --no_partial to continue" &&
        return 1
     return 0
}

_lncdprep(){
  local id="$1"; shift
  if [ -n "$FMCFG" ]; then
     distortion_dir=$OUTDIR/FM/$id
     fieldmap $distortion_dir \
        $(find -L $BIDSROOT/sub-$id/fmap/ -name "$FMPATT" -name "*magnitude1.nii.gz"| sed -n '$p') \
        $(find -L $BIDSROOT/sub-$id/fmap/ -name "$FMPATT" -name "*phase.nii.gz"| sed -n '$p')
     ARGS="$ARGS -distortion_dir $distortion_dir/unwarp"
  fi

  t1out="$OUTDIR/$T1DNAME/$id"
  if [ ! -r $t1out/mprage_warpcoef.nii.gz ]; then
     t1s=($(find -L $BIDSROOT/sub-$id -name '*T1w*.nii.gz' -path '*/anat/*'))
     [ ${#t1s[@]} -eq 0 ] && echo "ERROR: $id: no T1 in $BIDSROOT/sub-$id!?" && return
     [ ${#t1s[@]} -gt 1 ] && echo "ERROR: $id: more than one T1 ${t1s[*]}" && return
     $DRYRUN mprage $t1out ${t1s[0]}
  fi

  [ $ONLYT1 -ne 0 ] && return

  find -L "$BIDSROOT/sub-$id" \
     -path '*/func/*'  \
     -iname "$PATT" \
     -name "*nii.gz" \
     -not -iname '*_sbref.nii.gz' |
   while read func; do

     test 1 -ge $(AFNI_NIFTI_TYPE_WARN=NO 3dinfo -nt "$func") &&
        echo "# skipping '$func', too few volumes ($_)" && continue

     thisout=$(perl -pe "
       s:/func/sub-:/sub-:g;
       s/:/_/g;s:^$BIDSROOT:$OUTDIR/$T2ROOT:;
       s/sub-//;s/.nii(.gz)?$//;" <<< $func)
     # $BIDSROOT/sub-11757/func/sub-11757_task-SOA_bold.nii.gz
     #  becomes
     # $OUTPUTDIR/$T2ROOT/11757/sub-11757_task-SOA_bold 

     partial_ok "$thisout" || continue

     if [ $MAXJOBS -eq 1 -o -n "$DRYRUN" ]; then
        $DRYRUN func "$t1out" "$thisout" "$func"
     else
        func "$t1out" "$thisout" "$func" &
        sleep .1
        wait_for_jobs $id $func
     fi
  done
}

prep_all_subjs() {
   if [ -z "$SUBJS" ]; then
      debug "finding subjects"
      [ $USE_SES -eq 0 ] &&
        SUBJS=$(find_func 3) ||
        SUBJS=$(find_func 4)
      debug "have $SUBJS"
   fi

   for id in $SUBJS; do
     debug $id
     _lncdprep "$id"
   done
   wait
}

if [[ $0 =~ lncdprep$ ]]; then
   parse_args "$@"
   prep_all_subjs
fi

:<<=cut

=head1 EXAMPLE

lncdprep BIDS/ preproc/ 233/ses-1 --t2dir aus --pattern "*AUS_run*nii.gz" --task -- -smoothing_kernel 6


=over 4

=item look in BIDS for input niftis

=item output to preproc/ directory root

=item run only for sub C<233/ses-1>

=item save to C<aus> directory (i.e. preproc/aus)

=item only run on nifti matching glob "*AUS_run*nii.gz" (i.e. BIDS/sub-233/ses-1/func/*AUS_run*nii.gz; BIDS/**/func/*AUS_run*nii.gz if no sub/ses provided)

=item use task settings

=item but change smoothing_krenl to 6 (default is 4)

=back


=cut
