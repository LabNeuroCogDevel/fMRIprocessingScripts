#!/bin/bash
function printHelp() {

set -e #stop script on error

cat <<EndOfHelp
----------------------------------------------
preprocessMprage is a shell script that computes the nonlinear warp of a
  participant's structural scan to a standard stereotaxic template (e.g., MNI).

It is intended to be run within an mprage directory containing raw data (or a
  nifti of the raw data if you use the -n option).

The basic pipeline is:
  1) Convert dicom files to NIFTI
  2) Optional bias field correction to reduce spatial variation in intensity
       due to coil sensitivity. Particularly important for 32-channel T1 images.
  3) Brain extract the structural image
  4) Warp structural to standard stereotactic space using affine (linear)
      transformation: flirt. (Used only for warp coefficients)
  5) Warp structural image to stereotactic space using nonlinear transformation
       with fnirt. Affine coefficients from the linear warping are used as
       starting values (helps optimization). In the case of MNI, uses FSL's
       config file with optimal parameters for fnirt. In the case of Talairach,
       use a custom settings file adapted from FSL's MNI configuration.

Command line options:
  -b -bet_opts: bet options. Passes value to fsl bet (brain extraction).
        Must be quoted (e.g., -b "-f 0.7"). Defaults to "-R -f 0.5 -v"
  -cleanup: cleanup intermediate files not needed for further processing.
  -cleanup_only: run cleanup of intermediate files, then exit. (after checking files)
  -custom_brainmask: a NIfTI image containing a custom brain mask to be used instead of running a skull strip internally.
        Must be the same dimensions as the structural scan. Technically, this can even be a skull-stripped volume such that
        non-zero values are used to mask the structural image.
  -d -delete_dicom: delete or archive DICOM files. Options are -d n ("no": leaves DICOM
        untouched), -d y ("yes": deletes DICOM files), -d a ("archive":
        compresses files into archive file: mprage_dicom.tar.gz. If not
        passed, user will be prompted for action. Can also use "yes", "no", and "archive."
  -grad_unwarp: a file containing gradient nonlineatiy coefficients for a SIEMENS scanner (e.g., trio.coeff.grad).
        Structural image will be corrected for gradient distortion prior to transformation to template.
  -h -help: print command help
  -log: Name for log file that documents each command that is run. Default: preprocessMprage.log
  -n -nifti: skip DICOM conversion and start with specified NIFTI file. 
        Example: -n mprage.nii.gz (will complete bet, flirt, and
        fnirt, but skip DICOM -> NIFTI conversion).
  -no_bias: skip bias field correction.
  -o -output: output file name. The filename for the final warped mprage image.
        Defaults to mprage_nonlinear_warp_<referenceName>.nii.gz
  -p -dicom: file pattern for dicom MR files. Defaults to "MR*". Please enclose the pattern in quotes or it may not function properly
  -r -template_brain: reference brain. Currently supports "MNI_2mm", "MNI_FSL_2mm", "SPM_2mm", and "Tal_2mm". Default is "MNI_2mm".
  -ss_method: skull-stripping method used to create final brain-extracted data. Default is fnirt-inv. Options:
        fnirt-inv: uses the template brain mask warped onto the subject's brain to define brain mask
	bet: uses the bet program (FSL) to skull strip (also respects -bet_opts).
	3dSkullStrip: uses the 3dSkullStrip program (can pass additional parameters using -bet_opts).
  -w -warpres: resolution of warp basis (nonlinear neighborhood size) in mm. Default is 8 mm.
  -weakbias: used for images with little and/or smooth bias fields (cf. fsl_anat).

Example call: preprocessMprage -r MNI_2mm -b "-R -f 0.5 -g 0.2" -d a -o mprage_final.nii.gz -w 6
----------------------------------------------
EndOfHelp

} #end of printHelp

#Author: Michael Hallquist
#Written: 5/2/2010
#Last updated: 11/14/2016
#
#Changelog:
#11/14/2016
# - Added robustfov into pipeline to help with neck cleanup on larger structural scans
# - Allow bet or 3dSkullStrip to carry forward as brain-extracted image for subsequent processing (-ss_method)
# - Allow for a custom brain mask to be used to help with manual tweaks of skull strip (-custom_brainmask)
# - Allow for a .preproc_override file to supplant parameters passed on the command line. Useful for 
#     manual custom processing to still be picked up by preprocessMprage being run in large batch (autopreproc).
# - Implement .preprocessmprage_incomplete, consistent with preprocessFunctional approach
# - Archive preprocessMprage.log on re-run, rather than deleting it (consistent with preprocessFunctional)
# - Support gradient nonlinearity distortion correction: -grad_unwarp
#10/30/2014
# - added check for initial file extension for NIfTI to make sure that it matches FSLOUTPUTYPE. Otherwise, pipeline may fail to use reoriented file.
#4/5/2014
# - added -log parameter to keep a log of processing steps.
# - generate brain mask from inverse MNI warp to reduce sensitivity to BET (follows fsl_anat)
# - generate struct_to_template.png image to display quality of struct -> template warp.
# - provide option for bias field correction (to reduce spatial variability in intensity due to coil sensitivity).
#     Bias field is also incorporated into fnirt to improve warp to template. (adapted from fsl_anat).
# - use fslreorient2std to ensure that mprage matches template (MNI) orientation (LPI/RPI)
# - provide -w option for setting warp resolution. Default to 8mm.
# - align related arguments between preprocessMprage and preprocessFunctional (e.g., -dicom).
# - switch to remove_ext for T1
# - switch to more general arg parsing to allow for longer names
#6/4/2012
# - provide option to use SPM8 canonical MNI template
#10/27/2011
# - put back in 3dresample to orient to LPI. With some of Kirsten's data, warp was failing due to some orientation problem.
#10/18/2011
# - removed 3dresample command to orient original functional to LPI. Bug in AFNI that was flipping storage but not header.
# - Added -f to gzip to overwrite old file.
#08/31/2011
# - Changed default MNI template to new nonlinear template from Vladimir Fonov
#07/28/2011
# - Cleaned up DICOM to NIFTI conversion sections to adopt Dimon
# - Removed sleep commands (just used for monitoring output)
#06/28/2011:
# - Changed Dimon parameters used for DICOM > NIFTI conversion
#   it was failing on a couple datasets
#5/4/2011:
# - Switched from using the oriented output file from dcm2nii;
#   its usage is counterindicated (had fucked up qform/sform values)
# - Changed the code that determines which nii.gz file to use as anatomical.
#   now uses regex to determine correct file 
#3/10/2011:
# - Switched default template brain to MNI.
# - Exit script on unrecognized template brain parameter.

set -e #exit if any error occurs (stop processing)

scriptDir=$( dirname "$0" )

source "${scriptDir}/preproc_functions/helper_functions" #contains rel for running/logging; also sets up stddir env variable
source "${scriptDir}/preproc_functions/parse_args" #contains function for parsing command line args

##load necessary modules if running on cluster (specific to ACI at the moment)
if command -v module >/dev/null; then
    module load fsl/5.0.8 >/dev/null 2>&1
    module load afni/16.0.00 >/dev/null 2>&1
    module load R/3.2.0 >/dev/null 2>&1
    module load matlab/R2014b >/dev/null 2>&1
    module load python/2.7.5 >/dev/null 2>&1
fi

#set defaults for dicomPattern, reference, betOpts, and outputFile
cleanup=0
cleanup_only=0
biasCorrect=1
strongBias=1 #0 for minimal bias correction, 1 for strong bias
dicomPattern="MR*"
logFile="preprocessMprage.log"
reference="MNI_2mm"
wr=8 #warp resolution in mm
robustfov=1
ssmethod=fnirt-inv
gcoeffs= #no gradient nonlinearity correction by default

dotfile=.preprocessmprage

#exit script if processing complete
if [[ -f "${dotfile}_complete" && "$@" != *-startover* && "$@" != *-cleanup_only* && "$@" != *-help* ]]; then
    echo -e "\n--- preprocessMprage already complete.\n"
    exit 0
fi

#if no parameters are passed in, then print help and exit.
if [ $# -eq 0 ]; then
    printHelp
    exit 0
fi

datefmt='+%F+%I:%M'
#grab command, arguments, script version (date), and start time.
#needs to come before while loop because the positional parameters get popped off.
thiscommandinfo="$0 $@ \n# preprocessMprage v$(perl -ne 'print $1 if /^#Last updated: (.*)/' $0) \n# Run started $(date $datefmt) "

# write to an incomplete file (later to be changed to complete if process finishes)
echo -e "$thiscommandinfo " > ${dotfile}_incomplete

#now in preproc_functions/parse_args
parse_mprage_args "$@" #parse command line inputs

#if a .preproc_override file exists, parse args in that file, overriding the command line args in preceding step
if [ -f .preproc_override ]; then
    #there is a challenge of resplitting quoted arguments after read. This solution (eval) worked for this case
    #http://stackoverflow.com/questions/17338863/split-a-string-stored-in-a-variable-into-multiple-words-using-spaces-but-not-t
    read override_string < .preproc_override || echo "Did you forget a trailing newline in .preproc_override?"
    echo "Overriding the following command line arguments from .preproc_override: $override_string"
    eval override=($override_string)
    parse_mprage_args "${override[@]}"
fi

#dumpenv #output all variables to screen for debugging

case "$reference" in
    Tal_2mm)  bettedRefBrain=${stddir}/talairach_fsl_mni152/TalFSL_MNI152_T1_2mm_brain;
	unbettedRefBrain=${stddir}/talairach_fsl_mni152/TalFSL_MNI152_T1_2mm;
	refMask=${stddir}/talairach_fsl_mni152/TalFSL_MNI152_T1_2mm_brain_mask_dil;
	fnirtConfig=${stddir}/fnirtTalairachSettings.cnf;;
    MNI_2mm) bettedRefBrain=${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_2mm;
	unbettedRefBrain=${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_2mm;
	refMask=${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_mask_2mm_dil; #Nov2016: this is now a 1x dil, matching fsl_anat
	fnirtConfig=${FSLDIR}/etc/flirtsch/T1_2_MNI152_2mm.cnf;;
    MNI_FSL_2mm) bettedRefBrain=${stddir}/fsl_mni152/MNI152_T1_2mm_brain;
	unbettedRefBrain=${stddir}/fsl_mni152/MNI152_T1_2mm;
	refMask=${stddir}/fsl_mni152/MNI152_T1_2mm_brain_mask_dil;
	fnirtConfig=${FSLDIR}/etc/flirtsch/T1_2_MNI152_2mm.cnf;;
    SPM_2mm)  bettedRefBrain=${stddir}/spm8_mni/T1_brain;
	unbettedRefBrain=${stddir}/spm8_mni/T1;
	refMask=${stddir}/spm8_mni/brainmask_0.5thresh;
	fnirtConfig=${FSLDIR}/etc/flirtsch/T1_2_MNI152_2mm.cnf;;
    *) echo -e "Reference brain not recognized. Options are MNI_2mm, MNI_FSL_2mm, SPM_2mm, and Tal_2mm."; exit 1 ;;
esac

#define warped brain mask without dilation (used for creating a final betted image)
nodil=$( echo $refMask | sed -e 's/\(.*\)_dil$/\1/' )

if [[ ! -f ${bettedRefBrain}.nii && ! -f ${bettedRefBrain}.nii.gz  ]]; then
    echo -e "Skull stripped reference brain not found: $bettedRefBrain\n"
    exit 1
fi

#if unbetted reference is set, but file does not exist, throw error
if [[ ! -f ${unbettedRefBrain}.nii && ! -f ${unbettedRefBrain}.nii.gz ]]; then
    echo -e "Reference brain not found: $unbettedRefBrain\n"
    exit 1
fi

#check for the fnirt config file
if [ ! -f $fnirtConfig ]; then
    echo -e "FNIRT config file not found: $fnirtConfig\n"
    exit 1
fi

#if nifti passed in (i.e., skip dicom to nifti, then verify its existence
if [[ -n $nifti && ! -f $nifti ]]; then
    echo -e "Instructed to start preprocessing with nifti (-n), but file not found.\nFile:${nifti}\n"
    exit 1
fi

#figure out file extension for FSL programs
if [ -z $FSLOUTPUTTYPE ]; then
    export FSLOUTPUTTYPE=NIFTI_GZ
fi

if [ $FSLOUTPUTTYPE = NIFTI_GZ ]; then
    ext=".nii.gz"
elif [ $FSLOUTPUTTYPE = NIFTI ]; then
    ext=".nii"
else
    echo "Not setup to handle FSLOUTPUTTYPE: $FSLOUTPUTTYPE."
    exit 1
fi

if [ -n "${logFile}" ]; then
    if [ -f "${logFile}" ]; then
	#stat and date are not portable across Linux and BSD...
        [ $( uname ) = Darwin ] && mtime=$( stat -f "%Sm" -t "%Y%m%d_%H%M" "${logFile}" ) || mtime=$( date -r "${logFile}" +%Y%m%d_%H%M )
	mv "${logFile}" "${logFile}_${mtime}"
    fi
    
    #add absolute path to log file location
    logFile="$(pwd)/$( basename $logFile )" ##TODO: make path handling more robust to non-local directories

    echo "#!/bin/bash" > "${logFile}"
    echo "## Log of preprocessMprage commands" >> "${logFile}"
    echo -e "## Call: $thiscommandinfo" >> "${logFile}"
    [ -n "$override_string" ] && echo "## Override from .preproc_override: $override_string" >> "${logFile}"
fi

#if .mprage_nifti file exists, then DICOM -> NIFTI conversion completed and we should read nifti from file
if [[ -z "$nifti" && -f .mprage_nifti ]]; then
    read nifti < .mprage_nifti
fi

#check whether a .nii file was passed in, but FSL is using .nii.gz (or vice versa)
#in this case it is crucial to gzip or gunzip the file up front so that fslreorient2std overwrites
#the initial file and the reoriented file is used downstream

#for the moment, I haven't added the same check to preprocessFunctional because it prepends an underscore at the
#fslreorient2std step, which would avoid the ambiguity problem here.
if [ -n "$nifti" ]; then
    if [[ $nifti =~ .*.nii$ && $ext == .nii.gz ]]; then
	rel "Gzipping initial nifti input image to avoid ambiguous files downstream (FSL expects .nii.gz)" c
	rel "gzip $nifti"
    elif [[ $nifti =~ .*.nii.gz$ && $ext == .nii ]]; then
	rel "Gunzipping initial nifti input image to avoid ambiguous files downstream (FSL expects .nii)" c
	rel "gunzip $nifti"
    fi
fi

#if nifti undefined, assume the dicoms need to be converted
if [ -z "$nifti" ]; then
    ##############
    #convert dicom files to NIFTI
    rel "Converting DICOM files to NIFTI" c

    #check whether files exist
    #numFiles=$( ls | grep "$dicomPattern"  | wc -l )
    numFiles=$( ls $dicomPattern | wc -l )
    if [ $numFiles -eq 0 ]; then
	echo "No DICOM files found using pattern: $dicomPattern. If you have already converted DICOM to NIFTI and want to skip this step, pass in the unbetted structural image using the -n parameter. Example: preprocessMprage -n mprage.nii.gz"
	printHelp
	exit 1
    fi

    nifti="mprage.nii.gz" #used in bet step.

    #remove mprage.nii if it exists so that Dimon doesn't bomb out
    if [ -f mprage.nii ]; then
	rel "mv -f mprage.nii \"mprageBAK_$(date $datefmt).nii\""
    fi

    if [ -f mprage.nii.gz ]; then
	rel "mv -f mprage.nii.gz \"mprageBAK_$(date $datefmt).nii.gz\""
    fi

    #convert dicom to nifti using Dimon
    rel "Dimon \
	-infile_pattern \"${dicomPattern}\" \
	-GERT_Reco \
	-quit \
	-dicom_org \
	-sort_by_acq_time \
	-gert_write_as_nifti \
	-gert_create_dataset \
	-gert_to3d_prefix mprage"

    rm -f dimon.files*
    rm -f GERT_Reco_dicom*

    #if afnirc has compressor on, then above will already generate nii.gz
    if [ -f mprage.nii ]; then
	rel "gzip -f mprage.nii" #use -f to force overwrite in case where mprage.nii.gz exists, but we want to replace it.
    fi

    echo "mprage.nii.gz" > .mprage_nifti

    #Ask user what to do with original DICOM files unless passed on command line
    if [ -z $delDicom ]; then
	until [[ "$delDicom" = [AaNnYy] ]]; do
	    read -sn1 -p "Delete or archive original DICOM files? (y/n/a)" delDicom
	done
    fi

    case ${delDicom} in
	y|Y|yes|delete) echo -e "\nDeleting DICOM files"; rel "rm -f ${dicomPattern}" ;;
	n|N|no) echo -e "\nKeeping DICOM files" ;;
	a|A|archive) echo -e "\nArchiving DICOM files (mprage_dicom.tar.gz)"; rel "tar czf mprage_dicom.tar.gz ${dicomPattern}" && rel "rm -f ${dicomPattern}" ;;
    esac

fi

#strip off file extension to allow for suffix
T1=$( remove_ext $nifti )
[ -n "$brainmask" ] && brainmask=$( remove_ext $brainmask )

#check for cleanup only
if [ $cleanup_only -eq 1 ]; then
    rel "Cleaning up intermediate files for preprocessMprage." c
    cleanup_preprocessMprage
    exit 0
fi

#reorient structural to RPI/LPI to match template
rel "fslreorient2std $nifti $nifti"
[ -n "$brainmask" ] && rel "fslreorient2std $brainmask $brainmask"

if [ $robustfov -eq 1 ]; then
    if [ $( imtest "${T1}_fullfov" ) -eq 0 ]; then
	rel "Copying original mprage before FOV cleanup to ${T1}_fullfov" c
	rel "imcp ${T1} ${T1}_fullfov" #shouldn't re-run this step on clipped data if fullfov already exists because it will keep chopping 1mm
    fi
    rel "robustfov -i \"${T1}_fullfov\" -r \"${T1}\""

    if [ -n "$brainmask" ]; then
	[ $( imtest "${brainmask}_fullfov" ) -eq 0 ] && rel "imcp \"${brainmask}\" \"${brainmask}_fullfov\""
	rel "robustfov -i \"${brainmask}_fullfov\" -r \"${brainmask}\""
    fi
fi

#initial correction for any negative values in original image
fix_negatives "$T1"

#need to set default after processing options and dicom import
#to account for reference choice and filename
if [ -z "$outputFile" ]; then outputFile="${T1}_nonlinear_warp_${reference}"; fi

#adapted from fsl_anat to create a blurred image by downsampling
function quick_smooth() {
  in=$1
  out=$2
  rel "fslmaths $in -subsamp2 -subsamp2 -subsamp2 -subsamp2 vol16"
  rel "flirt -in vol16 -ref $in -out $out -noresampblur -applyxfm -paddingsize 16"
  # possibly do a tiny extra smooth to $out here?
  rel "imrm vol16"
}

type=1 # For FAST: 1 = T1w, 2 = T2w, 3 = PD

#Adapted from fsl_anat
#### BIAS FIELD CORRECTION (main work, although also refined later on if segmentation run)
# required input: ${T1}
# output: ${T1}_biascorr  [ other intermediates to be cleaned up ]
if [ $biasCorrect -eq 1 ] ; then
    rel "Performing bias field correction." c
    if [ $strongBias -eq 1 ] ; then
	rel "Estimating and removing field (stage 1 - large-scale fields)" c
	niter=5 #FAST iterations
	smooth=10 # bias field smoothing extent (FWHM) in mm; -l in FAST

	#create a highly smoothed T1 image for getting a rough brain mask
	quick_smooth "${T1}" "${T1}_s20"

	#divide T1 image by smoothed image
	rel "fslmaths ${T1} -div ${T1}_s20 ${T1}_hpf"

        #get a rough brain mask - it can be *VERY* rough (i.e. missing huge portions of the brain or including non-brain, but non-background)
	#use -f 0.1 to err on being over inclusive
	# Nov2016: add -R to the mix to improve initial skull strip that is more sensible (avoids ridiculous over-inclusiveness)
	rel "bet ${T1}_hpf ${T1}_hpf_brain -m -f 0.1 -R"

        # get a smoothed version without the edge effects
	rel "fslmaths ${T1} -mas ${T1}_hpf_brain_mask ${T1}_hpf_s20" #mask by hpf brain
	quick_smooth "${T1}_hpf_s20" "${T1}_hpf_s20" #smooth masked img
	quick_smooth "${T1}_hpf_brain_mask" "${T1}_initmask_s20"
	rel "fslmaths ${T1}_hpf_s20 -div ${T1}_initmask_s20 -mas ${T1}_hpf_brain_mask ${T1}_hpf2_s20"
	rel "fslmaths ${T1} -mas ${T1}_hpf_brain_mask -div ${T1}_hpf2_s20 ${T1}_hpf2_brain"

	# make sure the overall scaling doesn't change (equate medians)
	med0=$( fslstats ${T1} -k ${T1}_hpf_brain_mask -P 50 )
	med1=$( fslstats ${T1}_hpf2_brain -k ${T1}_hpf_brain_mask -P 50 )
	rel "fslmaths ${T1}_hpf2_brain -div $med1 -mul $med0 ${T1}_hpf2_brain"

	rel "Estimating and removing bias field (stage 2 - detailed fields)" c
	rel "fast -o ${T1}_initfast -l ${smooth} -b -B -t $type --iter=${niter} --nopve --fixed=0 -v ${T1}_hpf2_brain" #run on T1 with smoothed edge
	rel "fast -o ${T1}_initfast2 -l ${smooth} -b -B -t $type --iter=${niter} --nopve --fixed=0 -v ${T1}_initfast_restore" #run again on bias corrected image from above
	rel "fslmaths ${T1}_hpf_brain_mask ${T1}_initfast2_brain_mask" #copy mask for fast to match weak correction below
    else
	niter=10  #FAST iterations
	smooth=20 #bias field smoothing extent (FWHM) in mm; -l in FAST

	#for weak bias field correction, do not iterate the FAST as above (initfast, initfast2)
        # get a rough brain mask - it can be *VERY* rough (i.e. missing huge portions of the brain or including non-brain, but non-background) 
	# use -f 0.1 to err on being over inclusive.
	# Nov2016: add -R to the mix to improve initial skull strip that is more sensible (avoids ridiculous over-inclusiveness)
	rel "bet ${T1} ${T1}_initfast2_brain -m -f 0.1 -R"
	rel "fslmaths ${T1}_initfast2_brain ${T1}_initfast2_restore"
    fi

    # Run FAST (again) to improve bias field
    rel "fast -o ${T1}_fast -l ${smooth} -b -B -t $type --iter=${niter} --nopve --fixed=0 -v ${T1}_initfast2_restore"
    
    rel "Extrapolating bias field from central region" c

    # use the latest fast output
    rel "fslmaths ${T1} -div ${T1}_fast_restore -mas ${T1}_initfast2_brain_mask ${T1}_fast_totbias"
    rel "fslmaths ${T1}_initfast2_brain_mask -ero -ero -ero -ero ${T1}_initfast2_brain_mask2"
    rel "fslmaths ${T1}_fast_totbias -sub 1 ${T1}_fast_totbias" #subtract 1 from total bias
    rel "fslsmoothfill -i ${T1}_fast_totbias -m ${T1}_initfast2_brain_mask2 -o ${T1}_fast_bias"
    rel "fslmaths ${T1}_fast_bias -add 1 ${T1}_fast_bias" #re-add 1
    rel "fslmaths ${T1}_fast_totbias -add 1 ${T1}_fast_totbias"
    rel "fslmaths ${T1} -div ${T1}_fast_bias ${T1}_biascorr" #bias-corrected structural
else
    #no bias correction -- just copy T1 as is
    rel "Skipping bias field correction." c
    rel "fslmaths ${T1} ${T1}_biascorr"
fi


###############
#initial structural brain extraction for FLIRT
rel "Running brain extraction" c
if [ $ssmethod = bet ]; then
    [ -z "$betOpts" ] && betOpts="-R -f 0.5 -v" #default bet options if not set manually
    rel "bet ${T1}_biascorr ${T1}_bet_initial ${betOpts}"
elif [ -n "${brainmask}" ]; then
    if [ ! -f "${brainmask}${ext}" ]; then
	echo "Cannot locate -custom_brainmask: ${brainmask}${ext}"
	exit 1
    fi
    rel "fslmaths ${T1}_biascorr -mas $brainmask ${T1}_bet_initial" #apply custom brainmask
    ssmethod=custom #override ssmethod so that fnirt-inv doesn't fire below
else
    [ -z "$betOpts" ] && betOpts="-touchup -orig_vol" #default 3dss options
    rel "3dSkullStrip -input ${T1}_biascorr${ext} -prefix ${T1}_bet_initial${ext} ${betOpts}" #default option for initial strip
fi

#Handle gradient nonlinearity correction
#NB: relative to HCP pipeline, this step is executed after initial bias field correction.
#This was chosen because the bias field steps (based on fsl_anat) tended to be prone to small values outside the brain,
#leading the bias-corrected image to have rather low mean values and the skull strip step to under extract.
#There should be no adverse consequences conceptually to putting gradient unwarping just before the structural -> template
#warp since it will simply apply the gradient correction on the full image sans bias field.

#NB: also differing from HCP, the structural pipeline is generally performed with gradient-distorted images.
#Gradient undistortion is applied when computing the warp to MNI to maximize alignment to template.
#It is also applied at the end of the pipeline in files labeled _postgdc.
#The logic is that preprocessFunctional can take advantage of gradient unwarping with no major overhaul if we
# a) pass in the gradient-distorted mprage_bet
# b) pass in the concatenated structural -> undistorted structural -> MNI transformation

warpsuffix= #whether to include _postgdc in the flirt and fnirt steps (if gradient undistortion requested)
if [ -n "$gcoeffs" ]; then
    #check that command exists
    command -v gradient_unwarp.py >/dev/null 2>&1 || { echo "Cannot find gradient_unwarp.py. Aborting." >&2; exit 1; }

    #allow coeffs to be in scripts directory
    if [ ! -r "$gcoeffs" ]; then
	if [ ! -r "${scriptDir}/cfg_files/${gcoeffs}" ]; then
	    echo "Unable to locate -grad_unwarp file: $gcoeffs"
	    exit 1
	else
	    gcoeffs="${scriptDir}/cfg_files/${gcoeffs}"
	fi
    fi

    #initial run of gradient undistortion using python script
    rel "gradient_unwarp.py \"${T1}_biascorr${ext}\" \"${T1}_biascorr_gdc_orig${ext}\" siemens -g \"$gcoeffs\" -n"
    rel "convertwarp --abs --ref=\"${T1}_biascorr\" --warp1=fullWarp_abs --relout --out=gdc_warpfield" #--jacobian=gdc_jacobian
    #fslmaths gdc_jacobian -Tmean gdc_jacobian #omitting because jacobian is unused in the unwarping process    
    rel "applywarp --rel --interp=spline -i \"${T1}_biascorr\" -r \"${T1}_biascorr\" -w gdc_warpfield -o \"${T1}_biascorr_postgdc\""
    rel "applywarp --rel --interp=spline -i \"${T1}_bet_initial\" -r \"${T1}_bet_initial\" -w gdc_warpfield -o \"${T1}_bet_initial_postgdc\""
    warpsuffix=_postgdc
fi

#correct any negatives from GDC procedure
fix_negatives "${T1}_biascorr_postgdc"
fix_negatives "${T1}_bet_initial_postgdc"

##############
#warp structural to standard space (MNI or Talairach)
#first conduct affine (linear) warping to get linear warp coefficients
#note that flirt works with betted reference brain, but fnirt prefers unbetted
flirtAffCoef="${T1}_to_${reference}_affine.mat"

#if [ $( imtest "${T1}_warp_linear" ) -eq 0 ]; then
rel "Running affine (linear) transformation for structural -> template" c
rel "flirt -in ${T1}_bet_initial${warpsuffix} -ref $bettedRefBrain -omat ${flirtAffCoef} -out ${T1}\"_warp_linear\" -dof 12 -interp spline"
#fi

###############
#now nonlinear warp

rel "Running nonlinear transformation to warp mprage to: ${reference}" c
rel "Using warp resolution of $wr mm" c

#Note: fsl_anat generates a mask from the template brain_mask by -fillh -dilF.
#Previously FSL tools used the dil mask that had been dilated 2x -dilF -dilF.
#Not sure of the relevance (the fsl_anat way leads to a smaller mask).

#re-run fnirt even if output already exists because files upstream may have been changed (e.g., betted mprage)
rel "fnirt --ref=$unbettedRefBrain --refmask=$refMask --in=${T1}_biascorr${warpsuffix} --aff=$flirtAffCoef \
        --fout=\"$( remove_ext ${outputFile} )_warpfield\" --cout=\"${T1}_warpcoef\" --iout=\"$outputFile\" \
	--config=$fnirtConfig --logout=${T1}_to_${reference}_fnirt_settings.log --warpres=${wr},${wr},${wr} -v"

#compute MNI -> anat transformation
rel "invwarp --ref=${T1}_biascorr${warpsuffix} -w ${T1}_warpcoef -o template_to_subject_warpcoef"

#define warp files used for struct -> MNI and MNI -> struct
mni2anat="template_to_subject_warpcoef"
anat2mni="${T1}_warpcoef"

#Apply gradient correction and nonlinear warp in one interpolation (need to convertwarp to concatenate both)
if [ -n "$gcoeffs" ]; then
    rel "immv \"$outputFile\" \"${outputFile}_twostepinterp\""
    rel "convertwarp --ref=$unbettedRefBrain --warp1=gdc_warpfield --warp2=${T1}_warpcoef --out=${T1}_warpcoef_withgdc --relout"
    rel "applywarp --rel --in=${T1}_biascorr --ref=$unbettedRefBrain --warp=${T1}_warpcoef_withgdc --interp=spline --out=\"$outputFile\""
    mni2anat="template_to_subject_warpcoef_gdistort"
    anat2mni="${T1}_warpcoef_withgdc"

    #compute warp of MNI template onto subject's brain, applying gradient disortion
    rel "invwarp --ref=${T1}_biascorr -w gdc_warpfield -o gdc_inv_warpfield"
    rel "convertwarp --ref=${T1}_biascorr --warp1=template_to_subject_warpcoef --warp2=gdc_inv_warpfield -o template_to_subject_warpcoef_gdistort"
fi

#warp template to subject (incl. gradient distortion if needed)
rel "applywarp --interp=spline --in=$bettedRefBrain --ref=${T1}_biascorr -w ${mni2anat} -o template_to_subject_brain"

#compute final skull-stripped image
if [ $ssmethod = fnirt-inv ]; then
    rel "Generating brain mask based on inverse warp from template" c
    rel "applywarp --interp=nn --in=$nodil --ref=${T1}_biascorr -w ${mni2anat} -o ${T1}_biascorr_brain_mask"
    rel "fslmaths ${T1}_biascorr_brain_mask -fillh ${T1}_biascorr_brain_mask"
    rel "fslmaths ${T1}_biascorr -mas ${T1}_biascorr_brain_mask ${T1}_bet"
else
    rel "fslmaths ${T1}_bet_initial ${T1}_bet" #straight copy
    rel "fslmaths ${T1}_bet_initial -bin ${T1}_biascorr_brain_mask -odt char" #create brainmask from non-zero voxels of betted image
fi
    
if [[ -f "${bettedRefBrain}.nii" && ! -h ./template_brain.nii ]]; then
    ln -s "${bettedRefBrain}.nii" ./template_brain.nii
    tbrain=template_brain.nii
elif [[ -f "${bettedRefBrain}.nii.gz" && ! -h ./template_brain.nii.gz ]]; then
    ln -s "${bettedRefBrain}.nii.gz" ./template_brain.nii.gz
    tbrain=template_brain.nii.gz
fi

#Perform tissue segmentation here to avoid running FAST multiple times with parallel preprocessFunctional jobs
#WM segmentation is used for bbr co-registration
#also improves bias field correction here by running again
if [ $( imtest ${T1}_bet_fast ) -eq 0 ]; then
    #adapted from fsl_anat
    # required input: ${T1}_biascorr ${T1}_biascorr_brain ${T1}_biascorr_brain_mask
    # output: ${T1}_biascorr ${T1}_biascorr_brain (modified) ${T1}_fast* (as normally output by fast) ${T1}_fast_bias (modified)
    rel "Performing tissue-type segmentation" c
    
    # setting the smoothing parameter and number of iterations for cases which bias field was not calculated. 
    niter=10 
    smooth=20
	
    rel "fast -o ${T1}_bet_fast -n 3 -g -H 0.1 -l ${smooth} -b -B -t $type --iter=${niter} ${T1}_bet"
    rel "immv ${T1}_biascorr ${T1}_bet_initbias" #bias field correction up to this point
    rel "fslmaths ${T1}_bet_fast_restore ${T1}_bet" #use the further refinement of the bias field as the mprage_bet output

    # extrapolate bias field and apply to the whole head image
    rel "fslmaths ${T1}_bet_initbias -div ${T1}_bet_fast_restore -mas ${T1}_biascorr_brain_mask ${T1}_fast_totbias"
    rel "fslmaths ${T1}_fast_totbias -sub 1 ${T1}_fast_totbias"
    rel "fslsmoothfill -i ${T1}_fast_totbias -m ${T1}_biascorr_brain_mask -o ${T1}_fast_bias"
    rel "fslmaths ${T1}_fast_bias -add 1 ${T1}_fast_bias"
    rel "fslmaths ${T1}_fast_totbias -add 1 ${T1}_fast_totbias"
    rel "fslmaths ${T1}_bet_initbias -div ${T1}_fast_bias ${T1}_biascorr"

    # regenerate the standard space structural with the updated bias field correction applied ${T1}_biascorr
    rel "applywarp --rel --in=${T1}_biascorr --ref=$unbettedRefBrain --warp=${anat2mni} --interp=spline --out=\"$outputFile\""
    rel "fslmaths ${T1}_bet_fast_pve_2 -thr 0.5 -bin ${T1}_bet_fast_wmseg" #create binary WM mask

    #generate skull-stripped version of final warped file (after final bias correction)
    rel "fslmaths ${outputFile} -mas $nodil $( remove_ext ${outputFile} )_bet"
fi

#reapply gradient distortion correction on final native-space files
if [ -n "$gcoeffs" ]; then
    rel "applywarp --rel --interp=spline -i \"${T1}_biascorr\" -r \"${T1}_biascorr\" -w gdc_warpfield -o \"${T1}_biascorr_postgdc\""
    rel "applywarp --rel --interp=spline -i \"${T1}_bet\" -r \"${T1}_bet\" -w gdc_warpfield -o \"${T1}_bet_postgdc\""

    #correct any negatives from GDC procedure
    fix_negatives "${T1}_biascorr_postgdc"
    fix_negatives "${T1}_bet_initial_postgdc"
fi

#create png to check registration
rel "applywarp --ref=\"$unbettedRefBrain\" --mask=\"$refMask\" --in=\"${T1}_bet\" --warp=\"${anat2mni}\" --interp=spline --out=subject_to_template_brain"

#note: first input to slicer is rendered image, second is overlay
slicer subject_to_template_brain "$bettedRefBrain" -s 2 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png \
    -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png \
    -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png

pngappend sla.png + slb.png + slc.png + sld.png - sle.png + slf.png + slg.png + slh.png - sli.png + slj.png + slk.png + sll.png highres2standard1.png

montage -label "Subject brain with template outline overlaid" highres2standard1.png -pointsize 30 -geometry +0+0 highres2standard1.png

slicer "$bettedRefBrain" subject_to_template_brain -s 2 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png \
    -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png \
    -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png

pngappend sla.png + slb.png + slc.png + sld.png - sle.png + slf.png + slg.png + slh.png - sli.png + slj.png + slk.png + sll.png highres2standard2.png

montage -label "Template with subject brain outline overlaid" highres2standard2.png -pointsize 30 -geometry +0+0 highres2standard2.png

pngappend highres2standard1.png - highres2standard2.png struct_to_template.png; 
rm -f sl?.png highres2standard2.png  highres2standard1.png
imrm subject_to_template_brain

#generate symbolic link to skull-stripped mprage file for compatibility with FSL tools
ln -sfn "${T1}_bet${ext}" "${T1}_brain${ext}"

if [ $cleanup -eq 1 ]; then
    rel "Cleaning up preprocessMprage intermediate files." c
    cleanup_preprocessMprage
fi

# write finish time, mv incomplete to complete
echo "# finished $(date $datefmt)" >> ${dotfile}_incomplete
mv ${dotfile}_incomplete ${dotfile}_complete

#suggestions for QA
rel "" c
rel "QA suggestions (from least to most important):" c
rel "Initial skull strip. Primarily a worry if large parts of brain tissue are missing (e.g., cerebellum)." c
rel "   fslview ${T1}${ext} ${T1}_bet_initial${ext}" c
rel "Linear (affine) alignment of skull-stripped subject brain onto template." c
rel "This will be negatively affected if skull strip is poor. But you should only expect overall global alignment" c
rel "   fslview $tbrain ${T1}_warp_linear${ext}" c
rel "Nonlinear warp of template brain onto subject (inverse warp). Check especially for global shape problems." c
rel "   fslview ${T1}_bet${ext} template_to_subject_brain${ext}" c
rel "Nonlinear warp of subject brain onto template. Look for alignment of sulci, especially along midline." c
rel "   fslview $tbrain $( remove_ext ${outputFile} )_bet${ext}" c
