#!/bin/bash

function warp_structmask_to_func {
    structvol="${1}"
    outvol="${2}"

    #warp anatomical mask into functional space
    if [ $( imtest "unwarp/T1_UD_warp_bbr" ) -eq 1 ]; then
	rel "Using inverse of unwarp/T1_UD_warp_bbr to warp $structvol into functional space with distortion" c
	[ ! -f "unwarp/struct_to_func_transform_and_distort${ext}" ] && rel "invwarp -w unwarp/T1_UD_warp_bbr -o unwarp/struct_to_func_transform_and_distort -r unwarp/EF_D_mc_target"
	rel "applywarp --in=\"${structvol}\" --out=\"${outvol}\" --interp=spline --ref=mc_target --warp=unwarp/struct_to_func_transform_and_distort"
    else
	rel "Using struct_to_func transform to warp csf mask into functional space" c
	rel "applywarp --in=\"${structvol}\" --out=\"${outvol}\" --interp=spline --ref=mc_target --premat=struct_to_func.mat"
    fi

}

function compute_nuisance_regressors {
    declare -a nuisancecols #nuisance regressors to be concatenated

    if [ $no_warp -eq 0 ]; then
	#extracting time series from post-warp files to leverage tissue probability maps for templates
	local func_ts="${postWarp}"
    else
	#if despiking was applied, use this file for extracting CSF, WM, GS time series. Otherwise, use the file after skull strip, motion, and slice timing
	[ -n "${postDespike}" ] && local func_ts="${postDespike}" || local func_ts="${postSS}"
    fi

    #parse comma-delimited regressors of interest into array
    OLDIFS="${IFS}"
    IFS=',' read -ra reg <<< "$nuisance_regressors"
    IFS="${OLDIFS}"
    #reg=$( printf "%s\n" "${reg[@]}" | sort -u ) #eliminate any duplicate regressors
    #switched to perl because it does not reorder regressors
    reg=$( printf "%s\n" "${reg[@]}" | perl -ne 'print if ! $a{$_}++' ) #eliminate any duplicate regressors

    for r in $reg; do
	if [[ "$r" =~ ^(6motion|rx|ry|rz|tx|ty|tz)$ && ! -f ".motion_demean" ]]; then 
	    #compute de-meaned motion parameters for nuisance regression
	    1d_tool.py -overwrite -infile motion.par -set_nruns 1 \
		-demean -write .motion_demean	    
	fi

	if [[ "$r" =~ ^(d6motion|drx|dry|drz|dtx|dty|dtz)$ && ! -f ".motion_deriv" ]]; then 
	    #compute motion parameter derivatives for nuisance regression
	    1d_tool.py -overwrite -infile motion.par -set_nruns 1 \
		-derivative -demean -write .motion_deriv
	fi

	if [[ "$r" =~ ^(csf|dcsf|csf[0-9]+|dcsf[0-9]+)$ && ! -f ".csf_ts" ]]; then
	    #technically should probably change this to allow for use of templates for -warp_compute
	    if [ $no_warp -eq 0 ]; then
		#if we have a warp to standard space then use the inverse warp to transform the csf mask from the probabilistic atlas to subject space
		if [ $templateName = MNI_3mm ]; then
		    #thr 0.95 without erosian is best: 95 voxels
		    rel "fslmaths \"$stddir/mni_icbm152_nlin_asym_09c/mni_icbm152_csf_tal_nlin_asym_09c_3mm\" -thr 0.95 -bin .template_csf_prob"
		elif [ $templateName = MNI_2.3mm ]; then
		    #thr 0.98 without erosion works well here: 274 voxels
		    rel "fslmaths \"$stddir/mni_icbm152_nlin_asym_09c/mni_icbm152_csf_tal_nlin_asym_09c_2.3mm\" -thr 0.98 -bin .template_csf_prob"
		elif [ $templateName = MNI_2mm ]; then
		    rel "fslmaths \"$stddir/mni_icbm152_nlin_asym_09c/mni_icbm152_csf_tal_nlin_asym_09c_2mm\" -thr 0.98 -bin .template_csf_prob"
		elif [ $templateName = SPM_2mm ]; then
		    #thr 0.6 works best here: 193 voxels
		    rel "fslmaths \"$stddir/spm8_mni/csf.nii\" -thr 0.6 -bin -eroF .template_csf_prob"	    
		elif [ $templateName = MNI_FSL_3mm ]; then
		    #for the FSL MNI, thr 0.5 with erosion works well visually: 87 voxels
		    rel "fslmaths \"$stddir/fsl_mni152/avg152T1_csf_3mm.nii\" -thr 0.7 -bin .template_csf_prob"	    
		else
		    rel "Unsupported template brain for CSF extraction: $templateName" c
		    exit 1
		fi

		local csfmask=.template_csf_prob${ext}    
	    else
		#use the subject's segmented anatomical scan to identify the csf voxels
		
		#fast segmentation should have been run during preprocessMprage
		#use pve_0 for csf
		#re-run FAST here if needed
		[ $( imtest "${mprageBet_base}_fast_seg_0" ) -eq 0 ] && rel "fast -g -o \"${mprageBet_base}_fast\" \"${mprageBet_base}\""

		warp_structmask_to_func "${mprageBet_base}_fast_pve_0" .csf_pve

		#threshold at 0.8 to ensure that only voxels likely to be csf are retained	    
		rel "fslmaths .csf_pve -thr 0.8 -bin .csf_pve_thr0p8"

		#erode csf mask once to reduce risk of partial volume
		rel "3dmask_tool -overwrite -input .csf_pve_thr0p8${ext} -dilate_result -1 -prefix .csf_pve_thr0p8_ero1${ext}"

		#cluster csf mask and only retain clusters of 5 or more contiguous voxels
		rel "cluster -i .csf_pve_thr0p8_ero1 -t 1.0 --osize=.csf_pve_clustsize --no_table"	    
		rel "fslmaths .csf_pve_clustsize -thr 5.01 -bin -mas ${postSS}_tmean_mask .csf_mask -odt char" #multiply by tight brain mask to eliminate non-brain voxels
		
		#if fewer than 20 CSF voxels (in functional space) are present, revert to a non-dilated csf mask
		#too few voxels may result in undue influece of a given CSF voxel on the mask average
		local nvox=$( 3dBrickStat -non-zero -count .csf_mask${ext} )

		if [ $nvox -lt 20 ]; then
		    rel "Warning: fewer than 20 CSF voxels were found in .csf_mask. Reverting to a non-dilated mask" c	
		    rel "cluster -i .csf_pve_thr0p8 -t 1.0 --osize=.csf_pve_clustsize_noero --no_table"
		    rel "fslmaths .csf_pve_clustsize_noero -thr 15.01 -bin -mas ${postSS}_tmean_mask .csf_mask_noero -odt char"

		    local csfmask=.csf_mask_noero${ext}
		else
		    local csfmask=.csf_mask${ext}
		fi
		
		#cleanup some intermediate files
		rel "imrm .csf_pve_thr0p8 .csf_pve_thr0p8_ero1 .csf_pve_clustsize .csf_pve_clustsize_noero"
	    fi
	    
	    #extract CSF time series. If a number follows the CSF specification, this is an aCompCor approach with the specified number of components
	    if [[ "$r" =~ ^(csf[0-9]+|dcsf[0-9]+)$ ]]; then
		rel "3dmaskSVD -vnorm -mask $csfmask -sval ${r/?(d)csf/} -polort 2 ${func_ts}${ext} > .csf_ts" || ( echo "3dmaskSVD failed. Unable to extract CSF voxels. Check your mask! $csfmask" && exit 1 )
	    else
		rel "3dmaskave -mask $csfmask -q ${func_ts}${ext} > .csf_ts" || ( echo "3dmaskave failed. Unable to extract CSF voxels. Check your mask! $csfmask" && exit 1 )
	    fi
	    
	    rel "1d_tool.py -overwrite -infile .csf_ts -derivative -write .csf_ts_deriv"
	fi

	if [[ "$r" =~ ^(wm|dwm|wm[0-9]+|dwm[0-9]+)$ && ! -f ".wm_ts" ]]; then
	    if [ $no_warp -eq 0 ]; then
		#if we have a warp to standard space then use the inverse warp to transform the wm mask from the probabilistic atlas to subject space
		if [ $templateName = MNI_3mm ]; then
		    #0.9 with erosion gives nice mask: 793 voxels
		    rel "fslmaths \"$stddir/mni_icbm152_nlin_asym_09c/mni_icbm152_wm_tal_nlin_asym_09c_3mm\" -thr 0.9 -bin -eroF .template_wm_prob"
		elif [ $templateName = MNI_2.3mm ]; then
		    #0.95 with erosion: 2681 voxels
		    rel "fslmaths \"$stddir/mni_icbm152_nlin_asym_09c/mni_icbm152_wm_tal_nlin_asym_09c_2.3mm\" -thr 0.95 -bin -eroF .template_wm_prob"
		elif [ $templateName = MNI_2mm ]; then		    
		    rel "fslmaths \"$stddir/mni_icbm152_nlin_asym_09c/mni_icbm152_wm_tal_nlin_asym_09c_2mm\" -thr 0.95 -bin -eroF .template_wm_prob"
		elif [ $templateName = SPM_2mm ]; then
		    #0.85 with erosion: 2981 voxels
		    rel "fslmaths \"$stddir/spm8_mni/white.nii\" -thr 0.85 -bin -eroF .template_wm_prob"
		elif [ $templateName = MNI_FSL_3mm ]; then
		    #0.8 with erosion: 659 voxels
		    rel "fslmaths \"$stddir/fsl_mni152/avg152T1_white_3mm.nii\" -thr 0.8 -bin -eroF .template_wm_prob"	    
		else
		    rel "Unsupported template brain for WM extraction: $templateName" c
		    exit 1
		fi

		local wmmask=.template_wm_prob${ext}
	    else

		#fast segmentation should have been run during preprocessMprage
		#use seg_2 for wm
		#re-run FAST here if needed
		[ $( imtest "${mprageBet_base}_fast_seg_2" ) -eq 0 ] && rel "fast -g -o \"${mprageBet_base}_fast\" \"${mprageBet_base}\""

		warp_structmask_to_func "${mprageBet_base}_fast_pve_2" .wm_pve

		#threshold at 0.8 to ensure that only voxels likely to be wm are retained	    
		rel "fslmaths .wm_pve -thr 0.8 -bin .wm_pve_thr0p8"

		#erode wm mask twice to reduce risk of partial WM voxels
		#more contiguous wm voxels than csf voxels -- hence 2x dilation works well in general as a start to retain deep cerebral white matter
		rel "3dmask_tool -overwrite -input .wm_pve_thr0p8${ext} -dilate_result -2 -prefix .wm_pve_thr0p8_ero2${ext}"

		#cluster wm mask and only retain clusters of 15 or more contiguous voxels
		rel "cluster -i .wm_pve_thr0p8_ero2 -t 1.0 --osize=.wm_pve_clustsize --no_table"
		rel "fslmaths .wm_pve_clustsize -thr 15.01 -bin -mas ${postSS}_tmean_mask .wm_mask -odt char"
		
		#check that at least 50 voxels are present in mask to get a reasonable sampling distribution of WM timeseries
		local nvox=$( 3dBrickStat -non-zero -count .wm_mask${ext} )

		if [ $nvox -lt 50 ]; then
		    #go back to a 1x erosion, but up voxel clusters to 50 minimum
		    rel "Warning: fewer than 50 WM voxels were found in .wm_mask. Reverting to a 1x eroded WM mask" c
		    rel "3dmask_tool -overwrite -input .wm_pve_thr0p8${ext} -dilate_result -1 -prefix .wm_pve_thr0p8_ero1${ext}"
		    
		    rel "cluster -i .wm_pve_thr0p8_ero1 -t 1.0 --osize=.wm_pve_clustsize_ero1 --no_table"
		    rel "fslmaths .wm_pve_clustsize_ero1 -thr 50.01 -bin -mas ${postSS}_tmean_mask .wm_mask_ero1 -odt char"

		    local wmmask=.wm_mask_ero1${ext}
		else
		    local wmmask=.wm_mask${ext}
		fi    

		#cleanup some intermediate files
		rel "imrm .wm_pve_thr0p8 .wm_pve_thr0p8_ero2 .wm_pve_thr0p8_ero1 .wm_pve_clustsize .wm_pve_clustsize_noero_ero1"
	    fi

	    #extract WM time series. If a number follows the WM specification, this is an aCompCor approach with the specified number of components
	    if [[ "$r" =~ ^(wm[0-9]+|wm[0-9]+)$ ]]; then
		rel "3dmaskSVD -vnorm -mask $wmmask -sval ${r/?(d)wm/} -polort 2 ${func_ts}${ext} > .wm_ts" || ( echo "3dmaskSVD failed. Unable to extract WM voxels. Check your mask! $wmmask" && exit 1 )
	    else
		rel "3dmaskave -mask $wmmask -q ${func_ts}${ext} > .wm_ts" || ( echo "3dmaskave failed. Unable to extract WM voxels. Check your mask! $wmmask" && exit 1 )
	    fi
	    
	    rel "1d_tool.py -overwrite -infile .wm_ts -derivative -write .wm_ts_deriv"
	fi

	#global signal
	if [[ "$r" =~ ^(gs|dgs)$ && ! -f ".gs_ts" ]]; then
	    #erode the tight skull-stripped brain mask from the structural scan to identify brain voxels
	    rel "fslmaths ${mprageBet_base} -bin -eroF -eroF .brainmask_ero2x_anat -odt char" #eroding the binarized mprage_bet

	    warp_structmask_to_func .brainmask_ero2x_anat .brainmask_ero2x

	    rel "fslmaths .brainmask_ero2x -mas ${postSS}_tmean_mask .brainmask_ero2x -odt char" #mask by functional brain mask

	    rel "3dmaskave -mask .brainmask_ero2x${ext} -q ${func_ts}${ext} > .gs_ts"
	    rel "1d_tool.py -overwrite -infile .gs_ts -derivative -write .gs_ts_deriv"
	fi

	case "$r" in 
	    6motion)
		nuisancecols+=(".motion_demean[0]")
		nuisancecols+=(".motion_demean[1]")
		nuisancecols+=(".motion_demean[2]")
		nuisancecols+=(".motion_demean[3]")
		nuisancecols+=(".motion_demean[4]")
		nuisancecols+=(".motion_demean[5]")
		;;
	    rx)
		nuisancecols+=(".motion_demean[0]");;
	    ry)
		nuisancecols+=(".motion_demean[1]");;
	    rz)
		nuisancecols+=(".motion_demean[2]");;
	    tx)
		nuisancecols+=(".motion_demean[3]");;
	    ty)
		nuisancecols+=(".motion_demean[4]");;
	    tz)
		nuisancecols+=(".motion_demean[5]");;
	    d6motion)
		nuisancecols+=(".motion_deriv[0]")
		nuisancecols+=(".motion_deriv[1]")
		nuisancecols+=(".motion_deriv[2]")
		nuisancecols+=(".motion_deriv[3]")
		nuisancecols+=(".motion_deriv[4]")
		nuisancecols+=(".motion_deriv[5]")
		;;
	    drx)
		nuisancecols+=(".motion_deriv[0]");;
	    dry)
		nuisancecols+=(".motion_deriv[1]");;
	    drz)
		nuisancecols+=(".motion_deriv[2]");;
	    dtx)
		nuisancecols+=(".motion_deriv[3]");;
	    dty)
		nuisancecols+=(".motion_deriv[4]");;
	    dtz)
		nuisancecols+=(".motion_deriv[5]");;
	    wm)
		nuisancecols+=(".wm_ts");;
	    dwm)
		nuisancecols+=(".wm_ts_deriv");;
	    csf)
		nuisancecols+=(".csf_ts");;
	    dcsf)
		nuisancecols+=(".csf_ts_deriv");;
	    gs)
		nuisancecols+=(".gs_ts");;
	    dgs)
		nuisancecols+=(".gs_ts_deriv");;	    
	esac

    done

    rel "Creating ${nuisance_file} containing regressors as columns: ${nuisancecols[*]}" c
    rel "1dcat -overwrite ${nuisancecols[@]} > ${nuisance_file}"
    
}

function nuisance_regression {
    #handle nuisance regression and/or bandpass filtering
    [[ "$nuisance_compute" -eq 0 && "$nuisance_regression" -eq 0 && "$bandpass_filter" -eq 0 ]] && return 0 #no nuisance or bandpass, exit

    preNRBP="${prefix}${funcFile}${smoothing_suffix}${ext}"
    
    local todo=
    if [[ "$nuisance_regression" -eq 1 && "$bandpass_filter" -eq 1 ]]; then todo="br" #bandpass and regression
    elif [ "$nuisance_regression" -eq 1 ]; then todo="r" #regression only
    elif [ "$bandpass_filter" -eq 1 ]; then todo="b" #bandpass alone
    fi

    prefix="${todo}${prefix}"
    postNRBP="${prefix}${funcFile}${smoothing_suffix}${ext}"

    #check whether requisite steps are complete
    [[ -f .nuisance_regression_complete && $todo=r ]] && return 0
    [[ -f .bandpass_filter_complete && $todo=b ]] && return 0
    [[ -f .nuisance_regression_complete && -f .bandpass_filter_complete && $todo=br ]] && return 0

    if [[ ! -f "${nuisance_file}" && ( $nuisance_regression == 1 || $nuisance_compute == 1 ) ]]; then
	compute_nuisance_regressors
    fi

    #bandpass only
    if [ "$todo" = "b" ]; then
	rel "3dBandpass -input \"$preNRBP\" -mask \"${subjMask}${ext}\" -dt $tr \
		-prefix \"$postNRBP\" $bpLow $bpHigh"

	rel "date > .bandpass_filter_complete"
    elif [ "$todo" = "br" ]; then
        rel "3dBandpass -overwrite -input \"$preNRBP\" -mask \"${subjMask}${ext}\" -dt $tr \
		-prefix \"$postNRBP\" -ort ${nuisance_file} $bpLow $bpHigh"

	rel "date > .bandpass_filter_complete"
	rel "date > .nuisance_regression_complete"
    elif [ "$todo" = "r" ]; then
        rel "3dDetrend -overwrite -verb -polort 2 -vector ${nuisance_file} \
		-prefix \"$postNRBP\" \"$preNRBP\""
	
	#need to mask detrend by brain mask as with 3dBandpass
	rel "fslmaths \"$postNRBP\" -mas \"$subjMask\" \"$postNRBP\""
	rel "date > .nuisance_regression_complete"
    fi
    
    #explicit return code needed to avoid implicit status of prior command
    return 0

}
