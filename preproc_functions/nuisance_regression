#!/bin/bash

function warp_structmask_to_func {
    structvol="${1}"
    outvol="${2}"

    #warp anatomical mask into functional space
    if [ $( imtest "unwarp/T1_UD_warp_bbr" ) -eq 1 ]; then
	rel "Using inverse of unwarp/T1_UD_warp_bbr to warp $structvol into functional space with distortion" c
	[ ! -f "unwarp/struct_to_func_transform_and_distort${ext}" ] && rel "invwarp -w unwarp/T1_UD_warp_bbr -o unwarp/struct_to_func_transform_and_distort -r unwarp/EF_D_mc_target"
	rel "applywarp --in=\"${structvol}\" --out=\"${outvol}\" --interp=spline --ref=mc_target --warp=unwarp/struct_to_func_transform_and_distort"
    else
	rel "Using struct_to_func transform to warp csf mask into functional space" c
	rel "applywarp --in=\"${structvol}\" --out=\"${outvol}\" --interp=spline --ref=mc_target --premat=struct_to_func.mat"
    fi

}

function compute_nuisance_regressors {
    declare -a nuisancecols #nuisance regressors to be concatenated

    #if despiking was applied, use this file for extracting CSF, WM, GS time series. Otherwise, use the file after skull strip, motion, and slice timing
    [ -n "${postDespike}" ] && local func_ts="${postDespike}" || local func_ts="${postSS}"

    #parse comma-delimited regressors of interest into array
    OLDIFS="${IFS}"
    IFS=',' read -ra reg <<< "$nuisance_regressors"
    IFS="${OLDIFS}"
    reg=$( printf "%s\n" "${reg[@]}" | sort -u ) #eliminate any duplicate regressors

    for r in $reg; do
	if [[ "$r" =~ ^(6motion|rx|ry|rz|tx|ty|tz)$ && ! -f ".motion_demean" ]]; then 
	    #compute de-meaned motion parameters for nuisance regression
	    1d_tool.py -overwrite -infile motion.par -set_nruns 1 \
		-demean -write .motion_demean	    
	fi

	if [[ "$r" =~ ^(d6motion|drx|dry|drz|dtx|dty|dtz)$ && ! -f ".motion_deriv" ]]; then 
	    #compute motion parameter derivatives for nuisance regression
	    1d_tool.py -overwrite -infile motion.par -set_nruns 1 \
		-derivative -demean -write .motion_deriv
	fi

	if [[ "$r" =~ ^(csf|dcsf)$ && ! -f ".csf_ts" ]]; then
	    #fast segmentation should have been run during preprocessMprage
	    #use pve_0 for csf
	    #re-run FAST here if needed
	    [ $( imtest "${mprageBet_base}_fast_seg_0" ) -eq 0 ] && rel "fast -g -o \"${mprageBet_base}_fast\" \"${mprageBet_base}\""

	    warp_structmask_to_func "${mprageBet_base}_fast_pve_0" .csf_pve

	    #threshold at 0.8 to ensure that only voxels likely to be csf are retained	    
	    rel "fslmaths .csf_pve -thr 0.8 -bin .csf_pve_thr0p8"

	    #erode csf mask once to reduce risk of partial volume
	    rel "3dmask_tool -overwrite -input .csf_pve_thr0p8${ext} -dilate_result -1 -prefix .csf_pve_thr0p8_ero1${ext}"

	    #cluster csf mask and only retain clusters of 5 or more contiguous voxels
	    rel "cluster -i .csf_pve_thr0p8_ero1 -t 1.0 --osize=.csf_pve_clustsize --no_table"	    
	    rel "fslmaths .csf_pve_clustsize -thr 5.01 -bin -mas ${postSS}_tmean_mask .csf_mask -odt char" #multiply by tight brain mask to eliminate non-brain voxels
	    
	    #if fewer than 20 CSF voxels (in functional space) are present, revert to a non-dilated csf mask
	    #too few voxels may result in undue influece of a given CSF voxel on the mask average
	    local nvox=$( 3dBrickStat -non-zero -count .csf_mask${ext} )

	    if [ $nvox -lt 20 ]; then
		rel "Warning: fewer than 20 CSF voxels were found in .csf_mask. Reverting to a non-dilated mask" c	
		rel "cluster -i .csf_pve_thr0p8 -t 1.0 --osize=.csf_pve_clustsize_noero --no_table"
		rel "fslmaths .csf_pve_clustsize_noero -thr 15.01 -bin -mas ${postSS}_tmean_mask .csf_mask_noero -odt char"

		#obtain CSF timeseries from CSF mask in functional space
		rel "3dmaskave -mask .csf_mask_noero${ext} -q ${func_ts}${ext} > .csf_ts" || ( echo "3dmaskave failed. Unable to extract CSF voxels. Check your mask! .wm_mask_noero${ext}" && exit 1 )
	    else
		rel "3dmaskave -mask .csf_mask${ext} -q ${func_ts}${ext} > .csf_ts" || ( echo "3dmaskave failed. Unable to extract CSF voxels. Check your mask! .csf_mask${ext}" && exit 1 )
	    fi

	    rel "1d_tool.py -overwrite -infile .csf_ts -derivative -write .csf_ts_deriv"

	    #cleanup some intermediate files
	    rel "imrm .csf_pve_thr0p8 .csf_pve_thr0p8_ero1 .csf_pve_clustsize .csf_pve_clustsize_noero"
	fi

	if [[ "$r" =~ ^(wm|dwm)$ && ! -f ".wm_ts" ]]; then
	    #fast segmentation should have been run during preprocessMprage
	    #use seg_2 for wm
	    #re-run FAST here if needed
	    [ $( imtest "${mprageBet_base}_fast_seg_2" ) -eq 0 ] && rel "fast -g -o \"${mprageBet_base}_fast\" \"${mprageBet_base}\""

	    warp_structmask_to_func "${mprageBet_base}_fast_pve_2" .wm_pve

	    #threshold at 0.8 to ensure that only voxels likely to be wm are retained	    
	    rel "fslmaths .wm_pve -thr 0.8 -bin .wm_pve_thr0p8"

	    #erode wm mask twice to reduce risk of partial WM voxels
	    #more contiguous wm voxels than csf voxels -- hence 2x dilation works well in general as a start to retain deep cerebral white matter
	    rel "3dmask_tool -overwrite -input .wm_pve_thr0p8${ext} -dilate_result -2 -prefix .wm_pve_thr0p8_ero2${ext}"

	    #cluster wm mask and only retain clusters of 15 or more contiguous voxels
	    rel "cluster -i .wm_pve_thr0p8_ero2 -t 1.0 --osize=.wm_pve_clustsize --no_table"
	    rel "fslmaths .wm_pve_clustsize -thr 15.01 -bin -mas ${postSS}_tmean_mask .wm_mask -odt char"
	    
	    #check that at least 100 voxels are present in mask to get a reasonable sampling distribution of WM timeseries
	    local nvox=$( 3dBrickStat -non-zero -count .wm_mask${ext} )

	    if [ $nvox -lt 50 ]; then
		#go back to a 1x erosion, but up voxel clusters to 50 minimum
		rel "Warning: fewer than 50 WM voxels were found in .wm_mask. Reverting to a 1x eroded WM mask" c
		rel "3dmask_tool -overwrite -input .wm_pve_thr0p8${ext} -dilate_result -1 -prefix .wm_pve_thr0p8_ero1${ext}"
		
		rel "cluster -i .wm_pve_thr0p8_ero1 -t 1.0 --osize=.wm_pve_clustsize_ero1 --no_table"
		rel "fslmaths .wm_pve_clustsize_ero1 -thr 50.01 -bin -mas ${postSS}_tmean_mask .wm_mask_ero1 -odt char"

		#obtain average WM timeseries from WM mask in functional space
		rel "3dmaskave -mask .wm_mask_ero1${ext} -q ${func_ts}${ext} > .wm_ts" || ( echo "3dmaskave failed. Unable to extract WM voxels. Check your mask! .wm_mask_ero1${ext}" && exit 1 )
	    else
		rel "3dmaskave -mask .wm_mask${ext} -q ${func_ts}${ext} > .wm_ts" || ( echo "3dmaskave failed. Unable to extract WM voxels. Check your mask! .wm_mask${ext}" && exit 1 )
	    fi    

	    rel "1d_tool.py -overwrite -infile .wm_ts -derivative -write .wm_ts_deriv"

	    #cleanup some intermediate files
	    rel "imrm .wm_pve_thr0p8 .wm_pve_thr0p8_ero2 .wm_pve_thr0p8_ero1 .wm_pve_clustsize .wm_pve_clustsize_noero_ero1"
	fi

	#global signal
	if [[ "$r" =~ ^(gs|dgs)$ && ! -f ".gs_ts" ]]; then
	    #erode the tight skull-stripped brain mask from the structural scan to identify brain voxels
	    rel "fslmaths ${mprageBet_base} -bin -eroF -eroF .brainmask_ero2x_anat -odt char" #eroding the binarized mprage_bet

	    warp_structmask_to_func .brainmask_ero2x_anat .brainmask_ero2x

	    rel "fslmaths .brainmask_ero2x -mas ${postSS}_tmean_mask .brainmask_ero2x -odt char" #mask by functional brain mask

	    rel "3dmaskave -mask .brainmask_ero2x${ext} -q ${func_ts}${ext} > .gs_ts"
	    rel "1d_tool.py -overwrite -infile .gs_ts -derivative -write .gs_ts_deriv"
	fi

	case "$r" in 
	    6motion)
		nuisancecols+=(".motion_demean[0]")
		nuisancecols+=(".motion_demean[1]")
		nuisancecols+=(".motion_demean[2]")
		nuisancecols+=(".motion_demean[3]")
		nuisancecols+=(".motion_demean[4]")
		nuisancecols+=(".motion_demean[5]")
		;;
	    rx)
		nuisancecols+=(".motion_demean[0]");;
	    ry)
		nuisancecols+=(".motion_demean[1]");;
	    rz)
		nuisancecols+=(".motion_demean[2]");;
	    tx)
		nuisancecols+=(".motion_demean[3]");;
	    ty)
		nuisancecols+=(".motion_demean[4]");;
	    tz)
		nuisancecols+=(".motion_demean[5]");;
	    d6motion)
		nuisancecols+=(".motion_deriv[0]")
		nuisancecols+=(".motion_deriv[1]")
		nuisancecols+=(".motion_deriv[2]")
		nuisancecols+=(".motion_deriv[3]")
		nuisancecols+=(".motion_deriv[4]")
		nuisancecols+=(".motion_deriv[5]")
		;;
	    drx)
		nuisancecols+=(".motion_deriv[0]");;
	    dry)
		nuisancecols+=(".motion_deriv[1]");;
	    drz)
		nuisancecols+=(".motion_deriv[2]");;
	    dtx)
		nuisancecols+=(".motion_deriv[3]");;
	    dty)
		nuisancecols+=(".motion_deriv[4]");;
	    dtz)
		nuisancecols+=(".motion_deriv[5]");;
	    wm)
		nuisancecols+=(".wm_ts");;
	    dwm)
		nuisancecols+=(".wm_ts_deriv");;
	    csf)
		nuisancecols+=(".csf_ts");;
	    dcsf)
		nuisancecols+=(".csf_ts_deriv");;
	    gs)
		nuisancecols+=(".gs_ts");;
	    dgs)
		nuisancecols+=(".gs_ts_deriv");;	    
	esac

    done

    rel "Creating ${nuisance_file} containing regressors as columns: ${nuisancecols[*]}" c
    rel "1dcat -overwrite ${nuisancecols[@]} > ${nuisance_file}"
    
}

function nuisance_regression {
    #handle nuisance regression and/or bandpass filtering
    [[ "$nuisance_compute" -eq 0 && "$nuisance_regression" -eq 0 && "$bandpass_filter" -eq 0 ]] && return 0 #no nuisance or bandpass, exit

    preNRBP="${prefix}${funcFile}${smoothing_suffix}${ext}"
    
    local todo=
    if [[ "$nuisance_regression" -eq 1 && "$bandpass_filter" -eq 1 ]]; then todo="br" #bandpass and regression
    elif [ "$nuisance_regression" -eq 1 ]; then todo="r" #regression only
    elif [ "$bandpass_filter" -eq 1 ]; then todo="b" #bandpass alone
    fi

    prefix="${todo}${prefix}"
    postNRBP="${prefix}${funcFile}${smoothing_suffix}${ext}"

    #check whether requisite steps are complete
    [[ -f .nuisance_regression_complete && $todo=r ]] && return 0
    [[ -f .bandpass_filter_complete && $todo=b ]] && return 0
    [[ -f .nuisance_regression_complete && -f .bandpass_filter_complete && $todo=br ]] && return 0

    if [[ ! -f "${nuisance_file}" && ( $nuisance_regression == 1 || $nuisance_compute == 1 ) ]]; then
	compute_nuisance_regressors
    fi

    #bandpass only
    if [ "$todo" = "b" ]; then
	rel "3dBandpass -input \"$preNRBP\" -mask \"${subjMask}${ext}\" \
		-prefix \"$postNRBP\" $bpLow $bpHigh"

	rel "date > .bandpass_filter_complete"
    elif [ "$todo" = "br" ]; then
        rel "3dBandpass -overwrite -input \"$preNRBP\" -mask \"${subjMask}${ext}\" \
		-prefix \"$postNRBP\" -ort ${nuisance_file} $bpLow $bpHigh"

	rel "date > .bandpass_filter_complete"
	rel "date > .nuisance_regression_complete"
    elif [ "$todo" = "r" ]; then
        rel "3dDetrend -overwrite -verb -polort 2 -vector ${nuisance_file} \
		-prefix \"$postNRBP\" \"$preNRBP\""
	
	#need to mask detrend by brain mask as with 3dBandpass
	rel "fslmaths \"$postNRBP\" -mas \"$subjMask\" \"$postNRBP\""
	rel "date > .nuisance_regression_complete"
    fi
    
    #explicit return code needed to avoid implicit status of prior command
    return 0

}
