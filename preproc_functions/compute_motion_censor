#!/bin/bash

function compute_motion_censor {
    #parse -censor_motion syntax

    [ -z "$motionCensor" ] && return 0

    [ -f .motion_censor_complete ] && return 0

    allmats=

    #just replace slashes with spaces so that IFS will capture properly
    OLDIFS="${IFS}"
    IFS='/' read -ra cens <<< "$motionCensor"
    for spec in "${cens[@]}"; do
	#echo "censor motion is $censorMotion"
	#censorMotion=$( echo $censorMotion | tr "/" " " )
	#for spec in ${censorMotion}; do
	if [[ $spec == *=* ]]; then
	    #has equals sign
	    metric=${spec/=*/} #before the equals
	    thresh=${spec/*=/} #after the equals
	    outbase="${metric}_${thresh}"
	else 
	    #do not pass --thresh
	    metric=${spec}
	    thresh=
	    outbase="${metric}_pct75_1p5IQR"
	fi

	matname="motion_info/${outbase}.mat"
	imgname="-p motion_info/${metric}.png"
	metname="-s motion_info/${metric}.txt"

	#force lower case
	metric=$( echo $metric | awk '{print tolower($0)}' )

	case "$metric" in 
	    dvars|fd|refrms|refmse|fdrms) 
		metric="--${metric}" #add double hyphen for compatibility with fsl_motion_outliers
		[ -n "$thresh" ] && thresh="--thresh=${thresh}" #format for fsl_motion_outliers

		local intensMask=
		local inImg="${funcFile}" #image to pass to fsl_motion_outliers

		if [[ $metric =~ refrms|refmse|dvars ]]; then

		    if [ $despike -eq 1 ]; then
			inImg="${postDespike}" #compute intensity differences after despiking
		    else
			inImg="${postMC}" #intensity differences after motion correction (so that mask applies)
		    fi
		    [ $( imtest "mot_intens_mask" ) -eq 0 ] && rel "fslmaths \"${threshMask}\" -eroF -eroF -eroF mot_intens_mask -odt char"
		    intensMask="-m mot_intens_mask --nomoco" #don't run motion correction for intensity metrics (because they are run on post-mc data)
		fi

		rel "fsl_motion_outliers -i \"${inImg}\" -o \"$matname\" $metric $thresh $imgname $metname $intensMask";;
	    relrms)
		#relative rms movement (mm) from rmsdiff of movement parameters (displacement)
		if [ ! -f motion_info/motion_relrms_mm ]; then
		    echo "Cannot find motion_info/motion_relrms_mm to generate motion censor file"
		else
		    [ -z "$thresh" ] &&	thresh=$( Rscript -e "relrms <- read.table('motion_info/motion_relrms_mm')\$V1; cat(quantile(relrms, 0.75) + 1.5*IQR(relrms))" )
		    
		    local rcmd1="relrms <- read.table('motion_info/motion_relrms_mm')\$V1;"
		    local rcmd2="censormat=do.call(cbind, sapply(1:length(relrms), function(x) { if (abs(relrms[x]) > $thresh) {"
		    local rcmd3="v <- rep(0, length(relrms)); v[x] <- 1; v } else { NULL } }));"
		    local rcmd4="if (!is.null(censormat)) { write.table(censormat, file='$matname', col.names=FALSE, row.names=FALSE) }"
		    local rcmd="$rcmd1 $rcmd2 $rcmd3 $rcmd4" 

		    Rscript -e "$rcmd"
		fi
		;;
            *)
		echo "Unsupported metric to fsl_motion_outliers: $metric" && exit 1;;
	esac

	#only add matrix to set if it exists (i.e., if some volumes exceeded threshold)
	[ -f "${matname}" ] && allmats="${allmats} ${matname}" #list of output matrices

    done
    IFS="${OLDIFS}"

    #Convert matrices to AFNI -censor style (see 3dDeconvolve)
    #In AFNI censor, 1 represents good, 0 represents bad.
    #But spike regressors are the opposite (1 where there is a bad volume)

    local allcensor=
    if [ -n "$allmats" ]; then
	#at least one censor mat was created above
	for f in ${allmats}; do
	    fcensor=${f/.mat/_censor.1D}
	    rel "awk '{for ( i=1 ; i<=NF ; i++ ) t+=\$i; print 1 - t; t=0}' $f > $fcensor"
	    allcensor="${allcensor} $fcensor"
	done
    else
	#no censoring needed at these thresholds. create vector of 1s to indicate all good.
	#Rscript with newline or tab blows up (some sort of bug). Workaround using writeLines
	#Rscript -e "x <- read.table(\"${metname/#-s /}\", header=FALSE)\$V1; writeLines(rep(\"1\", length(x)), con='motion_info/allcgood')"
	awk '{print 1}' ${metname/#-s /} > motion_info/allcgood #easier in awk
	allcensor=motion_info/allcgood
    fi

    paste $allcensor > motion_info/allcensor_wide.1D
    rel "Making union and intersection files of all motion censoring criteria." c
    #awk call checks whether the sum across the row is equal to the number of columns (indicating all 1=good)
    rel "awk '{ for ( i=1 ; i<=NF ; i++ ) { t+=\$i } if ( t == NF ) { print 1 } else { print 0 }; t=0 }' motion_info/allcensor_wide.1D > motion_info/censor_union.1D"
    rel "awk '{ for ( i=1 ; i<=NF ; i++ ) { t+=\$i } if ( t == 0 ) { print 0 } else { print 1 }; t=0 }' motion_info/allcensor_wide.1D > motion_info/censor_intersection.1D"
    rm -f motion_info/allcensor_wide.1D
    [ -f motion_info/allcgood ] && rm -f motion_info/allcgood

    #make a spike regression censor_union.mat file. Need to drop any duplicate spike regressors (if metrics flag same volumes) before writing to disk.
    if [ -n "$allmats" ]; then
	paste $allmats > motion_info/allmats_wide.1D
	local rcmd1="allc <- read.table(\"motion_info/allmats_wide.1D\"); rbad <- which(rowSums(allc) > 1); if (length(rbad) > 0L) { "
	local rcmd2="cdrop <- unlist(sapply(rbad, function(r) { which(allc[r,] == 1)[-1L] })); allc <- allc[,-1*cdrop] }; "
	local rcmd3="write.table(allc, file=\"motion_info/censor_union.mat\", row.names=FALSE, col.names=FALSE)"
	
	Rscript -e "$rcmd1 $rcmd2 $rcmd3"

	rm -f motion_info/allmats_wide.1D

	#use censor_intersection.1D to generate corresponding .mat file.
	local rcmd1="allc <- read.table(\"motion_info/censor_intersection.1D\")\$V1; badVols <- which(allc == 0); if (length(badVols) > 0L) { "
	local rcmd2="intmat <- matrix(0, nrow=length(allc), ncol=length(badVols)); for (v in 1:length(badVols)) { intmat[badVols[v], v] <- 1 }; "
	local rcmd3="write.table(intmat, file=\"motion_info/censor_intersection.mat\", row.names=FALSE, col.names=FALSE) } else { system(\"touch motion_info/censor_intersection.mat\") }"

	Rscript -e "$rcmd1 $rcmd2 $rcmd3"

    else
	touch motion_info/censor_union.mat #no censoring needed. create empty file
    fi

    date > .motion_censor_complete

    return 0
}
