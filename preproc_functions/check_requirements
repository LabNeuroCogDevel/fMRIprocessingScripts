#!/bin/bash

function check_requirements {
    #preliminary checks for required files and settings

    #dcm2niix is preferred for SE TOPUP correction because Dimon seems to lose important header information that
    #results in the fieldmap behaving strangely between TOPUP, flirt -fieldmap, and fugue. This appears to be largely resolved
    #by using fslreorient2std on input images to achieve LPI/RPI before applying fieldmaps.
    command -v dcm2niix >/dev/null 2>&1 && have_dcm2niix=1 || have_dcm2niix=0

    #ANTS is quite good at coregistration (better than flirt in many cases) and will be increasingly preferred in the pipeline
    #c3d provides a tool for transforming an ANTS matrix (itk) to FSL-compatible.mat
    command -v antsRegistrationSyN.sh >/dev/null 2>&1 && have_ants=1 || have_ants=0
    command -v c3d_affine_tool >/dev/null 2>&1 && have_c3d=1 || have_c3d=0
        
    #use the saved slice order from dicom_to_nifti conversion
    if [ -f .detect_sliceorder ]; then
	if [ -n "$sliceAcquisition" ]; then
	    rel "Ignoring user setting for slice acquisition: ${sliceAcquisition} because of auto-detected order in .detect_sliceorder." c
	fi
	
	read sliceAcquisition < .detect_sliceorder
    fi

    if [ -f .detect_tr ]; then
	if [ -n "$tr" ]; then
	    rel "Ignoring user setting for -tr: ${tr} because of auto-detected TR in .detect_tr." c
	fi

	read tr < .detect_tr
    fi

    if [ -f .detect_te ]; then
	if [ -n "$epiTE" ]; then
	    rel "Ignoring user setting for -epi_te: ${epiTE} because of auto-detected TE in .detect_te." c
	fi

	read epiTE < .detect_te
    fi
  
    #use the saved series number and protocol name for epiref detection
    if [ -f .detect_series ]; then
	read series < .detect_series
    fi

    if [ -f .detect_protocolname ]; then
	read protocolname < .detect_protocolname
    fi

    #use detected epiref image to override directory, if specified
    if [ -f .detect_epiref ]; then
	read funcRefimg  < .detect_epiref
    fi
    
    
    #check that slice acquisition order and TR was specified or detected in case of 4d input
    if [ -n "$funcFile" ]; then
	if [[ -z $sliceAcquisition && $no_st -eq 0 && -z $sliceTimesFile ]]; then #only enforce provision of slice acquisition order if slice timing in pipeline.
	    echo -e "Slice acquisition order was not specified and not detected.\nPass using the -slice_acquisition parameter.\nExiting.\n"
	    exit 1
	fi

	if [ -z $tr ]; then
	    echo -e "TR was not specified and not detected.\nPass using the -tr parameter.\nExiting.\n"
	    exit 1
	fi

	#check number of slices
	#if DICOMs used, num slices will be picked up by preproc_functions/dicom_to_nifti
	detectSliceNum=$( fslhd ${funcFile}  | grep '^dim3' | perl -pe 's/dim3\s+(\d+)/\1/' )

    fi

    if [ -n "$funcRefimg" ]; then
	if [[ -d "$funcRefimg" && ! -r .epiref_bet_complete ]]; then
	    #if -funcRefImg is a directory, assume that this is the raw directory for the subject and we should detect the reference	    
	    #look for dicom in previous and following series
	    if [ -z "$series" ]; then
		echo "series variable not set, but -func_refimg detect specified. Cannot determine how to search for SBref"
		exit 1
	    fi

	    if [ -z "$protocolname" ]; then
		echo "protocolname variable not set, but -func_refimg detect specified. Cannot determine how to search for SBref"
		exit 1
	    fi
	    
	    #find first file matching the dicom pattern in subfolders of the directory
	    local rawdir=$funcRefimg
	    local sbrefFound=0
	    while IFS= read -r -d '' dir; do
		#echo "find '$dir' -iname '$dicomPattern' -type f -print -quit"
		firstDicom=$( find "$dir" -iname "$dicomPattern" -type f -print -quit )
		#echo "dcm: $firstDicom"
		
		if [ -n "${firstDicom}" ]; then #check the number of characters in the string
		    local cDicom=$( dicom_hdr -sexinfo "${firstDicom}" )
		    local cProtocol=$( echo "${cDicom}" | grep -i "ACQ Protocol Name" | perl -pe "s:.*ACQ Protocol Name//(\w+).*$:\1:" )
		    local cSeries=$( echo "${cDicom}" | grep "REL Series Number//" | perl -pe 's|^.*REL Series Number//(\d+).*$|\1|' ) #series number

		    echo "${cDicom}" | grep -q "REL Image Comments//Single-band reference" && local cSbref=1 || local cSbref=0
		    
		    #echo "cprotocol: $cProtocol, cSeries: $cSeries, issbref: $cSbref, series to match: $series, proto to match: $protocolname"
		    if [[ "$cProtocol" == "$protocolname" && ( $cSeries == $(( series - 1)) || $cSeries == $(( series + 1)) ) && $cSbref == 1 ]]; then
			sbrefFound=1
			funcRefimg="${firstDicom}"
			echo "${firstDicom}" > .detect_epiref
			rel "  Detected SBref image -func_refimg: ${funcRefimg}" c
			break
		    fi
		fi
	    done < <(find $rawdir -mindepth 1 -maxdepth 1 -type d -print0)

	    if [ $sbrefFound -eq 0 ]; then
		rel "Unable to detect -func_refimg in $rawdir. Cannot continue." c
		exit 1
	    fi
	fi
	
	if [[ ! -f "$funcRefimg" ]] && [[ ! -h "${funcRefimg}" ]]; then
	    echo -e "Functional reference scan (-func_refimg) specified but not found: ${funcRefimg}.\nExiting.\n"
	    exit 1
	fi

	if [ -n "$ref_vol" ]; then
	    echo "-ref_vol and -func_refimg specified. Ignoring -ref_vol and using -func_refimg $funcRefimg."
	    ref_vol=
	fi

	if [ ! -r .epiref_bet_complete ]; then
    	    #copy reference image to local directory to make directory more portable
	    #if funcRefimg is a single DICOM file, change to NIfTI
	    dicom_hdr "$funcRefimg" 2>&1 | grep -q "ERROR: can't open.*as a DICOM file" && isdicom=0 || isdicom=1 # 0 exit status from grep indicates a match
	    
	    if [ $isdicom -eq 1 ]; then
		rel "Converting -func_refimg to NIfTI" c
		if [ $have_dcm2niix -eq 1 ]; then
		    [ -r epiref.nii.gz ] && rm -f epiref.nii.gz
		    dcm2niix -z y -f epiref -o ./ $( dirname "${funcRefimg}" )
		else
		    rel "Using to3d to convert epiref to NIfTI. Warning: this will occasionally result in inconsistent unwarping behavior due to bad image headers. Prefer dcm2niix!" c
		    rel "to3d -overwrite -prefix epiref.nii.gz -ushort2float \"$funcRefimg\""
		fi
	    else
		#copy reference image to local directory to make directory more portable
		rel "fslmaths \"$funcRefimg\" epiref"
	    fi

	    rel "fslreorient2std epiref epiref" #reorient epiref to LPI/RPI. Crucial to getting fieldmap orientation and behavior consistent
	    
	    #skull strip reference image to improve coregistration
	    #rel "bet epiref epiref_brain -f 0.3 -n -R" #include bias field correction given heavy bias for 32-channel data
	    rel "3dSkullStrip -overwrite -input epiref${ext} -prefix epiref_brain${ext} -orig_vol"
	    rel "fast -o epiref_brain -l 20 -b -B -t 2 --iter=12 --nopve --fixed=0 epiref_brain"
	    rel "imrm epiref_brain_seg" #not needed for anything
	    #use epiref_brain_restore for coregistration
	    qa_image epiref_brain epiref "epiref_skullstrip.png" "Skull-stripped epiref overlaid with original epiref"
	    
	    rel "date > .epiref_bet_complete"
	fi
    fi
    
    #if no warp and ICA-AROMA are both requested, we must compute the warp to MNI to have the script work properly
    if [[ $no_warp -eq 1 && $ica_aroma -eq 1 ]]; then
	compute_warp=1
    fi

    #if no smooth and ICA-AROMA are both requested, we need to compute AROMA on smoothed data (increases SNR) and then apply component regressions onto unsmoothed data.
    #Undo smooth will remove the 's' at the beginning of the file prefix and run fsl_regfilt on unsmoothed data
    if [[ $no_smooth -eq 1 && $ica_aroma -eq 1 ]]; then
  	undo_smooth=1
  	no_smooth=0
    else
  	undo_smooth=0
    fi

    #####
    #High-pass filtering for slow-frequency scanner drift
    #-bptf 60 -1: high-pass filter with FWHM = 60 volumes (e.g., so filter slower than about 141 volumes)
    #             -1 indicates don't low-pass filter
    #NB. The -bptf specification is in terms of sigma (width of Gaussian). As a result, this is the HWHM, not FWHM.
    #Details: https://www.jiscmail.ac.uk/cgi-bin/webadmin?A2=ind1109&L=fsl&D=0&P=202555
    #To achieve the desired cutoff, we need to compute the number of volumes as follows:
    #  sigma[vol] = cutoff[sec]/(2.355*TR[sec])
    # where 2.355 is the FWHM -> Sigma conversion

    #allow for seconds to be passed in, then converted to volumes
    if [ $no_hp -eq 0 ]; then
	if [ "${hpFilter: -1}" == "s" ]; then
	    rel "High pass filter specified in seconds: $hpFilter. Dividing by 2.355*${tr} (TR) for fslmaths -bptf" c
	    hpFilter=$( echo "scale=4; ${hpFilter%?}/(2.355*${tr})" | bc )
	else
	    rel "Dividing -hp_filter argument $hpFilter (in volumes) by 2.355 for FWHM argument to fslmaths -bptf." c	    
	    hpFilter=$( echo "scale=4; ${hpFilter}/2.355" | bc )
	fi
    fi
    
    #check for existence of required files
    #mprageBet and warpCoef only required if warping to a standard template (or just computing via -compute_warp_only).
    #Thus, don't require for pure -no_warp runs.
    if [[ $no_warp -eq 0 && $compute_warp -eq 0 ]]; then
	if [ -z $mprageBet ]; then
	    echo -e "Betted mprage file parameter not provided.\nPass using the -mprage_bet parameter.\nExiting.\n"
	    exit 1
	elif [[ ! -f $mprageBet ]] && [[ ! -h ${mprageBet} ]]; then
	    echo -e "Betted mprage file: $mprageBet does not exist.\nExiting.\n"
	    exit 1
	else
	    #make mprage into an absolute path and symlink within the current directory
	    cd "$(dirname $mprageBet)"
	    mprageBet="$(pwd)/$(basename $mprageBet)"
	    cd - 1>/dev/null
	    # do not link if mprage is in the directory already #WF for MJ 20150424
	    [ ! -r "./$(basename $mprageBet)" ] && \
	      ln -sfn "$mprageBet" "./$(basename $mprageBet)"
	fi

	
	if [ -z $warpCoef ]; then
	    echo -e "Structural to standard space warp coefficients file (from FNIRT) not provided.\nPass using the -warpcoef parameter.\nExiting.\n"
	    exit 1
	elif [[ ! -f $warpCoef ]] && [[ ! -h ${warpCoef} ]]; then
	    echo "Structural to standard space warp coefficients file does not exist.\nFile specified: $warpCoef.\nExiting.\n"
	    exit 1
	fi
    fi

    #explicit return code needed to avoid implicit status of prior command
    return 0

}
# vim: set tabstop=7:
