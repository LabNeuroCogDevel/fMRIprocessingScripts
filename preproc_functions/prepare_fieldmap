#!/bin/bash

#if [ $cleanup -eq 1 ]; then savetemps=no; pics=no;
#else savetemps=yes; pics=yes;
#fi

# need a few functions not stored here
# this is sourced in ../preprocessFunctional. but again here just to be safe
for needfunc in waitforlock prepare_gre_fieldmap prepare_mc_target prepare_se_fieldmap; do
   [ "$(type -t $needfunc)" == "function" ] && continue
   filetosource="$(dirname ${BASH_SOURCE[0]})/$needfunc"
   [ ! -r "$filetosource" ] && echo "$BASH_SORUCE: need function $needfunc, not in '$filetosource'; not running" >&2 && return 1
   source "$filetosource"
done


#function to reset a fieldmap phase directory to its original state (DICOMs only)
#useful to fix/startover on fieldmap preparation
function reset_phasedir {
    local phasedir="${1}"
    cwd=$(pwd)
    rel "Resetting field map phase directory: $phasedir" c
    [ ! -d "$phasedir" ] && rel "Cannot find phase directory to reset: $phasedir" c && return 0
    cd "$phasedir"

    flist=".fieldmap_phase .fmphase_inprogress fm_phase.nii.gz fm_phase_radians.nii.gz fm_phase_radians_unwrapped.nii.gz fm_phase_rps.nii.gz FM_UD_fmap.nii.gz"
    if [ -f fm_phase_dicom.tar.gz ]; then	
	rel "tar xvzf fm_phase_dicom.tar.gz && rm -f fm_phase_dicom.tar.gz"
	rel "rm -f $flist"
    else
	rel "Could not locate dicom archive. In an abundance of caution, moving phase files to phase_archive folder" c
	local tomove=
	for fname in $flist; do
	    [ -f $fname ] && tomove="$tomove $fname"
	done

	if [ -n "$tomove" ]; then
     	    [ ! -d "phase_archive" ] && rel "mkdir phase_archive"
	    rel "mv $tomove phase_archive"
	fi
    fi

    cd "$cwd" #return to original directory
}

function reset_magdir {
    local magdir="$(abspath ${1})"
    
    cwd=$(pwd)
    rel "Resetting fieldmap magnitude directory: $magdir" c
    [ ! -d "$magdir" ] && rel "Cannot find magnitude directory to reset: $magdir" c && return 0
    cd "$magdir"

    rel "rm -f .fieldmap_magnitude .fmmagnitude_inprogress"
    
    if [ -d "echo1" ]; then
	cd echo1
	rel "rm -f fm_magnitude_echo1.nii.gz"
	if [ -f fm_magnitude_echo1_dicom.tar.gz ]; then
	    rel "mkdir dicom_temp"
	    rel "tar xvzf fm_magnitude_echo1_dicom.tar.gz -C dicom_temp"
	    rel "mv dicom_temp/* $magdir"
	    rel "rmdir dicom_temp"
	    rel "rm -f fm_magnitude_echo1_dicom.tar.gz"
	fi

	cd ../
	rel "rmdir echo1"
    fi
    
    if [ -d "echo2" ]; then
	cd echo2
	rel "rm -f fm_magnitude_echo2.nii.gz"
	if [ -f fm_magnitude_echo2_dicom.tar.gz ]; then
	    rel "mkdir dicom_temp"
	    rel "tar xvzf fm_magnitude_echo2_dicom.tar.gz -C dicom_temp "
	    rel "mv dicom_temp/* $magdir"
	    rel "rmdir dicom_temp"
	    rel "rm -f fm_magnitude_echo2_dicom.tar.gz"
	fi
	
	cd ../
	rel "rmdir echo2"
    fi
}

PREPARE_FIELDMAP_GLOBALS=(bbrCapable funcStructFlirtDOF fm_cfg mcMats fm_phase fm_magnitude ext logFile mprageBet qa_imgdir )
# bbrfmap from 'register_func2struct', but expected to be called after prepare_fieldmap. we probably want this to be empty

### Worker function for preparation of fieldmap.
# Steps:
# 1)  Source fm_cfg file to define relevant fieldmap details (e.g., TEdiff)
# 2)  Check for required files and variables
# 3)  Reorient fieldmap and magnitude to same orientation as template (RPI/LPI) so that EPI and FM are similarly oriented
# 4)  Convert fieldmap to radians per second
# 5)  Create brain mask for fieldmap based on magnitude image
# 6)  Despike edges of fieldmap (to avoid extreme voxel shifts due to rapid transitions at edge of fieldmap)
# 7)  De-median the fieldmap
# 8)  Create png image of fieldmap + magnitude
# 9)  Generate signal loss estimate (sigloss) based on fieldmap, then generate distorted fieldmap images to match EPI distortion (forward warp)
# 10) Create png of sigloss overlaid on magnitude
# 11) Align magnitude image with EPI to generate fieldmap
# 12) Undistort target functional (mc_target) based on EPI-aligned fieldmap, and generate voxel shift map
# 13) Generate image of shift map overlaid on fieldmap magnitude image
function prepare_fieldmap {
  
    [ -f .prepare_fieldmap_complete ] && rel "fieldmap completed already" c &&  return 0

    print_vars_in PREPARE_FIELDMAP_GLOBALS
    # FM = space of fieldmap
    # EF = space of mc_target
    # UD = undistorted (in any space)
    # D  = distorted (in any space)

    # if we have none of the fieldmap/distortion correction variables, we dont need to do anything
    [ -z "$fm_phase$fm_magnitude$fm_cfg$se_phaspos$se_phaseneg" ] && rel "not running fieldmap" c && return 0

    if [[ $bbrCapable -eq 1 && $funcStructFlirtDOF = "bbr" && -n "$fm_cfg" ]]; then
	createBBRFmapWarp=1 #generate func -> struct warp that includes FM unwarping (via BBR -fieldmap)
    else
	createBBRFmapWarp=0
    fi

    prepare_mc_target 
    # Make an unwarp temps working directory
    tempsdir=$(pwd)/unwarptemps
    [ -d $tempsdir ] && rm -r $tempsdir
    mkdir $tempsdir

    # we need to do this before testing if complete
    # because we use the warpdir sourced from the file
    # later (one-step warp)
    [ -n "$fm_cfg" ] && { find_and_source_fmconfig "$fm_cfg" || return 1; }
    
    if [[ ( -n "${fm_phase}" || -n "$se_phasepos" || -n "$distortion_dir" ) && -f ".prepare_fieldmap_complete" ]]; then
	return 0 #preparefieldmap already completed
    elif [ -n "$DISTORTION_DIR" ]; then
       prepare_distortion_dir "$DISTORTION_DIR"
    elif [ -n "$fm_phase" ]; then
	prepare_gre_fieldmap #setup fieldmap files using GRE
    elif [ -n "$se_phasepos$se_phaseneg" ]; then
	prepare_se_fieldmap #setup fieldmap files using SE + TOPUP
    fi

    #handle rare case where PE dir needs to be flipped for fieldmap processing after TOPUP step
    if [ -n "$flip_topup_pedir" ] && [ "$flip_topup_pedir" -eq 1 ]; then
	case $unwarpdir in
	    x)     unwarpdir=-x  ;;
	    -x|x-) unwarpdir=x ;;
	    y)     unwarpdir=-y  ;;
	    -y|y-) unwarpdir=y ;; 
	    z)     unwarpdir=-z  ;;
	    -z|z-) unwarpdir=z ;;
	    *)     echo "$FUNCNAME Unable to determine unwarping direction from '$unwarpdir'"
		   exit 1 ;;
	esac
    fi
	
    preproc_fieldmap #refine fieldmap and align to functional and structural images

    rel "date > .prepare_fieldmap_complete"

    #explicit return code needed to avoid implicit status of prior command
    return 0
}


# make unwarp dir in current working directory, using DISTORTION_DIR
# if unwarp and distortion_dir are the same, dont do anything
prepare_distortion_dir() {
  local DISTORTION_DIR="$1"
  [ -z "$DISTORTION_DIR" ] && echo "$FUNCNAME: bad usage. need DISTORTION_DIR" >&2 && return 1
  [ ! -d "$DISTORTION_DIR" ] && echo "distortion_dir ('$DISTORTION_DIR') is not a directory!" >&2 && return 1

  # we only have to do stuff if DISTORTION_DIR is not in this directory
  if [[ "$(abspath unwarp)" != "$(abspath $DISTORTION_DIR)" ]]; then
   if [ -d unwarp ]; then
    rel "already have unwarp but we are rerunning preprocessFunctional, so we're replacing it with $DISTORTION_DIR" c
    rel "rm -r unwarp"
   fi
   rel "cp -r $DISTORTION_DIR unwarp"
  else
    rel "fieldmap DISTORTION_DIR ('$DISTORTION_DIR') is within this functional as 'unwarp' run, re-using" c
  fi
  cd unwarp
  return 0
}


#preprocess fieldmap by creating masks, warping to structural, etc.
#largely based on FSL epi_reg script
function preproc_fieldmap {

    #Apr2014: When phase encoding is in the X direction, there is a disjunction between the unwarpdir for FUGUE versus convertwarp and flirt -bbr -pedir.
    #Corresponded with Mark Jenkinson and he acknowledged the bug. This workaround assumes that the direction in the cfg file gives proper results for
    #convertwarp and flirt -bbr -pedir, but that the direction needs to be reversed for FUGUE. This workaround pertains to some CogEmo data using 
    #the Northwestern OFC and my K01 pilot data.
    if [ "$unwarpdir" = x ]; then
	rel "Reversing phase encode direction for use in FUGUE. convertwarp and flirt -pedir will use x, whereas FUGUE will use x-" c
	fugue_unwarpdir=x-
    elif [ "$unwarpdir" = x- ]; then
	rel "Reversing phase encode direction for use in FUGUE. convertwarp and flirt -pedir will use x-, whereas FUGUE will use x" c
	fugue_unwarpdir=x
    else
	fugue_unwarpdir=$unwarpdir
    fi

    #assume that we have a) copied FM_UD_fmap_mag and FM_UD_fmap into unwarp directory and b) have cd'd into that directory
    #skull strip magnitude image for registration
    rel "bet FM_UD_fmap_mag          FM_UD_fmap_mag_brain -R"
    [ -n "$funcRefimg" ] &&     rel "fslmaths ../epiref_brain_restore      ER_D_epiref"
    rel "fslmaths ../mc_target_brain_restore                EF_D_mc_target"
    
    #change image orientation to LPI/RPI to match EPI (ease registration)
    #N.B. This needs to be run on the local copies, not in $fm_phasedir to avoid file collisions during parallel runs of preprocessFunctional
    rel "fslreorient2std FM_UD_fmap FM_UD_fmap"
    rel "fslreorient2std FM_UD_fmap_mag FM_UD_fmap_mag"
    rel "fslreorient2std FM_UD_fmap_mag_brain FM_UD_fmap_mag_brain"

    globalcount=-1 #use global count of -1 since these are not steps per se, just initial snapshots
    _picture EF_D_mc_target       "Initial"; globalcount=-1
    _picture FM_UD_fmap           "Initial"; globalcount=-1 
    _picture FM_UD_fmap_mag       "Initial"; globalcount=-1
    _picture FM_UD_fmap_mag_brain "Initial (copy of FM mag)"; 

    # creates EF_D_mc_target.nii  FM_UD_fmap_mag.nii   FM_UD_fmap.nii

    ### STEP 2: Create and refine mask for fieldmap based on magnitude image.
    rel "Creating masks" c

    # Create a binary mask of the non-zero voxels of the fieldmap magnitude image (which was skull-stripped above)
    rel "fslmaths FM_UD_fmap_mag_brain -bin FM_UD_fmap_mag_brain_mask -odt short"

    #the steps below (up through re-creation of FM_UD_fmap_mag_brain_mask) appear to try to handle the case where
    #either the fmap_rads or fmap_mag images have already been masked elsewhere, and we want to recreate a reasonable mask.

    # abs the original fieldmap, binarize, then mask based on the 1/0 magnitude image, invert by *-1, + 1, binarize (to be safe).
    # The result, FM_UD_fmap_mag_brain_mask_inv, is the non-zero voxels of the *fieldmap* (not magnitude) inverted such that
    # brain-ish voxels are 0 and non-brain voxels are 1.
    # This may lead to a circumstance where there are brain voxels of interest that have value 0 in the fieldmap. (patchy holes)
    rel "fslmaths FM_UD_fmap -abs -bin -mas FM_UD_fmap_mag_brain_mask -mul -1 -add 1 -bin FM_UD_fmap_mag_brain_mask_inv"

    _picture FM_UD_fmap_mag_brain_mask "binary mask of skullstripped fmap_mag "
    _picture FM_UD_fmap_mag_brain_mask_inv "non brain regions"

    # To handle the above scenario of 0-valued voxels in fieldmap, use cluster to obtain the largest cluster of non-zero
    # (non-brain) voxels in the above mask. The output of cluster is an integer-valued image with masks for each spatial cluster
    rel "cluster -i FM_UD_fmap_mag_brain_mask_inv -t 0.5 --no_table -o FM_UD_fmap_mag_brain_mask_idx"

    # This will grab the largest spatial cluster (the max of the range, -R), which refers to the biggest non-brain cluster
    outsideIdx=$(fslstats FM_UD_fmap_mag_brain_mask_idx -R | awk '{print  $2}')

    # Now take the clusters image, zero everything below the max (where max contains the biggest non-brain cluster),
    # binarize the image, re-invert (*-1 + 1), binarize again, then mask by the skull-stripped magnitude image.
    # Overwrite the fieldmap magnitude brain mask with the result, which reflects the largest non-zero cluster
    rel "fslmaths FM_UD_fmap_mag_brain_mask_idx -thr $outsideIdx -bin -mul -1 -add 1 -bin -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap_mag_brain_mask"

    _picture FM_UD_fmap_mag_brain_mask_inv "non brain regions, clustered"
    _picture FM_UD_fmap_mag_brain_mask "new brain_mask (inverted biggest nonbrain region masked by old self)"

    ### Refine Mask
    rel "Refining masks to remove edge voxels where signal is poor" c
    ## De-median the fieldmap (to avoid gross shifting)
    # compute median of non-zero voxels in fieldmap, masking by the useful voxels (from mask steps above)
    medVal=$(fslstats FM_UD_fmap -k FM_UD_fmap_mag_brain_mask -P 50 | sed 's/ //g') # 112.242508

    # subtract off the median from all fieldmap voxels within the relevant mask, then overwrite fmap
    rel "fslmaths FM_UD_fmap -sub $medVal -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap"

    # From skull-stripped magnitude image, compute 98th pctile of nonzero voxels, divide by 2
    almostHalfMax=$(fslstats FM_UD_fmap_mag_brain -P 98 | awk '{print $1/2.0}') # 563.5

    # Zero all non-zero voxels in the skull-stripped magnitude image that fall below half of 98th pctile
    # Many will be near the edge
    rel "fslmaths FM_UD_fmap_mag_brain -thr $almostHalfMax -bin FM_UD_fmap_mag_brain_mask50"

    # Erode once to shave off a layer of all edges
    rel "fslmaths FM_UD_fmap_mag_brain_mask -ero FM_UD_fmap_mag_brain_mask_ero"

    # Take the eroded magnitude mask and add back those voxels (wherever they are) that exceed the half-max (~50th pctile)
    # Then threshold those < 1 and binarize to make a magnitude mask.
    # In effect, this will bring back edge voxels lost by -ero that are > median (i.e., they have adequate signal and should be retained)
    rel "fslmaths FM_UD_fmap_mag_brain_mask_ero -add FM_UD_fmap_mag_brain_mask50 -thr 0.5 -bin FM_UD_fmap_mag_brain_mask"

    # Remove poor-quality edge voxels from the fieldmap using the the magnitude mask above (that dropped voxels < half max)
    rel "(Finally) applying the brain mask to the fieldmap image." c
    rel "fslmaths FM_UD_fmap -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap"

    # snap shots
    _picture FM_UD_fmap                    "overwrite by demedian-ing ( - $medVal, overwrite)"
    _picture FM_UD_fmap_mag_brain_mask50   "mag (masked) >$almostHalfMax (all high intensity)"
    _picture FM_UD_fmap_mag_brain_mask_ero "mag (masked) eroded"
    _picture FM_UD_fmap_mag_brain_mask     "eroded + high intensity (overwrite)"
    _picture FM_UD_fmap                    "remove low intenity (mask by brain_mask finally) (overwrite)"

    # [ -n "$savetemps" ] && fslmaths FM_UD_fmap FM_UD_fmap_preMedianFilter

    ### STEP 3: Despike edges of fieldmap
    rel "Despiking edges of fieldmap image" c

    # Erode the magnitude mask created above
    rel "fslmaths FM_UD_fmap_mag_brain_mask -ero FM_UD_fmap_mag_brain_mask_ero"

    #Apply 2D despiking filter, masking within the magnitude mask
    rel "fugue --loadfmap=FM_UD_fmap --savefmap=FM_UD_fmap_tmp_fmapfilt --mask=FM_UD_fmap_mag_brain_mask --despike --despikethreshold=2.1"

    #Smooth/despike voxels at the edge of the brain, leave everything else alone
    #How: take the unsmoothed fieldmap, which is masked by magnitude,
    #1) subtract despiked fieldmap (which is smoother) (-sub)
    #2) zero all voxels outside of the eroded magnitude mask (-mas)
    #3) add back despiked fieldmap -- this does 2 things:
    #      - retains original fmap within ero mask (since the -add and -sub sum to 0)
    #      - add despiked fmap outside of ero mask (where the -mas reset these voxels to 0)

    rel "fslmaths FM_UD_fmap -sub FM_UD_fmap_tmp_fmapfilt -mas FM_UD_fmap_mag_brain_mask_ero -add FM_UD_fmap_tmp_fmapfilt FM_UD_fmap"

    # snap shots
    _picture FM_UD_fmap_mag_brain_mask_ero "erode brain_mask again (regardless of intensity)"
    _picture FM_UD_fmap_tmp_fmapfilt       "2D demeaned,despiked FM"
    _picture FM_UD_fmap                    "sub self from demeaned, apply ero. mask, add back (overwrite)"

    #clean up
    mv FM_UD_fmap_tmp_fmapfilt* FM_UD_fmap_mag_brain_mask_ero* FM_UD_fmap_mag_brain_mask50* FM_UD_fmap_mag_brain_mask_i* $tempsdir

    ### STEP 4: Demedian fieldmap (again)
    medVal=$(fslstats FM_UD_fmap -k FM_UD_fmap_mag_brain_mask -P 50 | sed 's/ //g' ) # -0.623573

    rel "fslmaths FM_UD_fmap -sub $medVal -mas FM_UD_fmap_mag_brain_mask FM_UD_fmap"

    _picture FM_UD_fmap "demedian and mask ($medVal, again, overwrite)"

    ### STEP 5: image of fieldmap overlaid on magnitude image (fmap+mag.png)
    rel "Composing image of fieldmap and magnitude: fmap+mag.png" c
    # make lowest value 10: this prepares image for attractive thumbnail
    minVal=$(fslstats FM_UD_fmap -R | awk '{ print  $1}') #  -1383.077148 

    rel "fslmaths FM_UD_fmap -sub $minVal -add 10 -mas FM_UD_fmap_mag_brain_mask grot"

    _picture grot "FM_UD_fmap - $minVal + 10 (prepare for thumbnail)"

    # Determine the range of values above 1
    rangeAboveOne=$( fslstats grot -l 1 -p 0.1 -p 95 ) # 607.379578 1602.596313

    rel "overlay 0 0 FM_UD_fmap_mag -a grot $rangeAboveOne fmap+mag"

    # Generate slice images
    rel "slicer fmap+mag -s 3 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png \
	-y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png \
	-z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png"

    #pull these together
    rel "pngappend sla.png + slb.png + slc.png + sld.png - sle.png + slf.png + slg.png + slh.png - sli.png + slj.png + slk.png + sll.png ${qa_imgdir}/fmap+mag.png"
    rel "rm sl[a-l].png"

    ### STEP 6: Compute a signal loss (sigloss) estimate and make a siglossed magnitude image for forward warp
    rel "Compute signal loss estimate and apply to magnitude image for forward warp" c

    # get a sigloss estimate and make (-s) a siglossed estimate for forward warp
    # to be Distorted (ref (after *mag) and refweight in EF_2_FM warp) and warped to epi (sigloss+*png)
    rel "sigloss -i FM_UD_fmap --te=$epiTE -m FM_UD_fmap_mag_brain_mask -s FM_UD_fmap_sigloss"

    # make siglossed magnitude image for EPI -> fieldmap warp
    rel "fslmaths FM_UD_fmap_sigloss -mul FM_UD_fmap_mag_brain FM_UD_fmap_mag_brain_siglossed -odt float"

    _picture FM_UD_fmap_sigloss "FM_UD_fmap masked sigloss (te=$epiTE)"
    _picture FM_UD_fmap_mag_brain_siglossed "magnitude image with expected signal loss in EPI applied"

    # Distort mag_brain_siglossed and fmap_sigloss based on FD_UD_fmap.
    # This uses the "forward warp" of the fieldmap to distort the sigloss and magnitude images
    # to match EPI. These are then used for the sigloss+mag png file.
    rel "fugue -i FM_UD_fmap_mag_brain_siglossed \
           --loadfmap=FM_UD_fmap --mask=FM_UD_fmap_mag_brain_mask --dwell=$dwelltime \
           -w FM_D_fmap_mag_brain_siglossed --nokspace --unwarpdir=$fugue_unwarpdir"

    _picture FM_D_fmap_mag_brain_siglossed "undistorted to distorted ($fugue_unwarpdir), forward warp via FM_UD_fmap"

    rel "fugue -i FM_UD_fmap_sigloss \
           --loadfmap=FM_UD_fmap --mask=FM_UD_fmap_mag_brain_mask --dwell=$dwelltime \
           -w FM_D_fmap_sigloss --nokspace --unwarpdir=$fugue_unwarpdir"

    _picture FM_D_fmap_sigloss "undistorted to distorted ($fugue_unwarpdir), forward warp via FM_UD_fmap"

    # threshold by value set in cfg
    #The goal of thresholding based on signal loss is to remove EPI voxels where the signal loss
    #is greater than 90%, so there is little useful signal there, and what is there may
    #be highly distorted, which could detract from coregistration.
    rel "fslmaths FM_D_fmap_sigloss -thr $signallossthresh FM_D_fmap_sigloss" # .9

    _picture FM_D_fmap_sigloss "threshold by $signallossthresh (overwrite)"

    ### STEP 7: Generate image of signal loss overlaid onto magnitude image.
    rel "composing sigloss + magnitude image (FM_UD_sigloss+mag.png)" c

    # Note: this is consistent with FSL 5.0+, but starts to diverge from 4.1.9.
    # In FSL 5.0+, the sigloss+mag image is composed in the fieldmap space, as here. (trivial difference)
    rel "overlay 1 0 FM_UD_fmap_mag_brain -a FM_UD_fmap_sigloss 0 1 FM_UD_sigloss+mag"

    rel "slicer FM_UD_sigloss+mag -s 3 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png \
    -y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png \
    -z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png"

    rel "pngappend sla.png + slb.png + slc.png + sld.png - sle.png + slf.png + slg.png + slh.png - sli.png + slj.png + slk.png + sll.png ${qa_imgdir}/FM_UD_sigloss+mag.png"
    rel "rm sl[a-l].png"

    ##STEP 8. ALIGN MAGNITUDE WITH EPI
    # This begins to diverge from FSL 5.0+, where the magnitude and EPI are never explicitly aligned
    # In 5.0+, the thumbnail images are based on the func-to-struct warp using -fieldmap in BBR coregistration
    # The main goal here, however, is to make relevant images. We still do the -fieldmap in BBR coregistration downstream,
    # which then informs the func -> MNI warp and includes fieldmap unwarping, so we don't sacrifice any accuracy in the fmap -> EPI coregistration.
    # If user declines BBR (or FSL too old), the below is useful for volwise unwarping

    # align target epi (is distorted) to mag fieldmap (with distortion applied)
    # use distorted sigloss as a reference weight
    # mc_target is distorted and has falloff in high sigloss areas (darkening)
    # FM magnitude siglossed has been distorted and darkened similarly to improve coregistration
    # In addition, weight the "good" voxels (low sigloss) more in the registration cost function
    # Output grot is just used for creating thumbnails
    rel "Coregister fieldmap files into EPI space (mc_target)" c

    #use of refweight was leading to gross mis-registration in some subjects (esp. when fmap and epi did not have the same grid and voxel size).
    #the func_to_fmap.mat matrix is only used internally here, but does lead EF_D_mc_target and EF_UD_mc_target to look quite ugly.
    # -refweight FM_D_fmap_sigloss

    rel "flirt -in EF_D_mc_target -ref FM_D_fmap_mag_brain_siglossed -omat $funcdir/transforms/func_to_fmap.mat -o grot -dof 6"
    qa_image FM_D_fmap_mag_brain_siglossed grot func_to_fmap_mag_brain_siglossed.png "Distorted fm magnitude overlaid with distorted mc_target"
    
    if [ -n "$funcRefimg" ]; then
	rel "flirt -in ER_D_epiref -ref FM_D_fmap_mag_brain_siglossed -omat $funcdir/transforms/epiref_to_fmap.mat -o grot -dof 6"
	qa_image FM_D_fmap_mag_brain_siglossed grot epiref_to_fmap_mag_brain_siglossed.png "Distorted fm magnitude overlaid with distorted epiref"
    fi
	
    _picture grot "align FM (mag,sigloss in) to epi (ref) (make func_to_fmap.mat, use this image for thumbnail)"
   
    # reverse  EF->FM  to get FM->EF (to put all fieldmap stuff in epi space)
    rel "convert_xfm -omat $funcdir/transforms/fmap_to_epi.mat -inverse $funcdir/transforms/func_to_fmap.mat"
    [ -n "$funcRefimg" ] && rel "convert_xfm -omat $funcdir/transforms/fmap_to_ref.mat -inverse $funcdir/transforms/epiref_to_fmap.mat"

    # transform all the fieldmap images into EPI space (mc_target),  FM_UDs become EF_UDs
    for file in "FM_UD_fmap" "FM_UD_fmap_mag_brain" "FM_UD_fmap_mag_brain_mask" "FM_UD_fmap_sigloss"; do
	rel "flirt -in $file -ref EF_D_mc_target -init $funcdir/transforms/fmap_to_epi.mat -applyxfm -out ${file/FM_/EF_} -interp spline"
	#creates "EF_UD_fmap" "EF_UD_fmap_mag_brain" "EF_UD_fmap_mag_brain_mask" "EF_UD_fmap_sigloss"
	_picture ${file/FM_/EF_}  "align FM (mag,sigloss in) to epi (ref) (make func_to_fmap.mat)"
    done

    #threshold warped mask file to maintain same approximate size (alternative to nn interp)
    rel "fslmaths EF_UD_fmap_mag_brain_mask -thr 0.5 -bin EF_UD_fmap_mag_brain_mask -odt float"

    #also threshold sigloss image in EPI space
    rel "fslmaths EF_UD_fmap_sigloss -thr $signallossthresh EF_UD_fmap_sigloss -odt float"

    ##STEP 9. UNWARP TARGET EPI (mc_target)

    rel "Unwarp example func (undistort, shift)" c
    # epi: D -> UD (undistort mc_target)
    # unwarp EF_D_mc_target to EF_UD_mc_target (for thumbnail, compare to original, and in convertwarp to build applywarp)
    # and save unwarp-shiftmap then convert to unwarp warpfield
    # -u is unwarp 
    rel "fugue --loadfmap=EF_UD_fmap --dwell=$dwelltime --mask=EF_UD_fmap_mag_brain_mask -i EF_D_mc_target -u EF_UD_mc_target --unwarpdir=$fugue_unwarpdir --saveshift=EF_UD_shift"
    _picture EF_UD_shift "pixelshift ($fugue_unwarpdir)  EF_D_example using EF_UD_fmap"

    qa_image EF_UD_mc_target EF_D_mc_target undistort_mc_target.png "Undistorted mc_target overlaid with original mc_target"
    
    # Create warpfield file for undistorting EPI data based on shiftmap above
    # In FSL 4.1.9, this was used for the unwarping of functionals. In the new setup (consistent with 5.0+),
    # we get the warpfield from the BBR func2struct coregistration with -fieldmap.
    rel "convertwarp -s EF_UD_shift -o EF_UD_warp -r EF_D_mc_target --shiftdir=$unwarpdir --relout"
    _picture EF_UD_warp "warped ($unwarpdir, shift w/undistorted, shifted epi (with orig distored epi as ref)"

    ##STEP 10. Generate EPI voxel shift image thumbnail based on undistorted EPI
    rel "composing voxel shift map overlaid on fieldmap magnitude (EF_UD_shift+mag.png)" c
    # hack to to get variables (bash array of results from fslmatsh|awk)
    shiftExtrema=( $(fslstats EF_UD_shift -R -P 1 -P 99 | awk '{printf "%.1f %.1f %f %f", $1, $2, $3*-1, $4}'))
    #-9.9, 8.0, 3.999190, 4.090690
    shiftminR=${shiftExtrema[0]} # not used by image
    shiftmaxR=${shiftExtrema[1]} # not used by image
    shiftminr=${shiftExtrema[2]}
    shiftmaxr=${shiftExtrema[3]}

    rel "fslmaths EF_UD_shift -mul -1 grot"
    rel "overlay 1 0 EF_UD_fmap_mag_brain -a EF_UD_shift 0.0001 $shiftmaxr grot 0.0001 $shiftminr grot"
    rel "slicer grot -s 3 -x 0.35 sla.png -x 0.45 slb.png -x 0.55 slc.png -x 0.65 sld.png \
	-y 0.35 sle.png -y 0.45 slf.png -y 0.55 slg.png -y 0.65 slh.png \
	-z 0.35 sli.png -z 0.45 slj.png -z 0.55 slk.png -z 0.65 sll.png"

    rel "pngappend sla.png + slb.png + slc.png + sld.png - sle.png + slf.png + slg.png + slh.png - sli.png + slj.png + slk.png + sll.png ${qa_imgdir}/EF_UD_shift+mag.png"
    rel "rm sl[a-l].png"

    #TODO: Feat composes a few other images (animated GIFs) to show before and after.
    ## Skipping EF_D_mc_target.gif EF_UD_mc_target.gif EF_UD_fmap_mag_brain.gif
    ## for files in ^; do slicer &&  pngappend; done;  whirlgif

    #STEP 11. Coregister the fieldmap to the structural image for use in func2struct alignment with BBR cost function and -fieldmap
    #adapted from epi_reg
    rel "Coregister the fieldmap to the structural image for use in func2struct alignment with BBR cost function." c

    rel "flirt -in FM_UD_fmap_mag_brain -ref $mprageBet -dof 6 -omat $funcdir/transforms/fmap_to_struct.mat -out fmap_to_struct -interp spline" #magnitude to structural
    #note that epi_reg requests unbetted MPRAGE and runs an additional flirt on the unbetted magnitude and MPRAGE images.

    qa_image "$mprageBet" fmap_to_struct fmap_mag_to_struct.png "Structural image overlaid with 6dof-coregistered undistorted fmap mag"
    
    # 2017-08-07WF
    #  * added duplicated line for _fast_wmseg also created in register_func2struct             
    #  * removed bbrfmap from above. set by register_func2struct, which is run after this. 
    #    if bbrfmap is set, cause error (b/c e.g. unwarp/fmapForBBR.nii.gz DNE yet)
    #further testing indicates that BBR makes substantial improvements in (magnitude) -> struct coregistration for some subjects
    if [[ $bbrCapable -eq 1 && $funcStructFlirtDOF = "bbr" ]]; then
	local mprageBet_base=$( remove_ext ${mprageBet} ) #skull-stripped mprage image basename
	rel "immv fmap_to_struct fmap_to_struct_init"
	rel "mv $funcdir/transforms/fmap_to_struct.mat $funcdir/transforms/fmap_to_struct_init.mat"

       # create binary WM mask, fast_wmseg is function/script in prepoc_funtions
       fast_wmseg "${mprageBet_base}" # makes ${mprageBet_base}_fast_wmseg (likely mprage_bet_fast_wmseg.nii.gz)

	rel "flirt -in FM_UD_fmap_mag_brain -ref $mprageBet \
             -out fmap_to_struct -omat $funcdir/transforms/fmap_to_struct.mat \
             -interp spline -wmseg ${mprageBet_base}_fast_wmseg \
	      -cost bbr -init $funcdir/transforms/fmap_to_struct_init.mat -dof 6 \
             -schedule ${FSLDIR}/etc/flirtsch/bbr.sch" # $bbrfmap " # bbrfmap rm 20170807WF

	qa_image "$mprageBet" fmap_to_struct fmap_mag_to_struct_bbr.png "Structural image overlaid with bbr-coregistered undistorted fmap mag"
    fi
    
    # unmask the fieldmap (necessary to avoid edge effects)
    rel "fslmaths FM_UD_fmap -abs -bin -mul FM_UD_fmap_mag_brain_mask FM_UD_fmap_mask"

    # the direction here should take into account the initial affine (it needs to be the direction in the EPI)
    rel "fugue --loadfmap=FM_UD_fmap --mask=FM_UD_fmap_mask --unmaskfmap --savefmap=FM_UD_fmap_unmasked --unwarpdir=$fugue_unwarpdir"

    # the following is a NEW HACK to fix extrapolation when fieldmap is too small
    rel "applywarp -i FM_UD_fmap_unmasked -r $mprageBet --premat=$funcdir/transforms/fmap_to_struct.mat -o FM_UD_fmap_to_struct_pad0"
    rel "fslmaths FM_UD_fmap_to_struct_pad0 -abs -bin FM_UD_fmap_to_struct_pad0_innermask"
    rel "fugue --loadfmap=FM_UD_fmap_to_struct_pad0 --mask=FM_UD_fmap_to_struct_pad0_innermask --unmaskfmap --unwarpdir=${fugue_unwarpdir} --savefmap=FM_UD_fmap_to_struct_dilated"
    rel "fslmaths FM_UD_fmap_to_struct_dilated fmapForBBR" #create the fieldmap to be used for BBR func -> struct coregistration

    #cleanup
    mv FM_UD_fmap_to_struct_pad0* FM_UD_fmap_to_struct_dilated* $tempsdir
    imrm grot

    ###
    #Conclusion: We have now created the FM_UD_fmap FM_UD_fmap_mag and FM_UD_fmap_mag_brain files.
    #We also have the fmap_to_struct image, which is the fieldmap aligned to the structural.
    #For now, I am only going to support application of the unwarping step at the applywarp -> MNI phase of preprocessing.
    #This will result in a func -> Struct + Unwarp -> MNI interpolation (pretty good, I think).
    #If we wanted to, when slice timing falls between motion correction and warping to template, we could
    #create a combined MC + unwarp transformation for each volume (the old fslsplit grot + fslmerge approach).
    #This seems like overkill for the moment, esp. since I prefer sliceMotion4d which already does the MC interpolation.

    cd $funcdir

    #explicit return code needed to avoid implicit status of prior command
    return 0
   
}

# move to helper function file, renamed find_and_source_fmconfig
# find_and_source_config(){
#     local fm_cfg="$1"
#     [ -z "$fm_cfg" ] && echo "Want to correct with fieldmaps but dont have a config file!" >&2 && return 1
# 
#     ## need to find fmcfgdir
#     # expect it to be in $0
#     local fmcfgdir=""
#     for pdirs in $0 $(dirname ${BASH_SOURCE[0]}){,/..}/preprocessFunctional; do
#        [ ! -r "$pdirs" ] && continue
#        pdir=$(cd $(dirname $pdirs); pwd)
#        _fmcfgdir=$pdir/fmcfg
#        [ -d $_fmcfgdir ] && fmcfgdir=$_fmcfgdir &&  break
#     done
# 
#     [ -z "$fmcfgdir" -a ! -r "$fm_cfig" ] && echo "cannot find script directory root to find config file for '$fm_cfg'!" >&2 && return 1
# 
#     # Allow --config to be a shorthand lookup, defined here, rather than a config file
#     local fm_cfg_file=$fmcfgdir/$fm_cfg.fmcfg
#     if [ -r $fm_cfg_file ]; then
#       fm_cfg=$fm_cfg_file
#     else
#       case $fm_cfg in
#          cogemo|multimodal|wpc5640 ) fm_cfg=$fmcfgdir/cogemo.fmcfg;;
#          clock|specc|wpc6290|p5 )    fm_cfg=$fmcfgdir/MB5_TR1.0_TE30_60slc.fmcfg;;
#          # dead code -- 20170224
#          trust )                     fm_cfg=$fmcfgdir/trust.fmcfg;;
#          bandit )                    fm_cfg=$fmcfgdir/bandit.fmcfg;;
#          pet    )                    fm_cfg=$fmcfgdir/pet.fmcfg;;
#       esac
#     fi
#     
#     # source config file or warn
#     if [ -n "$fm_cfg" -a -r "$fm_cfg" ]; then
#       rel "using '$fm_cfg' for fieldmap config" c
#       source $fm_cfg 
#     else
#       echo "ERROR: readable config file not provided or understood ($fm_cfg)" >&2
#       return 1
#     fi
# }


# vim: set tabstop=7:
