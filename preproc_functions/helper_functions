#!/bin/bash

#function for taking sequential processing pictures (used in FM unwarping for now)
# Whether to take sequential pictures of processing steps
[ -z "$pics" ] && pics=no #=yes, take

globalcount=0 #order of processing
function _picture {
    # only do this if we are told to
    [ "$pics" == "yes" ] || return 0

    # check we have a save directory
    [ -d $imgdir ] || mkdir $imgdir 

    globalcount=$((( $globalcount+ 1))) #let ..++ can return 0 and break things with set -e 
    name=$(basename $(basename $1 .gz) .nii)
    num=$(printf "%04d" $globalcount)
    imgname=$imgdir/${num}_$name.png
    slicer -u $1 -a $imgname
    convert -scale 200% -fill white -gravity southwest -annotate 0 "$num $name:  $2" $imgname $imgname
}

function deleteFile() {
    #delete a file, if it exists
    if [ -f "$1" ]; then
	rel "rm -f \"$1\""
    fi
}

#rel is shorthand for "run, echo, log"
function rel() {
    #function that runs, echos to terminal, and logs to file an arbitrary command
    cmd="${1}"
    comment=0
    if [[ -n "${2}" && ${2} = c ]]; then
	comment=1
    fi
    
    if [ $comment -eq 0 ]; then
	#echo command to screen verbatim
	echo ${cmd}

	#run command
	eval ${cmd}
	cmdExit=$?
    else
	#echo command to screen with dashes to offset text visually
	echo "----  ${cmd}"
    fi
    
    if [ -n "${logFile}" ]; then
	if [ $comment -eq 1 ]; then
	    cmd="## ${cmd}"
	fi
	echo "${cmd}" >> "${logFile}"
    fi

    return $cmdExit
}

function dimon {
    [ $# -ne 2 ] && echo "dimon function requires <dicom pattern> <output prefix>" && exit 1

    dpat="$1"
    outbase="$2"
    
    #backup ${outbase}.nii if it exists so that Dimon doesn't bomb out
    [ -f "${outbase}.nii" ] && mv "${outbase}.nii" "${outbase}_bak.nii"
    [ -f "${outbase}.nii.gz" ] && mv "${outbase}.nii.gz" "${outbase}_bak.nii.gz"

    rel "Dimon \
	    -infile_pattern \"${dpat}\" \
	    -GERT_Reco \
	    -quit \
	    -dicom_org \
	    -gert_write_as_nifti \
	    -gert_create_dataset \
	    -gert_to3d_prefix \"${outbase}\""

    #-sort_by_acq_time

    rm -f dimon.files*
    rm -f GERT_Reco_dicom*

    #if afnirc has compressor on, then above will already generate nii.gz
    if [ -f "${outbase}.nii" ]; then
	rel "gzip -f \"${outbase}.nii\"" #use -f to force overwrite in case where functional.nii.gz exists, but we want to replace it.
    fi

}

function cleanup_preprocessMprage {
    imrm ${T1}_fast_totbias ${T1}_s20 ${T1}_initmask_s20 ${T1}_hpf ${T1}_hpf2_brain ${T1}_hpf2_s20 \
	${T1}_hpf_brain ${T1}_hpf_brain_mask ${T1}_hpf_s20 \
	${T1}_initfast2_bias ${T1}_initfast2_brain_mask ${T1}_initfast2_brain_mask2 \
	${T1}_initfast2_restore ${T1}_initfast2_seg ${T1}_initfast_bias \
	${T1}_initfast_restore ${T1}_initfast_seg ${T1}_fast_bias_vol2 \
	${T1}_fast_bias_vol32 template_to_subject_warpcoef ${T1}_fast_bias_idxmask
}


function cleanup_preprocessFunctional {

    if [ ${despike} -eq 1 ]; then
	dspre="d"
	deleteFile d_${funcNifti}
    else	   
	dspre=""
    fi

    if [ $no_warp -eq 0 ]; then
	wpre="w"
    else
	wpre=""
    fi

    if [ -n "${fm_phase}" ]; then
	upre="u"
    else
	upre=""
    fi

    echo "dspre: $dspre"
    echo "upre: $upre"
    echo "smoothing_suffix: $smoothing_suffix"

    #interleaved stream
    deleteFile t${dspre}_${funcFile}.nii.gz
    deleteFile mt${dspre}_${funcFile}.nii.gz
    deleteFile ${upre}mt${dspre}_${funcFile}.nii.gz
    deleteFile ${upre}mt${dspre}_${funcFile}_mean_reg.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}.nii.gz
    deleteFile k${upre}mt${dspre}_tmean_mask.nii.gz
    deleteFile ${wpre}k${upre}mt${dspre}_${funcFile}.nii.gz
    deleteFile ${wpre}k${upre}mt${dspre}_${funcFile}_extents_mask.nii.gz
    deleteFile s${wpre}k${upre}mt${dspre}_${funcFile}${smoothing_suffix}.nii.gz
    deleteFile fs${wpre}k${upre}mt${dspre}_${funcFile}${smoothing_suffix}.nii.gz

    deleteFile k${upre}mt${dspre}_${funcFile}_Tmin.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_Tmin_10pctThr.nii.gz
    deleteFile ${upre}mt${dspre}_tmean.nii.gz
    deleteFile k${upre}mt${dspre}_tmean.nii.gz
    deleteFile ${wpre}k${upre}mt${dspre}_tmean.nii.gz
    deleteFile fs${wpre}k${upre}mt${dspre}_mean_float.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_98_2_mask.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_98_2_mask_dil1x.nii.gz
    deleteFile k${upre}mt${dspre}_${funcFile}_masked.nii.gz
    deleteFile s${wpre}k${upre}mt${dspre}_${funcFile}${smoothing_suffix}_usan_size.nii.gz

    #sequential stream
    deleteFile m${dspre}_${funcFile}.nii.gz
    deleteFile m${dspre}_${funcFile}_mean_reg.nii.gz
    deleteFile ${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile t${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile kt${upre}m${dspre}_tmean_mask.nii.gz
    deleteFile ${wpre}kt${upre}m${dspre}_${funcFile}.nii.gz
    deleteFile ${wpre}kt${upre}m${dspre}_${funcFile}_extents_mask.nii.gz
    deleteFile s${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}.nii.gz
    deleteFile fs${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}.nii.gz

    deleteFile kt${upre}m${dspre}_${funcFile}_Tmin.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_Tmin_10pctThr.nii.gz
    deleteFile t${upre}m${dspre}_tmean.nii.gz
    deleteFile kt${upre}m${dspre}_tmean.nii.gz
    deleteFile ${wpre}kt${upre}m${dspre}_tmean.nii.gz
    deleteFile fs${wpre}kt${upre}m${dspre}_mean_float.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_98_2_mask.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_98_2_mask_dil1x.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_mask.nii.gz
    deleteFile kt${upre}m${dspre}_${funcFile}_masked.nii.gz
    deleteFile s${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}_usan_size.nii.gz

    deleteFile ${preSmooth}_mask_allbrain.nii.gz
    deleteFile ${preSmooth}_mask_edgecorrection.nii.gz

    #general files
    deleteFile mc_mean_vol_target.nii.gz
    deleteFile premc_mean_vol.nii.gz

    deleteFile func_to_struct.mat
    deleteFile func_to_struct_init.mat #6 dof transform prior to BBR
    deleteFile func_to_struct.nii.gz

    deleteFile mask_${funcFile}_Tmin_10pctThr.nii.gz

    deleteFile ${prefix}tmean${smoothing_suffix}.nii.gz

    #some more here...
    deleteFile "${threshMask}_2struct.nii.gz"
    deleteFile *98_2_mask_dil1x_outOfAnatBounds.nii.gz
    deleteFile templateMask.nii.gz

    [[ $constrainToTemplate = [Nn] ]] && deleteFile *98_2_mask_dil1x_templateTrim.nii.gz

    deleteFile func_to_standard_warp_allv.nii.gz #onestep_warp when warp is not volume-wise

    rm -rf mcOrig
    rm -rf unwarptemps #intermediate fieldmap files

    deleteFile example_func.nii.gz
    deleteFile premc_mean_vol.nii.gz
    deleteFile mc_initial.nii.gz #initial motion correction to mean functional
    deleteFile mc_target_mask.nii.gz #brain mask for mc_target used for rmsdiff in motion_plots

    deleteFile "*${funcFile}*_rel_mean.rms" #shouldn't be necessary anymore since we compute rms ourselves
    deleteFile "*${funcFile}*_abs_mean.rms"
    deleteFile "_${funcNifti}" #initial reoriented file with just a prepended underscore

    #file containing individual volumes of 4d dataset after fslsplit (used for MC+unwarping)
    [ -d episplit ] && rm -rf episplit

}
