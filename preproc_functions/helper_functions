#!/bin/bash

#function for taking sequential processing pictures (used in FM unwarping for now)
# Whether to take sequential pictures of processing steps
[ -z "$pics" ] && pics=no #=yes, take

globalcount=0 #order of processing
function _picture {
    # only do this if we are told to
    [ "$pics" == "yes" ] || return 0

    # check we have a save directory
    [ -d $imgdir ] || mkdir $imgdir 

    globalcount=$((( $globalcount+ 1))) #let ..++ can return 0 and break things with set -e 
    name=$(basename $(basename $1 .gz) .nii)
    num=$(printf "%04d" $globalcount)
    imgname=$imgdir/${num}_$name.png
    slicer -u $1 -a $imgname
    convert -scale 200% -fill white -gravity southwest -annotate 0 "$num $name:  $2" $imgname $imgname
}

function deleteFile() {
    #echo "to del: $1"

    #delete a file, if it exists
    if [ -f "$1" ]; then
	rel "rm -f \"$1\""
    fi
}

#rel is shorthand for "run, echo, log"
function rel() {
    #function that runs, echos to terminal, and logs to file an arbitrary command
    cmd="${1}"
    comment=0
    if [[ -n "${2}" && ${2} = c ]]; then
	comment=1
    fi
    
    if [ -n "${logFile}" ]; then
	if [ $comment -eq 1 ]; then
	    cmd="## ${cmd}"
	fi
	echo -e "${cmd}" >> "${logFile}"
    fi

    if [ $comment -eq 0 ]; then
	#echo command to screen verbatim
	echo ${cmd}

	#run command
	eval ${cmd}
	cmdExit=$?
    else
	#echo command to screen with dashes to offset text visually
	echo -e "----  ${cmd}"
    fi
    
    return $cmdExit
}

function dimon {
    [ $# -ne 2 ] && echo "dimon function requires <dicom pattern> <output prefix>" && exit 1

    dpat="$1"
    outbase="$2"
    
    #backup ${outbase}.nii if it exists so that Dimon doesn't bomb out
    [ -f "${outbase}.nii" ] && mv "${outbase}.nii" "${outbase}_bak.nii"
    [ -f "${outbase}.nii.gz" ] && mv "${outbase}.nii.gz" "${outbase}_bak.nii.gz"

    rel "Dimon \
	    -infile_pattern \"${dpat}\" \
	    -GERT_Reco \
	    -quit \
	    -dicom_org \
	    -gert_write_as_nifti \
	    -gert_create_dataset \
	    -gert_to3d_prefix \"${outbase}\""

    #-sort_by_acq_time

    rm -f dimon.files*
    rm -f GERT_Reco_dicom*

    #if afnirc has compressor on, then above will already generate nii.gz
    if [[ -f "${outbase}.nii" && $FSLOUTPUTTYPE = NIFTI_GZ ]]; then
	rel "gzip -f \"${outbase}.nii\"" #use -f to force overwrite in case where functional.nii.gz exists, but we want to replace it.
    fi

}

function cleanup_preprocessMprage {
    rel "imrm ${T1}_fast_totbias ${T1}_s20 ${T1}_initmask_s20 ${T1}_hpf ${T1}_hpf2_brain ${T1}_hpf2_s20 \
	${T1}_hpf_brain ${T1}_hpf_brain_mask ${T1}_hpf_s20 \
	${T1}_initfast2_bias ${T1}_initfast2_brain_mask ${T1}_initfast2_brain_mask2 \
	${T1}_initfast2_restore ${T1}_initfast2_seg ${T1}_initfast_bias \
	${T1}_initfast_restore ${T1}_initfast_seg ${T1}_fast_bias_vol2 \
	${T1}_fast_bias_vol32 template_to_subject_warpcoef ${T1}_fast_bias_idxmask \
	${T1}_fast_bias ${T1}_fast_bias_init ${T1}_fast_restore ${T1}_fast_seg \
	${T1}_bet_initbias ${T1}_bet_initial ${T1}_biascorr_brain_mask ${T1}_bet_fast_restore \
	${T1}_bet_fast_bias"
}


# remove flag files indicating a step was completed
# keeps .functional, .detect_tr, .preprocessfunctional_complete
# optionally keeps .motion_correction_complete (if KEEP_MOTION_FILES)
function rm_dotsteps {
    deleteFile ".detect_sliceorder"
    deleteFile ".median_intensity"
    deleteFile ".pct2"
    deleteFile ".csf_ts"
    deleteFile ".csf_ts_deriv"
    deleteFile ".wm_ts"
    deleteFile ".wm_ts_deriv"
    deleteFile ".gs_ts"
    deleteFile ".gs_ts_deriv"
    deleteFile ".motion_demean"
    deleteFile ".motion_deriv"
    deleteFile ".nuisance_regressors"
    deleteFile ".wm_ero2x${ext}"
    deleteFile ".csf_ero2x${ext}"
    deleteFile ".brainmask_ero2x_anat${ext}"
    deleteFile ".brainmask_ero2x${ext}"
    deleteFile ".template_csf_prob${ext}"
    deleteFile ".template_wm_prob${ext}"
    deleteFile ".fieldmap_magnitude"
    deleteFile ".fieldmap_phase"
    deleteFile ".reorient2std_complete"
    deleteFile ".motion_censor_complete"
    deleteFile ".motion_plots_complete"
    #deleteFile ".slice_timing_complete"
    #deleteFile ".motion_correction_complete"
    deleteFile ".skull_strip_complete"
    deleteFile ".func2struct_complete"
    deleteFile ".warp_complete"
    deleteFile ".compute_warp_complete"
    deleteFile ".smoothing_complete"
    deleteFile ".temporal_filtering_complete"
    deleteFile ".rescaling_complete"
    deleteFile ".thresholding_complete"
    deleteFile ".despike_complete"
    deleteFile ".fmunwarp_complete"
    deleteFile ".prepare_fieldmap_complete"
    deleteFile ".nuisance_regression_complete"
    deleteFile ".bandpass_filter_complete"

    # we want to keep motion bits around
    if [ -z "$KEEP_MOTION_FILES" ]; then
      deleteFile ".motion_correction_complete"
      deleteFile ".slice_timing_complete"
    fi
}
function rm_completefiles {
    rel "\nStarting over...\n\nRe-running all preprocessing steps\n" c
    deleteFile ".functional"
    deleteFile ".detect_tr"
    rm_dotsteps
    deleteFile ".preprocessfunctional_complete"
}

function cleanup_preprocessFunctional {

    if [ ${despike} -eq 1 ]; then
	dspre="d"
    else	   
	dspre=""
    fi

    if [ $no_warp -eq 0 ]; then
	wpre="w"
    else
	wpre=""
    fi

    if [ -n "${fm_phase}" ]; then
	upre="u"
    else
	upre=""
    fi

    [ -z "$funcFile" ] && echo "ERROR: $FUNC_NAME does not have funcfile!" && exit 1
    #echo "func: $funcFile"
    #echo "dspre: $dspre"
    #echo "wpre: $wpre"
    #echo "upre: $upre"
    #echo "smoothing_suffix: $smoothing_suffix"
    #echo "ext: $ext"

    #interleaved stream
    deleteFile t_${funcFile}${ext}
    #deleteFile mt_${funcFile}${ext}
    #deleteFile ${upre}mt_${funcFile}${ext}
    #deleteFile ${upre}mt_${funcFile}_mean_reg${ext}
    deleteFile k${upre}mt_${funcFile}${ext}
    deleteFile k${upre}mt_tmean_mask${ext}
    deleteFile ${wpre}${dspre}k${upre}mt_${funcFile}${ext}
    deleteFile ${wpre}${dspre}k${upre}mt_${funcFile}_extents_mask${ext}
    deleteFile s${wpre}${dspre}k${upre}mt_${funcFile}${smoothing_suffix}${ext}
    deleteFile fs${wpre}${dspre}k${upre}mt_${funcFile}${smoothing_suffix}${ext}

    deleteFile k${upre}mt_${funcFile}_Tmin${ext}
    deleteFile k${upre}mt_${funcFile}_Tmin_10pctThr${ext}
    #deleteFile ${upre}mt_tmean${ext}
    deleteFile ${dspre}k${upre}mt_tmean${ext}
    deleteFile ${wpre}${dspre}k${upre}mt_${funcFile}_tmean${ext}
    deleteFile fs${wpre}${dspre}kmt_mean_float${ext}
    deleteFile k${upre}mt_${funcFile}_98_2_mask${ext}
    deleteFile k${upre}mt_${funcFile}_98_2_mask_dil1x${ext}
    deleteFile k${upre}mt_${funcFile}_masked${ext}
    deleteFile s${wpre}${dspre}k${upre}mt_${funcFile}${smoothing_suffix}_usan_size${ext}

    #with one-step warp, often get files such as wuktmd where FM unwarping and MNI warp are adjacent
    #deleteFile mt_${funcFile}${ext}
    #deleteFile mt_${funcFile}_mean_reg${ext}
    deleteFile ${dspre}kmt_${funcFile}${ext}
    deleteFile ${dspre}kmt_tmean_mask${ext}
    deleteFile ${wpre}${upre}${dspre}kmt_${funcFile}${ext}
    deleteFile ${wpre}${upre}${dspre}kmt_${funcFile}_extents_mask${ext}
    deleteFile s${wpre}${upre}${dspre}kmt_${funcFile}${smoothing_suffix}${ext}
    deleteFile fs${wpre}${upre}${dspre}kmt_${funcFile}${smoothing_suffix}${ext}

    deleteFile ${dspre}kmt_${funcFile}_Tmin${ext}
    deleteFile ${dspre}kmt_${funcFile}_Tmin_10pctThr${ext}
    #deleteFile mt_tmean${ext}
    deleteFile kmt_tmean${ext}
    deleteFile ${wpre}${upre}${dspre}kmt_${funcFile}_tmean${ext}
    deleteFile fs${wpre}${upre}${dspre}kmt_mean_float${ext}
    deleteFile kmt_${funcFile}_98_2_mask${ext}
    deleteFile kmt_${funcFile}_98_2_mask_dil1x${ext}
    deleteFile kmt_${funcFile}_masked${ext}
    deleteFile s${wpre}${upre}${dspre}kmt_${funcFile}${smoothing_suffix}_usan_size${ext}

    #sequential stream
    #deleteFile m_${funcFile}${ext}
    #deleteFile m_${funcFile}_mean_reg${ext}
    #deleteFile ${upre}m_${funcFile}${ext}
    #deleteFile t${upre}m_${funcFile}${ext}
    #deleteFile tm_${funcFile}_tmean${ext}
    deleteFile ${dspre}kt${upre}m_${funcFile}${ext}
    deleteFile ${dspre}kt${upre}m_tmean_mask${ext}
    deleteFile ${wpre}${dspre}kt${upre}m_${funcFile}${ext}
    deleteFile ${wpre}${dspre}kt${upre}m_${funcFile}_extents_mask${ext}
    deleteFile s${wpre}${dspre}kt${upre}m_${funcFile}${smoothing_suffix}${ext}
    deleteFile fs${wpre}${dspre}kt${upre}m_${funcFile}${smoothing_suffix}${ext}

    deleteFile kt${upre}m${dspre}_${funcFile}_Tmin${ext}
    deleteFile kt${upre}m${dspre}_${funcFile}_Tmin_10pctThr${ext}
    deleteFile t${upre}m${dspre}_tmean${ext}
    deleteFile kt${upre}m${dspre}_tmean${ext}
    deleteFile ${wpre}kt${upre}m${dspre}_${funcFile}_tmean${ext}
    deleteFile fs${wpre}kt${upre}m${dspre}_mean_float${ext}
    deleteFile kt${upre}m${dspre}_${funcFile}_98_2_mask${ext}
    deleteFile kt${upre}m${dspre}_${funcFile}_98_2_mask_dil1x${ext}
    deleteFile kt${upre}m${dspre}_${funcFile}_mask${ext}
    deleteFile kt${upre}m${dspre}_${funcFile}_masked${ext}
    deleteFile s${wpre}kt${upre}m${dspre}_${funcFile}${smoothing_suffix}_usan_size${ext}

    #with one-step warp, often get files such as wuktmd where FM unwarping and MNI warp are adjacent
    deleteFile m_${funcFile}${ext}
    #deleteFile tm_${funcFile}${ext}
    deleteFile ktm_${funcFile}${ext}
    deleteFile ${dspre}ktm_${funcFile}${ext}
    deleteFile ktm_tmean_mask${ext}
    deleteFile ktm_${funcFile}_tmean_mask${ext}
    deleteFile ${wpre}${upre}${dspre}ktm_${funcFile}${ext}
    deleteFile ${wpre}${upre}${dspre}ktm_${funcFile}_extents_mask${ext}
    deleteFile s${wpre}${upre}${dspre}ktm_${funcFile}${smoothing_suffix}${ext}
    deleteFile fs${wpre}${upre}${dspre}ktm_${funcFile}${smoothing_suffix}${ext}

    deleteFile ktm_${funcFile}_Tmin${ext}
    deleteFile ktm_${funcFile}_Tmin_10pctThr${ext}
    #deleteFile tm_tmean${ext}
    deleteFile ktm_${funcFile}_tmean${ext}
    deleteFile ${wpre}${upre}${dspre}ktm_${funcFile}_tmean${ext}
    deleteFile fs${wpre}${upre}${dspre}ktm_mean_float${ext}
    deleteFile s${wpre}${upre}${dspre}ktm_mean_float${ext}
    deleteFile ktm_${funcFile}_98_2_mask${ext}
    deleteFile ktm_${funcFile}_98_2_mask_dil1x${ext}
    deleteFile ktm_${funcFile}_mask${ext}
    deleteFile ktm_${funcFile}_masked${ext}
    deleteFile s${wpre}${upre}${dspre}ktm_${funcFile}${smoothing_suffix}_usan_size${ext}

    deleteFile ${preSmooth}_mask_allbrain${ext}
    deleteFile ${preSmooth}_mask_edgecorrection${ext}

    #general files
    #deleteFile mc_mean_vol_target${ext}
    #deleteFile premc_mean_vol${ext}

    deleteFile func_to_struct_init.mat #6 dof transform prior to BBR
    deleteFile fmap2epi_bbr.mat
    deleteFile struct_to_func.mat
    deleteFile func_to_struct${ext}
    deleteFile func_to_struct_allv${ext}
    deleteFile func_to_struct_nounwarp${ext}

    deleteFile mask_${funcFile}_Tmin_10pctThr${ext}

    deleteFile ${prefix}tmean${smoothing_suffix}${ext}

    #some more here...
    deleteFile "${threshMask}_2struct${ext}"
    deleteFile *98_2_mask_dil1x_outOfAnatBounds${ext}
    deleteFile templateMask${ext}

    [[ $constrainToTemplate = [Nn] ]] && deleteFile *98_2_mask_dil1x_templateTrim${ext}

    deleteFile func_to_standard_warp_allv${ext} #onestep_warp when warp is not volume-wise

    rm -rf mcOrig
    rm -rf unwarptemps #intermediate fieldmap files
    #[ -d mc_mats ] && rm -rf mc_mats #original motion transformation matrices

    deleteFile example_func${ext}
    deleteFile premc_mean_vol${ext}
    #deleteFile mc_initial${ext} #initial motion correction to mean functional
    #deleteFile mc_target_mask${ext} #brain mask for mc_target used for rmsdiff in motion_plots

    deleteFile "*${funcFile}*_rel_mean.rms" #shouldn't be necessary anymore since we compute rms ourselves
    deleteFile "*${funcFile}*_abs_mean.rms"
    deleteFile "_${funcNifti}" #initial reoriented file with just a prepended underscore

    #file containing individual volumes of 4d dataset after fslsplit (used for MC+unwarping)
    [ -d episplit ] && rm -rf episplit

    deleteFile epi_bet${ext}

    deleteFile mot_intens_mask${ext} #used by fsl_motion_outliers

    deleteFile epiref_to_struct_init${ext}
    deleteFile epiref_to_struct_init.mat
    deleteFile epiref_to_struct_nounwarp${ext}
    deleteFile epiref_brain_bias${ext}
    deleteFile epiref_brain_restore${ext}
    deleteFile func_to_epiref${ext}
    #deleteFile mc_target_brain_bias${ext}
    #deleteFile mc_target_brain_restore${ext}

    deleteFile dktm_${funcFile}_wavelet_noise.nii.gz
    deleteFile dkmt_${funcFile}_wavelet_noise.nii.gz

    if [[ "$nuisance_regression" -eq 1 || "$bandpass_filter" -eq 1 ]]; then
	deleteFile ns${wpre}${upre}${dspre}ktm_${funcFile}${smoothing_suffix}${ext}
    fi


    ## Files left over from Finn's pipeline
    #wktm_rest_1_98_2_mask_dil1x.nii.gz
    #wktm_rest_1_98_2_mask_dil1x_templateTrim.nii.gz
    deleteFile ${wpre}k${upre}tm_${funcFile}_98_2_mask_dil1x${ext}
    deleteFile ${wpre}k${upre}tm_${funcFile}_98_2_mask_dil1x_templateTrim${ext}
    ###

    if [ -n "$upre" ]; then
       deleteFile ${upre}mt_${funcFile}${ext}
       deleteFile ${upre}mt_${funcFile}_mean_reg${ext}
       deleteFile ${upre}mt_tmean${ext}
       deleteFile ${upre}m_${funcFile}${ext}
       deleteFile t${upre}m_${funcFile}${ext}
    fi

    # remove motion files if we aren't told to keep them
    # this option implemented to keep time consuming 4d motion computation
    if [[ -z "$KEEP_MOTION_FILES" ]]; then

      deleteFile m_${funcFile}${ext}
      deleteFile m_${funcFile}_mean_reg${ext}

      deleteFile tm_tmean${ext}
      deleteFile tm_${funcFile}_tmean${ext}
      deleteFile tm_${funcFile}${ext}

      deleteFile mt_${funcFile}${ext}
      deleteFile mt_${funcFile}${ext}
      deleteFile mt_${funcFile}_mean_reg${ext}
      deleteFile mt_tmean${ext}

      [ -d mc_mats ] && rm -rf mc_mats #original motion transformation matrices

      deleteFile mc_initial${ext} #initial motion correction to mean functional
      deleteFile mc_target_mask${ext} #brain mask for mc_target used for rmsdiff in motion_plots
      

      deleteFile mc_target_brain_bias${ext}
      deleteFile mc_target_brain_restore${ext}

      deleteFile mc_mean_vol_target${ext}
      deleteFile premc_mean_vol${ext}

      # in case we missed the empty upre
      deleteFile ${upre}mt_${funcFile}${ext}
      deleteFile ${upre}mt_${funcFile}_mean_reg${ext}
      deleteFile ${upre}mt_tmean${ext}
      deleteFile ${upre}m_${funcFile}${ext}
      deleteFile t${upre}m_${funcFile}${ext}

    fi

    # keeps .functional, .detect_tr, .preprocessfunctional_complete
    # optionally keeps .motion_correction_complete (if KEEP_MOTION_FILES)
    rm_dotsteps
}

# read_preproc_cmd does not work!
# sets $@ for function instead of global
function read_preproc_cmd {
 if [ -f .preproc_cmd ]; then
   read cmd < .preproc_cmd
   # disable wildcard expansion so that -dicom patterns don't get expanded
   set -f 
   # change positional parameters to stored settings
   set -- $cmd
   # re-enable wildcard expansion as usual
   set +f 
 else
   echo "no .preproc_cmd files, cannot read!"
   exit 1
 fi
}


# given the NAME of an array that contains the names of other variables 
# (presumably global variable names used by a function)
# print the variable name and value
# e.g. GLOBALS=(template mask)
#      printvariablesin GLOBALS
# ouptut like:
#      template=mni
#      mask=subj_mask.nii.gz
# saved to file '.$globalsarrayname.cfg'
function print_vars_in {
   # scary bash indirect reference of array index
   # to build array globals from passed in variable name
   local globalarrayname=$1
   [ -z "$globalarrayname" ] && warn "$FUNC_NAME expects the name of a global array as only input" && return 1

   local ref="$globalarrayname[@]"
   local globals=(${!ref})

   (
   echo "# $(date +%F/%H:%M)"
   for var in ${globals[@]};do
      echo "$var='${!var}'"
   done
   echo
   ) >> .${globalarrayname,,}.cfg
}

# vim: set tabstop=7:
