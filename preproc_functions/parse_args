#!/bin/bash

function parse_args {
    ## parse input arguments, initialize default parameter settings
    ## when called from preprocessFunctional, must pass "$@", which is all input parameters to script
    
    #initialize defaults
    funcFile=
    smoothing_kernel="5"
    bandpass_filter=0 #no bandpass by default
    betFrac=0.3 #default fractional intensity threshold
    cleanup=0
    cleanup_only=0
    compute_warp=0 #used for -compute_warp_only. Specifies to compute warp to template without applying it to preprocessed data.
    constrainToTemplate="y"
    deoblique_all=0
    despike=0
    despikeThresh="2.5 4.0"
    delDicom=
    detectSiemens=0
    dicomPattern=
    DISTORTION_DIR= # alterntaive to preprocessing fieldmaps within preprocessFunctional (more like preprocessMprage). dir most likely named "warp"
    dte=
    dwelltime=     #effective echo spacing. set by -epi_echospacing or by fmcfg file
    epiTE=
    flip_topup_pedir=0
    fm_phase=
    fm_magnitude=
    fm_cfg=
    funcRefimg=
    funcStructFlirtDOF="bbr" #boundary-based registration in FSL 5.0+
    funcWarpInterp="spline"
    hpFilter=120s #default to 120s hp filter
    ica_aroma=0 #whether to run smoothed data through ICA-AROMA
    logFile="preprocessFunctional.log"
    mc_first= #default to empty and choose at stage of motion + slice timing depending on user specification and slice acquisition order
    mc_movie=0
    mc_program="mcflirt"
    motionCensor=
    motionSinc="y"
    no_hp=0
    no_st=0
    no_smooth=0
    no_warp=0
    autocorr_with_basis=0 # -rmautocorr, 20170420WF -- added in nuisance_regression, 3dREMLfit basis 
    nuisance_regression=0
    nuisance_compute=0
    nuisance_file=.nuisance_regressors
    output_basename=functional #base prefix of NIfTI file after dicom -> NIfTI conversion
    MATLAB_RAM_limit=3 #3GB wavelet despike RAM limit by default (more is faster, but can be a hog when processing in parallel).
    MATLAB_single_thread=
    ref_vol=  #don't set a motion correction reference volume by default
    rescalingMethod="10000_globalmedian" #scale whole brain 4D by single constant to normalize median to 10000.
    se_phasepos=
    se_phaseneg=
    signallossthresh=0.9 # Areas with 90% or more signal loss in fieldmap are masked out. Will be overridden by an fmcfg file if specified
    sliceAcquisition= #never assume slice acquistion order. Force definition or use auto-detect from DICOM.
    sliceMotion4D=0
    sliceTimesFile=
    smoother="susan"
    st_first= #default to empty and choose default based on slice acquisition order (sequential versus interleaved)
    thresholdMethod="98_2"
    tr= #never assume a TR. Force definition or use auto-detect from DICOM.
    templateBrain="${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_3mm" #default to new 2009 MNI
    templateName=MNI_3mm
    unwarpdir= #set by -epi_pedir or by fmcfg file
    waveletDespike=0
    waveletM1000=0
    waveletThreshold=10
    verbose=
    KEEP_MOTION_FILES=
    n_rm_firstvols=0

    #figure out file extension for FSL programs
    if [ -z $FSLOUTPUTTYPE ]; then
	export FSLOUTPUTTYPE=NIFTI_GZ
    fi

    if [ $FSLOUTPUTTYPE = NIFTI_GZ ]; then
	ext=".nii.gz"
    elif [ $FSLOUTPUTTYPE = NIFTI ]; then
	ext=".nii"
    else
	echo "Not setup to handle FSLOUTPUTTYPE: $FSLOUTPUTTYPE."
	exit 1
    fi

    #if no parameters are passed in, then print help and exit.
    if [ $# -eq 0 ]; then
	#check for resume
	if [ -f .preproc_cmd ]; then
	    read cmd < .preproc_cmd
	    #delete -startover from positional parameters, if present
	    #if running -cleanup_only, don't want to delete .*complete files.
	    #if running -startover, don't need to run rm_completefiles again.
	    cmd="${cmd/-startover/}"
	    echo -e "\npreprocessFunctional called initially with parameters below:\n\n"
	    echo "$cmd"
	    local resume=
	    until [[ "$resume" = [ny] ]]; do
		echo ""
		read -sn1 -p "Resume run with these settings? (y/n)" resume
	    done
	    echo ""

	    if [ $resume = y ]; then
              #disable wildcard expansion so that -dicom patterns don't get expanded
		set -f 
              # change positional parameters to stored settings
		set -- $cmd
              # re-enable wildcard expansion as usual
		set +f
	    else
		echo -e "\n\nQuitting script."
		exit 0
	    fi
	else
	    printHelp
	    exit 0
	fi
    elif [ $# -eq 1 ]; then
	if [ $1 = -cleanup_only ]; then
	    cleanup_only=1
	    cleanup=1
	elif [ $1 = -startover ]; then
	    rm_completefiles
	elif [ $1 = -help ]; then
	    printHelp
	    exit 0
	elif [ $1 = -resume ]; then
	    echo "Resuming preprocessing using existing settings."
	else
	    echo "Unable to determine what to do with call: preprocessFunctional ${1}"
	    exit 1
	fi

	if [ -f .preproc_cmd ]; then
	    read cmd < .preproc_cmd
	    cmd="${cmd/-startover/}"
           # disable wildcard expansion so that -dicom patterns don't get expanded
           set -f 
           # change positional parameters to stored settings
	    set -- $cmd
           # re-enable wildcard expansion as usual
	    set +f 
	else
	    echo "-cleanup_only or -startover specified alone, but no known preprocessing call in .preproc_cmd."
	    exit 1
	fi

    elif [ $# -eq 2 ] && 
         [[ "$@" =~ -cleanup ]] && # cleanup or cleanup_only, doesn't matter
         [[ "$@" =~ -keep_motion_files ]]; then
	cleanup_only=1
	cleanup=1
       KEEP_MOTION_FILES=1
	if [ -f .preproc_cmd ]; then
	    read cmd < .preproc_cmd
	    cmd="${cmd/-startover/}"
           # disable wildcard expansion so that -dicom patterns don't get expanded
           set -f 
           # change positional parameters to stored settings
	    set -- $cmd
           # re-enable wildcard expansion as usual
	    set +f 
	else
	    echo "doesn't look like we've run anything yet. dont know how to -cleanup_only and -keep_motion_files"
	    exit 1
	fi
      
    else
       # don't overwrite
       [ -r .preproc_cmd ] && mv .preproc_cmd .preproc_cmd_mv$(date +%s)
	#write the parameter settings to file
       # for resuming failed run.
	echo "$@" > .preproc_cmd 
    fi

    #echo "about to process with cmd: $@"

    #process command line parameters
    while [ _$1 != _ ] ; do
	if [[ $1 = -4d || $1 = -4D ]] ; then
	    funcFile="${2}"
	    funcNifti="${funcFile}" #retains file extension
	    shift 2
	elif [ $1 = -bandpass_filter ]; then
	    no_hp=1 #bandpass and high-pass are mutually exclusive
	    bandpass_filter=1
	    bpLow="${2}"
	    bpHigh="${3}"
	    shift 3
	elif [ $1 = -bet_frac ]; then
	    betFrac="${2}"
	    shift 2
	elif [ $1 = -cleanup ]; then
	    cleanup=1
	    shift 1
	elif [ $1 = -cleanup_only ]; then
	    #I'm a bit dubious about letting -cleanup_only be passed alongside the rest of a call, rather than
	    #relying on the .preproc_cmd code above, but keeping this for now.
	    cleanup_only=1
	    cleanup=1
	    shift 1
	elif [ $1 = -compute_warp_only ]; then
	    no_warp=1
	    compute_warp=1
	    shift 1
	elif [ $1 = -custom_slice_times ]; then
	    sliceTimesFile="$2"
	    sliceMotion4D=1 #for now, this option is only relevant for sliceMotion4d correction
	    shift 2
	elif [ $1 = -constrain_to_template ]; then
	    if [[ $2 = [NnYy] ]]; then
		constrainToTemplate="${2}"
		shift 2
	    else
		echo -e "Unrecognized -constrain_to_template parameter: ${2}.\n  Options are: y or n."
		exit 1
	    fi
	elif [ $1 = -delete_dicom ]; then
	    if [[ $2 = "delete" || $2 = "yes" || $2 = "no" || $2 = "archive" ]]; then
		delDicom="${2}"
		shift 2
	    else
		echo -e "Unrecognized -delete_dicom: ${2}.\n  Options are: -delete_dicom delete yes no archive."
		exit 1
	    fi
	elif [ $1 = -deoblique_all ]; then
	    deoblique_all=1
	    shift 1
	elif [ $1 = -despike ]; then
	    despike=1
	    shift 1
	elif [ $1 = -despike_thresh ]; then
	    despike=1
	    despikeThresh="$2 $3"
	    shift 3
	elif [ $1 = -dicom ]; then
	    dicomPattern="${2}"
	    shift 2
	elif [ $1 = -distortion_dir ]; then
	    DISTORTION_DIR=$(abspath "${2}")
           [ -z "$DISTORTION_DIR" -o ! -d "$DISTORTION_DIR" ] && echo "distortion_dir '$2' ('$DISTORTION_DIR') DNE!" && exit 1
           # use fm_cfg from distortion directoyr unless we've already specifed a fm_cfg
           [ -z "$fm_cfg" -a -r "$DISTORTION_DIR/fm.cfg" ] && export fm_cfg="$DISTORTION_DIR/fm.cfg"
	    shift 2
	elif [ $1 = -epi_echospacing ]; then
	    dwelltime="${2}"
	    shift 2
	elif [ $1 = -epi_pedir ]; then
	    unwarpdir="${2}" #should be x/x-/y/y-/z/z-

	    #fix pickiness of FUGUE
	    [ "$unwarpdir" = -x ] && unwarpdir="x-" && echo "Please use -epi_pedir x-"
	    [ "$unwarpdir" = -y ] && unwarpdir="y-" && echo "Please use -epi_pedir y-"
	    [ "$unwarpdir" = -z ] && unwarpdir="z-" && echo "Please use -epi_pedir z-"
	    shift 2
	elif [ $1 = -epi_te ]; then #echo time of EPI data
	    epiTE=$( echo "($2)/1000" | bc -l ) # convert TE into seconds for sigloss
	    shift 2
	elif [ $1 = -flip_topup_pedir ]; then
	    flip_topup_pedir=1
	    shift 1
	elif [ $1 = -fm_phase ]; then
	    fm_phase="${2}"
	    shift 2
	elif [ $1 = -fm_magnitude ]; then
	    fm_magnitude="${2}"
	    shift 2
	elif [ $1 = -fm_cfg ]; then
	    fm_cfg="${2}"
	    shift 2
	elif [ $1 = -func_struc_dof ]; then
	    if [[ $2 = "bbr" || $2 = "6" || $2 = "7" || $2 = "12" ]]; then
		funcStructFlirtDOF="${2}"
		shift 2
	    else
		echo -e "Unrecognized -func_struc_dof: ${2}.\n  Options are: -func_struc_dof bbr, 6, 7, 12."
		exit 1
	    fi
	elif [ $1 = -func_refimg ]; then
	    funcRefimg="${2}"
	    shift 2
	elif [ $1 = -help ]; then	
	    printHelp
	    exit 0
	elif [ $1 = -hp_filter ]; then
	    hpFilter="${2}"
	    shift 2
	elif [ $1 = -ica_aroma ]; then
	    ica_aroma=1
	    shift 1
	elif [ $1 = -log ]; then
	    logFile="${2}"
	    shift 2
	elif [ $1 = -mc_first ]; then
	    mc_first=1
	    st_first=0
	    shift 1
	elif [ $1 = -mc_movie ]; then
	    mc_movie=1
	    shift 1
	elif [ $1 = -mc_program ]; then
	    if [[ $2 = "3dvolreg" || $2 = "mcflirt" ]]; then
		mc_program="${2}"
		shift 2
	    else
		echo -e "Unrecognized -mc_program: ${2}.\n  Options are: -mc_program 3dvolreg, mcflirt."
		exit 1
	    fi
	elif [ $1 = -motion_censor ]; then
	    motionCensor="${2}"
	    shift 2
	elif [ $1 = -motion_sinc ]; then
	    if [[ $2 = [NnYy] ]]; then
		motionSinc="${2}"
		shift 2
	    else
		echo -e "Unrecognized -motion_sinc parameter: ${2}.\n  Options are: y or n."
		exit 1
	    fi
	elif [ $1 = -mprage_bet ]; then
	    mprageBet="${2}"
	    shift 2
	elif [ $1 = -no_hp ]; then
	    no_hp=1
	    shift 1
	elif [ $1 = -no_smooth ]; then
	    no_smooth=1
	    shift 1
	elif [ $1 = -no_st ]; then
	    no_st=1
	    shift 1
	elif [ $1 = -no_warp ]; then
	    no_warp=1
	    shift 1
	elif [ $1 = -nuisance_file ]; then
	    nuisance_file="${2}"
	    shift 2
	elif [ $1 = -nuisance_compute ]; then
	    nuisance_compute=1
	    nuisance_regressors="${2}"
	    shift 2
	elif [ $1 = -nuisance_regression ]; then
	    nuisance_regression=1
	    nuisance_regressors="${2}"
	    shift 2
	elif [ $1 = -output_basename ]; then
	    output_basename="${2}"
	    shift 2
	elif [ $1 = -ref_vol ] ; then
            ref_vol="${2}"
            shift 2
       elif [ $1 = -rmautocorr ]; then
           autocorr_with_basis=1
           shift
	elif [ $1 = -rescaling_method ]; then
	    if [[ $2 = "10000_globalmedian" || $2 = "100_voxelmean" ]]; then
		rescalingMethod="${2}"
		shift 2
	    else
		echo -e "Unrecognized -rescaling_method: ${2}.\n  Options are: -rescaling_method 10000_globalmedian or -rescaling_method 100_voxelmean"
		exit 1
	    fi
	elif [ $1 = -slice_acquisition ]; then
	    if [[ $2 = "interleaved" || $2 = "seqasc" || $2 = "seqdesc" ]]; then
		sliceAcquisition="${2}"
		shift 2
	    else
		echo "Slice acquisition setting not recognized. Options are: seqdesc, seqasc, and interleaved"
		exit 1
	    fi
	elif [ $1 = -4d_slice_motion ]; then
	    sliceMotion4D=1
	    mc_program="sliceMotion4d"
	    shift 1
	elif [ $1 = -se_phaseneg ]; then
	    se_phaseneg="${2}"
	    shift 2
	elif [ $1 = -se_phasepos ]; then
	    se_phasepos="${2}"
	    shift 2
	elif [ $1 = -siemens ]; then
	    detectSiemens=1
	    shift 1
	elif [ $1 = -smoother ]; then
	    smoother="${2}"
	    shift 2
	elif [ $1 = -startover ]; then
	    rm_completefiles
	    shift 1
	elif [ $1 = -smoothing_kernel ] ; then
            smoothing_kernel="${2}"
            shift 2
	elif [ $1 = -st_first ]; then
	    st_first=1
	    mc_first=0
	    shift 1
	elif [ $1 = -template_brain ]; then
	    templateName="${2}"
	    case $2 in
		Tal_3mm) templateBrain="${stddir}/talairach_fsl_mni152/TalFSL_MNI152_T1_3mm_brain" ;;
		MNI_FSL_3mm) templateBrain="${stddir}/fsl_mni152/MNI152_T1_3mm_brain" ;;
		MNI_3mm) templateBrain="${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_3mm" ;;
		MNI_2.3mm) templateBrain="${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_2.3mm" ;;
		SPM_2mm) templateBrain="${stddir}/spm8_mni/T1_brain" ;;
		MNI_2mm) templateBrain="${stddir}/mni_icbm152_nlin_asym_09c/mni_icbm152_t1_tal_nlin_asym_09c_brain_2mm" ;;
		*) echo -e "Reference brain -template_brain ${2} not recognized. Options are MNI_3mm, MNI_FSL_3mm, SPM_2mm, and Tal_3mm."; exit 1 ;;
	    esac
	    shift 2
	elif [ $1 = -threshold ]; then
	    if [[ $2 = "98_2" || $2 = "10" ]]; then
		thresholdMethod="${2}"
		shift 2
	    else
		echo -e "Unrecognized thresholding parameter: ${2}.\n  Options are: 98_2 or 10."
		exit 1
	    fi
	elif [ $1 = -tr ]; then
	    tr="${2}"
            shift 2
	elif [ $1 = -trio_tim ]; then
	    #deprecated: -siemens preferred
	    detectSiemens=1
	    shift 1
       elif [ $1 = -trunc   ]; then
           n_rm_firstvols=$2
           shift 2

	elif [ $1 = -verbose ]; then
	    verbose=1
	    set -xv
	    shift 1
	elif [ $1 = -warpcoef ]; then
	    warpCoef="${2}"
	    shift 2
	elif [ $1 = -warp_interpolation ]; then
	    if [[ $2 = "sinc" || $2 = "trilinear" || $2 = "spline" ]]; then
		funcWarpInterp="${2}"
		shift 2
	    else
		echo -e "Unrecognized -warp_interpolation parameter: ${2}.\n  Options are: sinc, spline, or trilinear."
		exit 1
	    fi
	elif [ $1 = -wavelet_despike ]; then
	    waveletDespike=1
	    despike=1
	    shift 1
	elif [ $1 = -wavelet_m1000 ]; then
	    waveletM1000=1
	    shift 1
	elif [ $1 = -wavelet_threshold ]; then
	    waveletThreshold="${2}"
	    shift 2
	elif [ $1 = -keep_motion_files ]; then
	    # probably dont see this, -cleanup_only skips this parsing
	    KEEP_MOTION_FILES=1
	    shift 1
	else
	    #printHelp
	    echo -e "----------------\n\n"
	    echo "Unrecognized command line parameter: ${1}"
	    exit 1
	fi
    done

    #If we have previously converted to NIfTI (dicom_to_nifti function), then the name of the file (i.e., funcNifti) should be stored in .functional. If this exists, read it and use it.
    if [ -f .functional ]; then
	[ -n "$funcFile" ] && local fcache="$funcFile"
	read funcNifti < .functional
	funcFile=$( remove_ext $funcNifti )

	if [[ -n "$fcache" && "$fcache" != "$funcFile" ]]; then
	    rel "This is odd. You seem to have specified -4d, but I found a .functional file, which implies starting from DICOM. I will use $funcFile, not $fcache" c
	fi
	
	if [ ! -r "$funcNifti" ]; then
	    rel "Tried to use the 4d file $funcNifti as input, but failed to locate it." c
	    exit 1
	fi
    fi

    #trim off file extension for functional file
    if [ -n "$funcFile" ]; then
	if [ ! -r ${funcFile} ]; then
	    #passed in parameter does not exist or does not have .nii or nii.gz extension. Need to test for file with added extension
	    if [ -r "${funcFile}.nii" ]; then
		funcNifti="${funcFile}.nii"
		rel "Assuming that ${funcNifti} is the intended -4d input." c
	    elif [ -r "${funcFile}.nii.gz" ]; then
		funcNifti="${funcFile}.nii.gz"
		rel "Assuming that ${funcNifti} is the intended -4d input." c
	    else
		rel "Raw functional 4d file: $funcFile does not exist.\nAttempted to look for ${funcFile}.nii and ${funcFile}.nii.gz to no avail.\nExiting.\n" c
		exit 1
	    fi
	fi

	if [ ${funcFile:(-7)} = ".nii.gz" ]; then
	    #strip off the suffix for FSL processing and makes filenames easier to build.
	    lenFile=${#funcFile}
	    lenSub=$( expr $lenFile - 7 )
	    funcFile=${funcFile:0:$lenSub}
	elif [ ${funcFile:(-4)} = ".nii" ]; then
	    #strip off the suffix for FSL processing
	    lenFile=${#funcFile}
	    lenSub=$( expr $lenFile - 4 )
	    funcFile=${funcFile:0:$lenSub}
	fi
    fi

    #Not legal to pass in requests for MC versus ST order when using 4d slice + motion.
    if [[ $sliceMotion4D -eq 1 && $no_st -eq 1 ]]; then
	echo "Cannot request -no_st with -4d_slice_motion"
	exit 1
    fi

    if [[ $sliceMotion4D -eq 1 && $st_first -eq 1 ]]; then
	echo "Cannot request -st_first with -4d_slice_motion"
	exit 1
    fi

    if [[ $sliceMotion4D -eq 1 && $mc_first -eq 1 ]]; then
	echo "Cannot request -mc_first with -4d_slice_motion"
	exit 1
    fi

    if [[ $autocorr_with_basis -eq 1 && $bandpass_filter -eq 0 ]]; then
	echo "Cannot request -rmautocorr without -bandpass_filter "
	exit 1
    fi

    #whether to use a fieldmap, either GRE or TOPUP
    use_fm=0
    if [[ -n "$fm_phase" || -n "$se_phasepos"  || -n "$DISTORTION_DIR" ]]; then
	use_fm=1
    fi

    #if using TOPUP (SE fieldmap approach), do we use the 'direct' pipeline (i.e., WarpField from TopupPreprocessingAll),
    #or the indirect approach of the rad/s field pushed through the typical GRE fieldmap pipeline (incl. registration to structural)
    [[ -n "$se_phasepos" ]] && topup_direct=1 || topup_direct=0 #hidden at the moment, perhaps expose option later
    
    #determine whether flirt version is new enough to handle BBR coregistration
    #if we have v6.0+, then incorporate fieldmap unwarping into BBR func2struct
    #and use resulting unwarping information for EPI -> unwarp -> struct -> MNI transform.
    #for older versions, need to use EPI-registered fieldmap for unwarping
    flirtVersion=$( flirt | head -1 | perl -pe 's/^FLIRT version ([0-9\\.]+)$/\1/' )
    bbrCapable=$( echo "${flirtVersion} >= 6" | bc )

    #The smoothing kernel parameter is expected to be the full width at half
    #maximum (FWHM) value (in mm). FWHM refers to the width of the Gaussian shape
    #on the x-axis at half of the maximum y value
    #(see http://imaging.mrc-cbu.cam.ac.uk/imaging/PrinciplesSmoothing).
    #It is common to conceptualize Gaussian curves in terms of their standard
    #deviation (sigma). Sigma is related to FWHM by the following equation:
    #FHWM=sigma * sqrt(8*log(2))
    #Hence, because FSL expects our smoothing specification to be a sigma,
    #we divide the FWHM value provided by $smoothing_kernel by 2.355 (approximately 8*log(2).

    sigma=$( echo "scale=5; $smoothing_kernel/2.355" | bc )

    #smoothed files include the FHWM as a sufix
    [ $no_smooth -eq 0 ] && smoothing_suffix="_${smoothing_kernel}" || smoothing_suffix=
    
    if [ -n "${logFile}" ]; then
	archive_file "${logFile}" #move any existing files out of the way
	
        #add absolute path to log file location
	logFile="${funcdir}/$( basename $logFile )" ##TODO: make path handling more robust to non-local directories
	
	echo "#!/bin/bash" > "${logFile}"
	echo "## Log of preprocessFunctional commands" >> "${logFile}"
	echo -e "## Call: $thiscommandinfo" >> "${logFile}"
    fi

    if uname -n | grep -q "comp-hm.*aci.ics.psu.edu"; then
	rel "Running on ACI high-memory cluster. Increase MATLAB RAM limit and force MATLAB single threading." c
	MATLAB_RAM_limit=16
	MATLAB_single_thread="-singleCompThread"
    fi

}

#process command line parameters for preprocessMprage
function parse_mprage_args() {

    while [ _$1 != _ ] ; do
	if [[ $1 = -b || $1 = -bet_opts ]] ; then
	    betOpts="${2}"
	    shift 2
	elif [[ $1 = -bright_skull ]] ; then
	    bright_skull=1
	    shift 1
	elif [[ $1 = -cleanup ]]; then
	    cleanup=1
	    shift 1
	elif [[ $1 = -cleanup_only ]]; then
	    cleanup_only=1
	    shift 1
	elif [[ $1 = -custom_brainmask ]]; then
	    brainmask="${2}"
	    shift 2
	elif [[ $1 = -d || $1 = -delete_dicom ]]; then
	    low=$( echo "${2}" | awk '{print tolower($0)}' ) 	#force lower case input
	    if [[ $2 = "delete" || $2 = "yes" || $2 = "no" || $2 = "archive" ]]; then
		delDicom="${low}"
		shift 2
	    elif [[ $2 = "y" || $2 = "n" || $2 = "a" ]]; then
		echo "Use of single character deprecated. Please change to yes, no, archive."
		delDicom="${low}"
		shift 2
	    else
		echo -e "Unrecognized ${1}: ${2}.\n  Options are: ${1} delete yes no archive."
		exit 1
	    fi
	elif [[ $1 = -p || $1 = -dicom ]]; then
	    dicomPattern="${2}"
	    shift 2
	elif [[ $1 = -fnirt_mask ]]; then
	    fnirt_mask="${2}"
	    shift 2
	elif [[ $1 = -grad_unwarp ]]; then
	    gcoeffs="${2}"
	    shift 2
	elif [[ $1 = -h || $1 = -help ]]; then
	    printHelp
	    exit 0
	elif [ $1 = -log ]; then
	    logFile="${2}"
	    shift 2
	elif [[ $1 = -no_bias ]]; then
	    biasCorrect=0
	    shift 1
	elif [[ $1 = -n || $1 = -nifti ]]; then
	    nifti="${2}"
	    shift 2
	elif [[ $1 = -no_robustfov ]]; then
	    robustfov=0
	    shift 1
	elif [[ $1 = -o || $1 = -output ]]; then
	    outputFile="${2}"
	    shift 2
	elif [[ $1 = -r || $1 = -template_brain ]]; then
	    reference="${2}"
	    shift 2
	elif [[ $1 = -ss_method ]]; then
	    ssmethod="${2}"
	    shift 2
	elif [[ $1 = -strongbias || $1 = -strong_bias ]]; then
	    strongBias=1
	    shift 1
	elif [[ $1 = -warpres || $1 = -w ]]; then
	    wr="${2}"
	    if [[ ! ${wr} =~ ^[0-9]+$ ]]; then
		echo "-warpres must be an integer (e.g., 10)."
		exit 1
	    fi
	    shift 2
	elif [[ $1 = -weakbias || $1 = -weak_bias ]]; then
	    strongBias=0
	    shift 1
	else
            printHelp
            echo -e "----------------\n\n"
            echo "Unrecognized command line parameter: ${1}"
            exit 1
	fi
    done

    #explicit return code needed to avoid implicit status of prior command
    return 0

}

# vim: set tabstop=7:
